/**
 * CHIP-8 Simple Falling Block Game
 *
 * A minimal falling block game for demonstrating pay-per-move.
 * Uses polling for key input instead of blocking.
 *
 * Controls:
 * - 4: Move left
 * - 6: Move right
 * - 5: Move up (rotate placeholder)
 * - 7: Move down (drop)
 */

// CHIP-8 opcodes for a simple falling block game
// V0 = X position (block), V1 = Y position (block)
// V4-V7 hold key values for checking
const ROM_BYTES = new Uint8Array([
	// === INIT (0x200) ===
	0x00,
	0xe0, // 0x200: CLS - Clear screen
	0x60,
	0x1e, // 0x202: LD V0, 30 - X position (center)
	0x61,
	0x08, // 0x204: LD V1, 8  - Y position
	0x64,
	0x04, // 0x206: LD V4, 4  - Key 4 (left)
	0x65,
	0x06, // 0x208: LD V5, 6  - Key 6 (right)
	0x66,
	0x05, // 0x20A: LD V6, 5  - Key 5 (up)
	0x67,
	0x07, // 0x20C: LD V7, 7  - Key 7 (down)

	// === DRAW BORDERS ===
	// Draw left border (x=8)
	0x6a,
	0x08, // 0x20E: LD VA, 8
	0x6b,
	0x00, // 0x210: LD VB, 0
	0xa2,
	0xa0, // 0x212: LD I, border sprite (at 0x2A0)

	// Left border loop
	0xda,
	0xb1, // 0x214: DRW VA, VB, 1
	0x7b,
	0x02, // 0x216: ADD VB, 2
	0x3b,
	0x1e, // 0x218: SE VB, 30
	0x12,
	0x14, // 0x21A: JP 0x214

	// Draw right border (x=55)
	0x6a,
	0x37, // 0x21C: LD VA, 55
	0x6b,
	0x00, // 0x21E: LD VB, 0

	// Right border loop
	0xda,
	0xb1, // 0x220: DRW VA, VB, 1
	0x7b,
	0x02, // 0x222: ADD VB, 2
	0x3b,
	0x1e, // 0x224: SE VB, 30
	0x12,
	0x20, // 0x226: JP 0x220

	// Draw bottom border (y=28)
	0x6a,
	0x08, // 0x228: LD VA, 8
	0x6b,
	0x1c, // 0x22A: LD VB, 28

	// Bottom border loop
	0xda,
	0xb1, // 0x22C: DRW VA, VB, 1
	0x7a,
	0x02, // 0x22E: ADD VA, 2
	0x3a,
	0x38, // 0x230: SE VA, 56
	0x12,
	0x2c, // 0x232: JP 0x22C

	// === DRAW INITIAL BLOCK ===
	0xa2,
	0x9c, // 0x234: LD I, block sprite (at 0x29C)
	0xd0,
	0x14, // 0x236: DRW V0, V1, 4

	// === MAIN LOOP (0x238) ===
	// Check key 4 (LEFT) - E4 9E skips if key[V4] is pressed
	0xe4,
	0x9e, // 0x238: SKP V4 - Skip if key 4 pressed
	0x12,
	0x48, // 0x23A: JP check_right (not pressed)

	// Key 4 pressed - move left
	0xa2,
	0x9c, // 0x23C: LD I, block sprite
	0xd0,
	0x14, // 0x23E: DRW V0, V1, 4 - Erase
	0x70,
	0xfc, // 0x240: ADD V0, -4
	0xd0,
	0x14, // 0x242: DRW V0, V1, 4 - Draw
	0x12,
	0x38, // 0x244: JP main_loop
	0x00,
	0x00, // padding

	// check_right (0x248): Check key 6 (RIGHT)
	0xe5,
	0x9e, // 0x248: SKP V5 - Skip if key 6 pressed
	0x12,
	0x58, // 0x24A: JP check_up

	// Key 6 pressed - move right
	0xa2,
	0x9c, // 0x24C: LD I, block sprite
	0xd0,
	0x14, // 0x24E: DRW V0, V1, 4 - Erase
	0x70,
	0x04, // 0x250: ADD V0, 4
	0xd0,
	0x14, // 0x252: DRW V0, V1, 4 - Draw
	0x12,
	0x38, // 0x254: JP main_loop
	0x00,
	0x00, // padding

	// check_up (0x258): Check key 5 (UP)
	0xe6,
	0x9e, // 0x258: SKP V6 - Skip if key 5 pressed
	0x12,
	0x68, // 0x25A: JP check_down

	// Key 5 pressed - move up
	0xa2,
	0x9c, // 0x25C: LD I, block sprite
	0xd0,
	0x14, // 0x25E: DRW V0, V1, 4 - Erase
	0x71,
	0xfc, // 0x260: ADD V1, -4
	0xd0,
	0x14, // 0x262: DRW V0, V1, 4 - Draw
	0x12,
	0x38, // 0x264: JP main_loop
	0x00,
	0x00, // padding

	// check_down (0x268): Check key 7 (DOWN)
	0xe7,
	0x9e, // 0x268: SKP V7 - Skip if key 7 pressed
	0x12,
	0x78, // 0x26A: JP no_key

	// Key 7 pressed - move down
	0xa2,
	0x9c, // 0x26C: LD I, block sprite
	0xd0,
	0x14, // 0x26E: DRW V0, V1, 4 - Erase
	0x71,
	0x04, // 0x270: ADD V1, 4
	0xd0,
	0x14, // 0x272: DRW V0, V1, 4 - Draw
	0x12,
	0x38, // 0x274: JP main_loop
	0x00,
	0x00, // padding

	// no_key (0x278): No key pressed
	0x12,
	0x38, // 0x278: JP main_loop

	// Padding to reach sprite data at 0x29C
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00, // 0x27A-0x281
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00, // 0x282-0x289
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00, // 0x28A-0x291
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00, // 0x292-0x299
	0x00,
	0x00, // 0x29A-0x29B

	// === SPRITES (0x29C) ===
	// Block sprite (4x4 filled square)
	0xf0, // ████░░░░
	0xf0, // ████░░░░
	0xf0, // ████░░░░
	0xf0, // ████░░░░

	// Border sprite (1 pixel) at 0x2A0
	0x80, // █░░░░░░░
])

/** Get the game ROM as a Uint8Array */
export function getTetrisRom(): Uint8Array {
	return ROM_BYTES
}

/** Key mappings for our simplified controls */
export const TETRIS_KEYS = {
	left: 4, // CHIP-8 key 4
	right: 6, // CHIP-8 key 6
	rotate: 5, // CHIP-8 key 5 (moves up in this simple version)
	drop: 7, // CHIP-8 key 7
} as const

export type TetrisAction = keyof typeof TETRIS_KEYS
