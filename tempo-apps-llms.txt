# llms.txt for tempoxyz/tempo-apps
# Generated: 2025-12-09T21:55:08.831Z
# Total files in repository: 148

---

## File: README.md
```
# Tempo Apps

Monorepo for Tempo Apps

## Apps

| Workspace | Description | URL |
| --------- | ----------- | ----------- |
| [`apps/explorer`](apps/explorer) | Chain explorer. | [`explore.tempo.xyz`](<https://explore.tempo.xyz>) |
| [`apps/fee-payer`](apps/fee-payer) | Fee payer. | [`sponsor.testnet.tempo.xyz`](<https://sponsor.testnet.tempo.xyz>) |
| [`apps/service-proxy`](apps/service-proxy) | Proxy requests to external services that require credentials. | `p.tempo.xyz` |

## Contributing

Our contributor guidelines can be found in [`CONTRIBUTING.md`](https://github.com/tempoxyz/tempo-apps?tab=contributing-ov-file).

## Security

See [`SECURITY.md`](https://github.com/tempoxyz/tempo-apps?tab=security-ov-file).

## License

Licensed under either of [Apache License](./LICENSE-APACHE), Version
2.0 or [MIT License](./LICENSE-MIT) at your option.

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in these crates by you, as defined in the Apache-2.0 license,
shall be dual licensed as above, without any additional terms or conditions.

```

## File: apps/explorer/README.md
```
# Tempo Explorer

## Getting Started

To run this application:

```bash
pnpm install
pnpm dev
```

### Styling

This project uses [Tailwind CSS](https://tailwindcss.com/) for styling.

### Linting, Formatting & Type Checking

This project uses [Biome](https://biomejs.dev/) for linting and formatting.

To format & lint:

```bash
pnpm check
```

To check types:

```bash
pnpm check:types
```

## Adding new features

When adding new features, please read TanStack Router and Start docs first.

[TanStack Router](https://tanstack.com/router/latest/docs)

[TanStack Start](https://tanstack.com/start/latest/docs)

```

## File: apps/fee-payer/README.md
```
# Fee Payer Service

A Cloudflare Worker that provides fee sponsorship for Tempo transactions.

```bash
cp .env.example .env  # Copy example environment variables
pnpm install          # Install dependencies
pnpm dev              # Start development server
pnpm dev:playground   # Start playground
```

## API

| Method | Route | Params |
|--------|-------|--------|
| GET | `/usage` | - optional: `blockTimestampFrom` (epoch seconds)<br>- optional: `blockTimestampTo` (epoch seconds) |
| POST | `*` | JSON-RPC request body for fee sponsorship<br>Supported methods: `eth_signTransaction`, `eth_signRawTransaction`, `eth_sendRawTransaction`, `eth_sendRawTransactionSync` |

```

## File: apps/service-proxy/README.md
```
# Service Proxy

A Cloudflare Worker that proxies requests to external services that require credentials.

```bash
pnpm i          # Install dependencies
pnpm dev        # Start development server
```
```

## File: package.json
```
{
	"name": "@tempo/apps",
	"private": true,
	"type": "module",
	"workspaces": [
		"apps/*"
	],
	"scripts": {
		"build": "pnpm -r build",
		"deploy": "pnpm -r deploy",
		"dev:explorer": "pnpm --filter explorer dev",
		"dev:sponsor": "pnpm --filter tempo-sponsor dev",
		"check": "pnpm check:biome && pnpm check:types",
		"check:biome": "biome check --write --unsafe",
		"check:types": "pnpm -r check:types",
		"gen:types": "pnpm -r gen:types",
		"postinstall": "pnpm -r postinstall",
		"preview": "pnpm -r preview"
	},
	"devDependencies": {
		"@biomejs/biome": "catalog:",
		"@typescript/native-preview": "^7.0.0-dev.20251209.1",
		"typescript": "^5.9.3"
	},
	"devEngines": {
		"runtime": {
			"name": "node",
			"version": "24.11.1",
			"onFail": "download"
		}
	},
	"packageManager": "pnpm@10.25.0"
}

```

## File: apps/explorer/src/comps/AccountCard.tsx
```
import { ClientOnly, getRouteApi } from '@tanstack/react-router'
import type { Address } from 'ox'
import { InfoCard } from '#comps/InfoCard'
import { RelativeTime } from '#comps/RelativeTime'
import { PriceFormatter } from '#lib/formatting'
import { useCopy } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

const Route = getRouteApi('/_layout/address/$address')

export function AccountCard(props: AccountCard.Props) {
	const params = Route.useParams()
	const {
		address = params.address,
		className,
		createdTimestamp,
		lastActivityTimestamp,
		totalValue,
	} = props

	const { copy, notifying } = useCopy()

	return (
		<InfoCard
			title={
				<div className="flex items-center justify-between px-[18px] pt-[10px] pb-[8px]">
					<h1 className="text-[13px] uppercase text-tertiary select-none">
						Account
					</h1>
				</div>
			}
			className={className}
			sections={[
				<button
					key="address"
					type="button"
					onClick={() => copy(address)}
					className="w-full text-left cursor-pointer press-down text-tertiary"
					title={address}
				>
					<div className="flex items-center gap-[8px] mb-[8px]">
						<span className="text-[13px] font-normal capitalize">Address</span>
						<div className="relative flex items-center">
							<CopyIcon className="w-[12px] h-[12px]" />
							{notifying && (
								<span className="absolute left-[calc(100%+8px)] text-[13px] leading-[16px]">
									copied
								</span>
							)}
						</div>
					</div>
					<p className="text-[14px] font-normal leading-[17px] tracking-[0.02em] text-primary break-all max-w-[22ch]">
						{address}
					</p>
				</button>,
				{
					label: 'Holdings',
					value: (
						<ClientOnly
							fallback={<span className="text-tertiary text-[13px]">…</span>}
						>
							{totalValue !== undefined ? (
								<span
									className="text-[13px] text-primary"
									title={PriceFormatter.format(totalValue)}
								>
									{PriceFormatter.format(totalValue, { format: 'short' })}
								</span>
							) : (
								<span className="text-tertiary text-[13px]">…</span>
							)}
						</ClientOnly>
					),
				},
				{
					label: 'Active',
					value: (
						<ClientOnly
							fallback={<span className="text-tertiary text-[13px]">…</span>}
						>
							{lastActivityTimestamp ? (
								<RelativeTime
									timestamp={lastActivityTimestamp}
									className="text-[13px] text-primary"
								/>
							) : (
								<span className="text-tertiary text-[13px]">…</span>
							)}
						</ClientOnly>
					),
				},
				{
					label: 'Created',
					value: (
						<ClientOnly
							fallback={<span className="text-tertiary text-[13px]">…</span>}
						>
							{createdTimestamp ? (
								<RelativeTime
									timestamp={createdTimestamp}
									className="text-[13px] text-primary"
								/>
							) : (
								<span className="text-tertiary text-[13px]">…</span>
							)}
						</ClientOnly>
					),
				},
			]}
		/>
	)
}

export declare namespace AccountCard {
	type Props = {
		address?: Address.Address | undefined
		className?: string
		lastActivityTimestamp?: bigint | undefined
		createdTimestamp?: bigint | undefined
		totalValue?: number | undefined
	}
}

```

## File: apps/explorer/src/comps/Address.tsx
```
import { Link } from '@tanstack/react-router'
import type { Address as AddressType } from 'ox'
import { HexFormatter } from '#lib/formatting'

export function Address(props: Address.Props) {
	const { address, chars, self, className } = props
	return (
		<>
			<Link
				to="/address/$address"
				params={{ address }}
				title={address}
				className={className}
			>
				{HexFormatter.shortenHex(address, chars)}
			</Link>
			{self && <span className="text-tertiary"> (self)</span>}
		</>
	)
}

export namespace Address {
	export interface Props {
		address: AddressType.Address
		chars?: number
		self?: boolean
		className?: string
	}
}

```

## File: apps/explorer/src/comps/AddressCell.tsx
```
import { Link } from '@tanstack/react-router'
import type { Address } from 'ox'
import { TruncatedHash } from '#comps/TruncatedHash'

export function AddressCell(props: {
	address: Address.Address
	label?: string
	asLink?: boolean
	chars?: number
}) {
	const { address, label, asLink = true, chars = 8 } = props
	const title = `${label ? `${label}: ` : ''}${address}`

	if (!asLink)
		return (
			<span className="text-[13px] text-accent" title={title}>
				<TruncatedHash hash={address} minChars={chars} />
			</span>
		)

	return (
		<Link
			to="/address/$address"
			params={{ address }}
			className="text-[13px] text-accent hover:text-accent/80 transition-colors press-down"
			title={title}
		>
			<TruncatedHash hash={address} minChars={chars} />
		</Link>
	)
}

```

## File: apps/explorer/src/comps/Amount.tsx
```
import { Link } from '@tanstack/react-router'
import { type Address, Value } from 'ox'
import { Hooks } from 'tempo.ts/wagmi'
import { isTip20Address } from '#lib/domain/tip20.ts'
import { PriceFormatter } from '#lib/formatting.ts'

export function Amount(props: Amount.Props) {
	const { value, token, decimals, symbol } = props

	const { data: metadata } = Hooks.token.useGetMetadata({
		token,
		query: {
			enabled: decimals === undefined,
		},
	})

	const decimals_ = decimals ?? metadata?.decimals
	const symbol_ = symbol ?? metadata?.symbol

	const rawFormatted =
		decimals_ === undefined ? '…' : Value.format(value, decimals_)
	const formatted =
		rawFormatted === '…' ? '…' : PriceFormatter.formatAmount(rawFormatted)

	return (
		<span className="items-end whitespace-nowrap">
			{formatted}{' '}
			<Link
				className="text-base-content-positive press-down inline-flex"
				params={{ address: token }}
				title={token}
				to={isTip20Address(token) ? '/token/$address' : '/address/$address'}
			>
				{symbol_}
			</Link>
		</span>
	)
}

export namespace Amount {
	export interface Props {
		value: bigint
		token: Address.Address
		decimals?: number
		symbol?: string
	}
}

```

## File: apps/explorer/src/comps/AmountCell.tsx
```
import { formatUnits } from 'viem'
import { PriceFormatter } from '#lib/formatting'

export function AmountCell(props: {
	value: bigint
	decimals?: number
	symbol?: string
}) {
	const { value, decimals = 18, symbol } = props
	const formatted = PriceFormatter.formatAmount(formatUnits(value, decimals))
	return (
		<span className="text-[12px] text-primary">
			{formatted} {symbol}
		</span>
	)
}

export function BalanceCell(props: { balance: string; decimals?: number }) {
	const { balance, decimals = 18 } = props
	const formatted = PriceFormatter.formatAmount(
		formatUnits(BigInt(balance), decimals),
	)
	return <span className="text-[12px] text-primary">{formatted}</span>
}

```

## File: apps/explorer/src/comps/BlockCard.tsx
```
import { Link } from '@tanstack/react-router'
import type { Hex } from 'ox'
import * as React from 'react'
import { useWatchBlockNumber } from 'wagmi'
import { InfoCard } from '#comps/InfoCard'
import { TruncatedHash } from '#comps/TruncatedHash'
import { cx } from '#cva.config'
import { DateFormatter } from '#lib/formatting'
import { useCopy } from '#lib/hooks'
import type { BlockWithTransactions } from '#lib/queries'
import ArrowUp10 from '~icons/lucide/arrow-up-1-0'
import ChevronDown from '~icons/lucide/chevron-down'
import CopyIcon from '~icons/lucide/copy'

export function BlockCard(props: BlockCard.Props) {
	const { block } = props
	const {
		number: blockNumber,
		hash,
		timestamp,
		parentHash,
		miner,
		gasUsed,
		gasLimit,
		stateRoot,
		transactionsRoot,
		receiptsRoot,
		withdrawalsRoot,
	} = block

	const [showAdvanced, setShowAdvanced] = React.useState(false)

	const copyBlock = useCopy()
	const copyHash = useCopy()

	const confirmationsRef = React.useRef<HTMLSpanElement>(null)
	const latestBlockRef = React.useRef(blockNumber ?? 0n)

	const getConfirmations = (latest?: bigint) => {
		if (!blockNumber || !latest || latest < blockNumber) return undefined
		return Number(latest - blockNumber) + 1
	}

	useWatchBlockNumber({
		onBlockNumber: (newBlockNumber) => {
			if (newBlockNumber > (latestBlockRef.current ?? 0n)) {
				latestBlockRef.current = newBlockNumber
				const confirmations = getConfirmations(newBlockNumber)
				if (confirmationsRef.current) {
					confirmationsRef.current.textContent =
						confirmations !== undefined ? String(confirmations) : '—'
				}
			}
		},
	})

	const utcFormatted = timestamp
		? DateFormatter.formatUtcTimestamp(timestamp)
		: undefined
	const [utcDate, utcTime] = utcFormatted?.split(', ') ?? []

	const gasUsage = BlockCard.getGasUsagePercent(gasUsed, gasLimit)
	const roots = [
		{ label: 'state', value: stateRoot },
		{ label: 'txns', value: transactionsRoot },
		{ label: 'receipts', value: receiptsRoot },
		{ label: 'withdraws', value: withdrawalsRoot },
	]

	const showAdvancedSection = true

	return (
		<InfoCard
			titlePosition="inside"
			className="text-[13px]"
			title={
				<button
					type="button"
					onClick={() => copyBlock.copy(String(blockNumber ?? 0n))}
					className="w-full text-left cursor-pointer press-down text-tertiary pb-[4px]"
					title={String(blockNumber ?? 0n)}
				>
					<div className="flex items-center gap-[8px] mb-[4px]">
						<span className="uppercase">Block</span>
						<div className="relative flex items-center">
							<CopyIcon className="w-[12px] h-[12px] text-content-dimmed" />
							{copyBlock.notifying && (
								<span className="absolute left-[calc(100%+8px)] leading-[16px]">
									copied
								</span>
							)}
						</div>
					</div>
					<BlockCard.BlockNumber value={blockNumber ?? 0n} />
				</button>
			}
			sections={[
				<div key="time" className="w-full flex flex-col gap-[8px]">
					<BlockCard.TimeRow
						label="UTC"
						value={
							<time dateTime={new Date(Number(timestamp) * 1000).toISOString()}>
								<span className="text-primary">{utcDate}</span>
								{utcTime && <> {utcTime}</>}
							</time>
						}
					/>
					<BlockCard.TimeRow label="UNIX" value={String(timestamp)} />
				</div>,
				<div key="hash-parent" className="w-full flex flex-col gap-[8px]">
					{hash && (
						<button
							type="button"
							onClick={() => copyHash.copy(hash)}
							className="w-full text-left cursor-pointer press-down text-tertiary"
							title={hash}
						>
							<div className="flex items-center gap-[8px] mb-[8px]">
								<span className="font-normal capitalize">Hash</span>
								<div className="relative flex items-center">
									<CopyIcon className="w-[12px] h-[12px] text-content-dimmed" />
									{copyHash.notifying && (
										<span className="absolute left-[calc(100%+8px)] leading-[16px]">
											copied
										</span>
									)}
								</div>
							</div>
							<div className="text-[14px] font-normal leading-[18px] tracking-[1px] text-primary break-all max-w-[calc(22ch+22px)]">
								{hash}
							</div>
						</button>
					)}
					<div className="w-full flex items-center justify-between gap-[8px]">
						<span className="flex items-center gap-[6px] font-normal capitalize text-tertiary">
							<ArrowUp10 className="size-[14px] text-content-dimmed" />
							Parent
						</span>
						<Link
							to="/block/$id"
							params={{ id: parentHash }}
							className="text-accent hover:underline press-down"
							title={parentHash}
						>
							<TruncatedHash hash={parentHash} minChars={4} />
						</Link>
					</div>
				</div>,
				<div
					key="miner-confirmations"
					className="w-full flex flex-col gap-[8px]"
				>
					<BlockCard.InfoRow label="Miner">
						{miner ? (
							<Link
								to="/address/$address"
								params={{ address: miner }}
								className="text-accent hover:underline press-down"
								title={miner}
							>
								<TruncatedHash hash={miner} minChars={4} />
							</Link>
						) : (
							<span className="text-tertiary">—</span>
						)}
					</BlockCard.InfoRow>
					<BlockCard.InfoRow label="Confirmations">
						<span ref={confirmationsRef} className="text-primary">
							<span className="text-secondary">—</span>
						</span>
					</BlockCard.InfoRow>
				</div>,
				showAdvancedSection && (
					<div
						key="advanced"
						className="w-[calc(100%+36px)] -mx-[18px] -my-[12px] px-[18px] py-[12px]"
					>
						<button
							type="button"
							className="flex w-full items-center justify-between text-tertiary cursor-pointer press-down"
							onClick={() => setShowAdvanced((prev) => !prev)}
						>
							<span className="text-[14px]">Advanced</span>
							<ChevronDown
								className={cx('size-[14px] text-content-dimmed', {
									'rotate-180': showAdvanced,
								})}
							/>
						</button>

						{showAdvanced && (
							<div className="mt-[14px] space-y-[14px]">
								<div className="space-y-[6px]">
									<div className="flex items-center justify-between text-primary">
										<span>Gas Usage</span>
										<span className="text-primary">
											{gasUsage !== undefined
												? `${gasUsage.toFixed(2)}%`
												: '0.00%'}
										</span>
									</div>
									<div className="flex items-center h-[2px] px-[1px] bg-card-border">
										<div
											className="h-full bg-accent"
											style={{
												width: `max(4px, ${Math.min(100, gasUsage ?? 0)}%)`,
											}}
										/>
									</div>
									<div className="flex items-center justify-between text-tertiary">
										<BlockCard.GasValue value={gasUsed} />
										<BlockCard.GasValue value={gasLimit} highlight={false} />
									</div>
								</div>

								<div className="space-y-[8px]">
									<div>Roots</div>
									{roots.map((root) => (
										<BlockCard.RootRow
											key={root.label}
											label={root.label}
											hash={root.value}
										/>
									))}
								</div>
							</div>
						)}
					</div>
				),
			]}
		/>
	)
}

export namespace BlockCard {
	export interface Props {
		block: BlockWithTransactions
	}

	export function TimeRow(props: TimeRow.Props) {
		const { label, value } = props
		return (
			<div className="w-full flex items-center justify-between">
				<span className="text-[11px] uppercase text-tertiary bg-base-alt/65 px-[4px] py-[2px]">
					{label}
				</span>
				<span className="text-right text-base-content-secondary">{value}</span>
			</div>
		)
	}

	export namespace TimeRow {
		export interface Props {
			label: string
			value?: React.ReactNode
		}
	}

	export function BlockNumber(props: BlockNumber.Props) {
		const { value } = props
		const str = String(value).padStart(14, '0')
		const zerosEnd = str.match(/^0*/)?.[0].length ?? 0
		return (
			// the 14px font size is used to set the same width as the block hash
			<div className="text-[14px] max-w-[calc(22ch+22px)]">
				<span className="flex justify-between gap-[1px] text-[22px] text-tertiary">
					{str.split('').map((char, index) => (
						<span
							key={`${index}-${char}`}
							className={index >= zerosEnd ? 'text-primary' : undefined}
						>
							{char}
						</span>
					))}
				</span>
			</div>
		)
	}

	export namespace BlockNumber {
		export interface Props {
			value: bigint
		}
	}

	export function InfoRow(props: InfoRow.Props) {
		const { label, children } = props
		return (
			<div className="w-full flex items-center justify-between gap-[8px]">
				<span className="font-normal capitalize text-tertiary">{label}</span>
				{children}
			</div>
		)
	}

	export namespace InfoRow {
		export interface Props {
			label: string
			children: React.ReactNode
		}
	}

	export function GasValue(props: GasValue.Props) {
		const { value, digits = 9, highlight = true } = props
		if (value === undefined) return <span>—</span>
		const str = String(value).padStart(digits, '0')
		const zeros = str.match(/^0*/)?.[0] ?? ''
		const number = str.slice(zeros.length)
		return (
			<span>
				{zeros}
				{highlight ? <span className="text-primary">{number}</span> : number}
			</span>
		)
	}

	export namespace GasValue {
		export interface Props {
			value?: bigint
			digits?: number
			highlight?: boolean
		}
	}

	export function RootRow(props: RootRow.Props) {
		const { label, hash } = props
		const { copy, notifying } = useCopy()

		if (!hash) {
			return (
				<div className="flex items-center justify-between gap-[8px] text-primary lowercase">
					<span className="text-[12px] text-tertiary">{label}</span>
					<span className="text-tertiary">—</span>
				</div>
			)
		}

		return (
			<button
				type="button"
				onClick={() => copy(hash)}
				className="w-full flex items-center justify-between gap-[8px] text-primary lowercase cursor-pointer press-down"
				title={hash}
			>
				<span className="text-[12px] text-tertiary">
					{notifying ? 'copied' : label}
				</span>
				<div className="flex items-center gap-[8px]">
					<TruncatedHash hash={hash} minChars={4} />
					<CopyIcon className="w-[12px] h-[12px] text-content-dimmed" />
				</div>
			</button>
		)
	}

	export namespace RootRow {
		export interface Props {
			label: string
			hash?: Hex.Hex
		}
	}

	export function getGasUsagePercent(gasUsed?: bigint, gasLimit?: bigint) {
		if (!gasUsed || !gasLimit) return undefined
		const used = Number(gasUsed)
		const limit = Number(gasLimit)
		if (!limit) return undefined
		return (used / limit) * 100
	}
}

```

## File: apps/explorer/src/comps/ContractReader.tsx
```
import { Link, useLocation } from '@tanstack/react-router'
import { Address } from 'ox'
import { getSignature } from 'ox/AbiItem'
import * as React from 'react'
import type { Abi, AbiFunction } from 'viem'
import { decodeFunctionResult, encodeFunctionData } from 'viem'
import { useCall, useReadContract } from 'wagmi'
import { cx } from '#cva.config.ts'
import { ellipsis } from '#lib/chars'
import {
	formatOutputValue,
	getContractAbi,
	getFunctionSelector,
	getInputFunctions,
	getInputType,
	getNoInputFunctions,
	getPlaceholder,
	isArrayType,
	parseInputValue,
} from '#lib/domain/contracts.ts'
import { useCopy } from '#lib/hooks.ts'
import CheckIcon from '~icons/lucide/check'
import ChevronDownIcon from '~icons/lucide/chevron-down'
import CopyIcon from '~icons/lucide/copy'
import DownloadIcon from '~icons/lucide/download'
import ExternalLinkIcon from '~icons/lucide/external-link'
import LinkIcon from '~icons/lucide/link'

// ============================================================================
// Types
// ============================================================================

type ReadFunction = AbiFunction & { stateMutability: 'view' | 'pure' }

// ============================================================================
// Helpers
// ============================================================================

/**
 * Get a display-friendly function signature.
 * Uses getSignature for named functions, falls back to selector for unnamed (whatsabi).
 */
function getFunctionDisplaySignature(fn: AbiFunction): string {
	if (fn.name) return getSignature(fn)
	// Fallback for whatsabi-extracted functions without names
	const selector = getFunctionSelector(fn)
	const inputs = fn.inputs?.map((i) => i.type).join(', ') ?? ''
	return `${selector}(${inputs})`
}

/**
 * Get method name with selector, e.g., "approve (0x095ea7b3)"
 */
function getMethodWithSelector(fn: AbiFunction): string {
	const selector = getFunctionSelector(fn)
	const name = fn.name || selector
	return `${name} (${selector})`
}

// ============================================================================
// Main Component
// ============================================================================

export function ContractReader(props: {
	address: Address.Address
	abi?: Abi
	docsUrl?: string
}) {
	const { address, docsUrl } = props
	const { copy: copyAbi, notifying: copiedAbi } = useCopy({ timeout: 2000 })
	const location = useLocation()

	const abi = props.abi ?? getContractAbi(address)

	const key = React.useId()

	// Scroll to function when hash is present
	React.useEffect(() => {
		const hash = location.hash
		if (hash && typeof window !== 'undefined') {
			// Small delay to ensure DOM is rendered
			const timer = setTimeout(() => {
				// Strip the leading '#' since getElementById expects just the ID
				const element = document.getElementById(hash.slice(1))
				if (element) {
					element.scrollIntoView({ behavior: 'smooth', block: 'center' })
					// Add a brief highlight effect
					element.classList.add('ring-1', 'ring-accent', 'ring-offset-1')
					setTimeout(() => {
						element.classList.remove('ring-1', 'ring-accent', 'ring-offset-1')
					}, 2_000)
				}
			}, 100)
			return () => clearTimeout(timer)
		}
	}, [location.hash])

	const handleCopyAbi = React.useCallback(() => {
		if (!abi) return
		void copyAbi(JSON.stringify(abi, null, 2))
	}, [abi, copyAbi])

	const handleDownloadAbi = React.useCallback(() => {
		if (!abi || typeof window === 'undefined') return
		const json = JSON.stringify(abi, null, 2)
		const blob = new Blob([json], { type: 'application/json' })
		const url = URL.createObjectURL(blob)
		const anchor = document.createElement('a')
		anchor.href = url
		anchor.download = `${address}-abi.json`
		document.body.appendChild(anchor)
		anchor.click()
		document.body.removeChild(anchor)
		URL.revokeObjectURL(url)
	}, [abi, address])

	if (!abi) {
		return (
			<div className="rounded-[10px] bg-card-header p-[18px] h-full">
				<p className="text-sm font-medium text-tertiary">
					No ABI available for this contract.
				</p>
			</div>
		)
	}

	const noInputFunctions = getNoInputFunctions(abi)
	const inputFunctions = getInputFunctions(abi)

	return (
		<div className="flex flex-col gap-[14px]">
			{/* ABI Viewer */}
			<ContractFeatureCard
				title="ABI"
				description="Shareable interface definition for read/write tooling."
				actions={
					<div className="flex gap-[8px]">
						{docsUrl && (
							<a
								href={docsUrl}
								target="_blank"
								rel="noopener noreferrer"
								className="text-[12px] rounded-[6px] border border-card-border px-[10px] py-[6px] hover:bg-base-alt transition-colors inline-flex items-center gap-[4px]"
							>
								Docs
								<ExternalLinkIcon className="w-[12px] h-[12px]" />
							</a>
						)}
						<button
							type="button"
							onClick={handleDownloadAbi}
							className="text-[12px] rounded-[6px] border border-card-border px-[10px] py-[6px] hover:bg-base-alt transition-colors inline-flex items-center gap-[4px]"
						>
							<DownloadIcon className="w-[12px] h-[12px]" />
							Download
						</button>
					</div>
				}
			>
				<AbiViewer abi={abi} onCopy={handleCopyAbi} copied={copiedAbi} />
			</ContractFeatureCard>

			<div aria-hidden="true" className="border-b border-card-border" />

			{/* Read Contract Panel */}
			<ContractFeatureCard
				title="Read contract"
				description="Call view methods to read contract state."
			>
				<div className="flex flex-col gap-[12px]">
					{/* Functions without inputs - show as static values */}
					{noInputFunctions.map((fn) => (
						<StaticReadFunction
							key={fn.name}
							address={address}
							abi={abi}
							fn={fn}
						/>
					))}

					{/* Functions with inputs - show as expandable forms */}
					{inputFunctions.map((fn) => (
						<DynamicReadFunction
							key={`${fn.name}-${key}-${fn.inputs?.length}`}
							address={address}
							abi={abi}
							fn={fn}
						/>
					))}

					{noInputFunctions.length === 0 && inputFunctions.length === 0 && (
						<p className="text-[13px] text-tertiary">
							No read functions available.
						</p>
					)}
				</div>
			</ContractFeatureCard>
		</div>
	)
}

// ============================================================================
// ABI Viewer
// ============================================================================

function AbiViewer(props: { abi: Abi; onCopy: () => void; copied: boolean }) {
	const { abi, onCopy, copied } = props

	return (
		<div className="relative">
			<div className="absolute right-[8px] top-[8px] flex items-center gap-[4px]">
				{copied && (
					<span className="text-[11px] uppercase tracking-wide text-tertiary leading-none">
						copied
					</span>
				)}
				<button
					type="button"
					onClick={onCopy}
					title={copied ? 'Copied' : 'Copy JSON'}
					className="rounded-[6px] bg-card p-[6px] text-tertiary press-down hover:text-primary transition-colors"
				>
					<CopyIcon className="h-[14px] w-[14px]" />
				</button>
			</div>
			<pre className="max-h-[280px] overflow-auto rounded-[8px] text-[12px] leading-[18px] text-primary/90 font-mono">
				{JSON.stringify(abi, null, 2)}
			</pre>
		</div>
	)
}

// ============================================================================
// Static Read Function (no inputs)
// ============================================================================

function StaticReadFunction(props: {
	address: Address.Address
	abi: Abi
	fn: ReadFunction
}) {
	const { address, abi, fn } = props
	const { copy, notifying } = useCopy({ timeout: 2_000 })
	const { copy: copyLink, notifying: linkCopied } = useCopy({ timeout: 2_000 })

	const [mounted, setMounted] = React.useState(false)
	React.useEffect(() => setMounted(true), [])

	const hasOutputs = Array.isArray(fn.outputs) && fn.outputs.length > 0

	const {
		data: typedResult,
		error: typedError,
		isLoading: typedLoading,
	} = useReadContract({
		address,
		abi,
		functionName: fn.name,
		args: [],
		query: { enabled: mounted && hasOutputs },
	})

	// Raw call fallback for functions without outputs
	const callData = React.useMemo(() => {
		if (hasOutputs) return undefined
		try {
			return encodeFunctionData({ abi, functionName: fn.name, args: [] })
		} catch {
			return undefined
		}
	}, [abi, fn.name, hasOutputs])

	const {
		data: rawResult,
		error: rawError,
		isLoading: rawLoading,
	} = useCall({
		to: address,
		data: callData,
		query: { enabled: mounted && !hasOutputs && Boolean(callData) },
	})

	const decodedRawResult = React.useMemo(() => {
		if (hasOutputs || !rawResult?.data) return undefined
		const data = rawResult.data

		// Check if it looks like a padded address (32 bytes with 12 leading zero bytes)
		// Address encoding: 0x + 24 zeros + 40 hex chars (20 bytes address)
		const looksLikeAddress =
			data.length === 66 &&
			data.slice(2, 26) === '000000000000000000000000' &&
			data.slice(26) !== '0000000000000000000000000000000000000000'

		if (looksLikeAddress) {
			try {
				const addressAbi = [{ ...fn, outputs: [{ type: 'address', name: '' }] }]
				return decodeFunctionResult({
					abi: addressAbi,
					functionName: fn.name,
					data,
				})
			} catch {
				// Fall through to other attempts
			}
		}

		// Try decoding as string (common for functions like typeAndVersion)
		try {
			const stringAbi = [{ ...fn, outputs: [{ type: 'string', name: '' }] }]
			return decodeFunctionResult({
				abi: stringAbi,
				functionName: fn.name,
				data,
			})
		} catch {
			// Fall through
		}

		// Try decoding as uint256 (common for numeric getters)
		try {
			const uint256Abi = [{ ...fn, outputs: [{ type: 'uint256', name: '' }] }]
			return decodeFunctionResult({
				abi: uint256Abi,
				functionName: fn.name,
				data,
			})
		} catch {
			// Return raw hex if all decode attempts fail
			return data
		}
	}, [hasOutputs, rawResult, fn])

	const isLoading = !mounted || (hasOutputs ? typedLoading : rawLoading)
	const result = hasOutputs ? typedResult : decodedRawResult
	const queryError = hasOutputs ? typedError : rawError
	const error = queryError ? queryError.message : null

	const isResultAddress =
		typeof result === 'string' && Address.validate(result as string)
	const outputType =
		fn.outputs?.[0]?.type ?? (isResultAddress ? 'address' : 'string')

	const displayValue = error
		? error
		: isLoading
			? ellipsis
			: formatOutputValue(result, outputType)

	// Format address outputs as links (only after mount to avoid hydration mismatch)
	const isAddressOutput = outputType === 'address' || isResultAddress
	const isValidAddress = mounted && isAddressOutput && isResultAddress

	const handleCopyMethod = () => {
		void copy(getMethodWithSelector(fn))
	}

	const selector = getFunctionSelector(fn)
	const fnId = fn.name || selector

	const handleCopyPermalink = () => {
		const url = new URL(window.location.href)
		url.hash = fnId
		void copyLink(url.toString())
	}

	return (
		<div
			id={fnId}
			className="flex flex-col gap-[4px] rounded-[8px] border border-dashed border-card-border px-[12px] py-[10px] transition-all duration-300"
		>
			<div className="flex items-center justify-between gap-[8px]">
				<span className="text-[12px] text-secondary font-mono">
					{getFunctionDisplaySignature(fn)}
				</span>
				<div className="flex items-center gap-[8px]">
					<button
						type="button"
						onClick={handleCopyMethod}
						title={notifying ? 'Copied!' : 'Copy method name'}
						className={cx(
							'transition-colors press-down',
							notifying ? 'text-positive' : 'text-tertiary hover:text-primary',
						)}
					>
						{notifying ? (
							<CheckIcon className="w-[12px] h-[12px]" />
						) : (
							<CopyIcon className="w-[12px] h-[12px]" />
						)}
					</button>
					<button
						type="button"
						onClick={handleCopyPermalink}
						title={linkCopied ? 'Copied!' : 'Copy permalink'}
						className={cx(
							'transition-colors press-down',
							linkCopied ? 'text-positive' : 'text-tertiary hover:text-primary',
						)}
					>
						{linkCopied ? (
							<CheckIcon className="w-[12px] h-[12px]" />
						) : (
							<LinkIcon className="w-[12px] h-[12px]" />
						)}
					</button>
				</div>
			</div>
			{isValidAddress ? (
				<Link
					to="/address/$address"
					params={{ address: result as Address.Address }}
					className="text-[13px] text-accent hover:text-accent/80 transition-colors font-mono"
				>
					{displayValue}
				</Link>
			) : (
				<span
					className={cx(
						'text-[13px] font-mono',
						error ? 'text-red-400' : 'text-primary',
					)}
				>
					{displayValue}
				</span>
			)}
		</div>
	)
}

// ============================================================================
// Dynamic Read Function (with inputs)
// ============================================================================

function DynamicReadFunction(props: {
	address: Address.Address
	abi: Abi
	fn: ReadFunction
}) {
	const { address, abi, fn } = props
	const [isExpanded, setIsExpanded] = React.useState(false)
	const [inputs, setInputs] = React.useState<Record<string, string>>({})
	const { copy, notifying } = useCopy({ timeout: 2_000 })
	const { copy: copyLink, notifying: linkCopied } = useCopy({ timeout: 2_000 })

	const selector = getFunctionSelector(fn)
	const fnId = fn.name || selector

	const handleInputChange = (name: string, value: string) => {
		setInputs((prev) => ({ ...prev, [name]: value }))
	}

	const allInputsFilled = (fn.inputs ?? []).every((input) => {
		const value = inputs[input.name ?? '']
		return value !== undefined && value.trim() !== ''
	})

	const parsedArgs = React.useMemo(() => {
		if (!allInputsFilled) return { args: [] as Array<unknown>, error: null }
		try {
			const args = (fn.inputs ?? []).map((input) => {
				const value = inputs[input.name ?? ''] ?? ''
				return parseInputValue(value, input.type)
			})
			return { args, error: null }
		} catch (err) {
			return {
				args: [] as Array<unknown>,
				error: err instanceof Error ? err.message : 'Failed to parse inputs',
			}
		}
	}, [fn.inputs, inputs, allInputsFilled])

	const {
		data: result,
		error: queryError,
		isLoading,
	} = useReadContract({
		address,
		abi,
		functionName: fnId,
		args: parsedArgs.args,
		query: {
			enabled: allInputsFilled && !parsedArgs.error,
		},
	})

	const error =
		parsedArgs.error ?? (queryError ? queryError.message : null) ?? null

	const outputType = fn.outputs?.[0]?.type ?? 'unknown'

	const handleCopyMethod = (e: React.MouseEvent) => {
		e.stopPropagation()
		void copy(getMethodWithSelector(fn))
	}

	const handleCopyPermalink = (e: React.MouseEvent) => {
		e.stopPropagation()
		const url = new URL(window.location.href)
		url.hash = fnId
		void copyLink(url.toString())
	}

	return (
		<div
			id={fnId}
			className="rounded-[8px] border border-dashed border-card-border overflow-hidden transition-all duration-300"
		>
			<div className="w-full flex items-center justify-between px-[12px] py-[10px] hover:bg-card-header/50 transition-colors">
				<button
					type="button"
					onClick={() => setIsExpanded(!isExpanded)}
					className="flex-1 text-left"
				>
					<span className="text-[12px] text-secondary font-mono">
						{getFunctionDisplaySignature(fn)}
					</span>
				</button>
				<div className="flex items-center gap-[8px]">
					<button
						type="button"
						onClick={handleCopyMethod}
						title={notifying ? 'Copied!' : 'Copy method name'}
						className={cx(
							'transition-colors press-down',
							notifying ? 'text-positive' : 'text-tertiary hover:text-primary',
						)}
					>
						{notifying ? (
							<CheckIcon className="w-[12px] h-[12px]" />
						) : (
							<CopyIcon className="w-[12px] h-[12px]" />
						)}
					</button>
					<button
						type="button"
						onClick={handleCopyPermalink}
						title={linkCopied ? 'Copied!' : 'Copy permalink'}
						className={cx(
							'transition-colors press-down',
							linkCopied ? 'text-positive' : 'text-tertiary hover:text-primary',
						)}
					>
						{linkCopied ? (
							<CheckIcon className="w-[12px] h-[12px]" />
						) : (
							<LinkIcon className="w-[12px] h-[12px]" />
						)}
					</button>
					<button
						type="button"
						onClick={() => setIsExpanded(!isExpanded)}
						className="text-secondary"
					>
						<ChevronDownIcon
							className={cx(
								'w-[14px] h-[14px] transition-transform',
								isExpanded && 'rotate-180',
							)}
						/>
					</button>
				</div>
			</div>

			{isExpanded && (
				<div className="border-t border-card-border px-[12px] py-[10px] flex flex-col gap-[10px]">
					{fn.inputs.map((input, index) => (
						<FunctionInput
							key={input.name ?? index}
							input={input}
							value={inputs[input.name ?? ''] ?? ''}
							onChange={(value) =>
								handleInputChange(input.name ?? `arg${index}`, value)
							}
						/>
					))}

					{isLoading && (
						<p className="text-[12px] text-secondary">{ellipsis}</p>
					)}

					{!isLoading && (result !== undefined || error) && (
						<div className="p-2.5 rounded-md bg-card-header flex flex-col gap-2">
							<span className="text-[11px] text-secondary uppercase tracking-wide font-medium">
								Result
							</span>
							<p
								className={cx(
									'text-[13px] mt-[4px] break-all font-mono',
									error ? 'text-red-400' : 'text-primary',
								)}
							>
								{error ?? formatOutputValue(result, outputType)}
							</p>
						</div>
					)}
				</div>
			)}
		</div>
	)
}

// ============================================================================
// Function Input Component
// ============================================================================

function FunctionInput(props: {
	input: { name?: string; type: string }
	value: string
	onChange: (value: string) => void
}) {
	const { input, value, onChange } = props
	const inputId = React.useId()
	const inputType = getInputType(input.type)
	const placeholder = getPlaceholder(input as { name: string; type: string })

	// Special handling for bool type
	if (inputType === 'checkbox') {
		return (
			<div className="flex items-center gap-[8px]">
				<input
					id={inputId}
					type="checkbox"
					checked={value === 'true'}
					onChange={(e) => onChange(e.target.checked ? 'true' : 'false')}
					className="w-[16px] h-[16px] rounded border-base-border"
				/>
				<label htmlFor={inputId} className="text-[12px] text-primary font-mono">
					{input.name || 'value'}{' '}
					<span className="text-secondary">({input.type})</span>
				</label>
			</div>
		)
	}

	// Textarea for complex types
	if (inputType === 'textarea' || isArrayType(input.type)) {
		return (
			<div className="flex flex-col gap-[4px]">
				<label htmlFor={inputId} className="text-[12px] text-primary font-mono">
					{input.name || 'value'}{' '}
					<span className="text-secondary">({input.type})</span>
				</label>
				<textarea
					id={inputId}
					value={value}
					onChange={(e) => onChange(e.target.value)}
					placeholder={placeholder}
					rows={3}
					className="w-full rounded-[6px] border border-base-border bg-card px-[10px] py-[6px] text-[13px] text-primary placeholder:text-secondary focus-visible:outline-1 focus-visible:outline-accent resize-none font-mono"
				/>
			</div>
		)
	}

	// Standard text input
	return (
		<div className="flex flex-col gap-[4px]">
			<label htmlFor={inputId} className="text-[12px] text-primary font-mono">
				{input.name || 'value'}{' '}
				<span className="text-secondary">({input.type})</span>
			</label>
			<input
				id={inputId}
				type="text"
				value={value}
				onChange={(e) => onChange(e.target.value)}
				placeholder={placeholder}
				className="w-full rounded-[6px] border border-base-border bg-card px-[10px] py-[6px] text-[13px] text-primary placeholder:text-secondary focus-visible:outline-1 focus-visible:outline-accent font-mono"
			/>
		</div>
	)
}

// ============================================================================
// Shared Components
// ============================================================================

function ContractFeatureCard(props: {
	title: string
	description?: React.ReactNode
	actions?: React.ReactNode
	children: React.ReactNode
}) {
	const { title, description, actions, children } = props
	return (
		<section className="rounded-[10px] bg-card-header overflow-hidden">
			<div className="flex flex-col gap-1.5 px-4 py-3 sm:flex-row sm:items-center sm:justify-between">
				<div>
					<p className="text-[13px] uppercase text-primary font-medium">
						{title}
					</p>
					{description && (
						<p className="text-[12px] text-secondary">{description}</p>
					)}
				</div>
				{actions}
			</div>
			<div className="border-t border-card-border bg-card px-4 py-3.5">
				{children}
			</div>
		</section>
	)
}

export { ContractFeatureCard }

```

## File: apps/explorer/src/comps/ContractWriter.tsx
```
/**
 * TODO
 */

export function ContractWriter() {
	return null
}

```

## File: apps/explorer/src/comps/CopyButton.tsx
```
import type * as React from 'react'
import { cx } from '#cva.config.ts'
import { useCopy } from '#lib/hooks.ts'
import CheckIcon from '~icons/lucide/check'
import CopyIcon from '~icons/lucide/copy'

export function CopyButton(props: CopyButton.Props): React.JSX.Element {
	const { value, ariaLabel, disabled, className } = props

	const { copy, notifying } = useCopy({ timeout: 2_000 })

	return (
		<button
			type="button"
			className={cx(
				'transition-colors press-down',
				notifying ? 'text-positive' : 'text-tertiary hover:text-primary',
				className,
			)}
			disabled={disabled}
			onClick={() => copy(value)}
			aria-label={ariaLabel ?? 'Copy to clipboard'}
			title={notifying ? 'Copied!' : (ariaLabel ?? 'Copy to clipboard')}
		>
			{notifying ? (
				<CheckIcon className="size-3.75" />
			) : (
				<CopyIcon className="size-3.75" />
			)}
		</button>
	)
}

export declare namespace CopyButton {
	type Props = {
		value: string
		ariaLabel?: string | undefined
		disabled?: boolean | undefined
		className?: string | undefined
	}
}

```

## File: apps/explorer/src/comps/DataGrid.tsx
```
import { Link } from '@tanstack/react-router'
import * as React from 'react'
import { Pagination } from '#comps/Pagination'
import { Sections } from '#comps/Sections'
import { cx } from '#cva.config'

export function DataGrid(props: DataGrid.Props) {
	const {
		columns,
		items,
		totalItems,
		page,
		isPending,
		itemsLabel = 'items',
		itemsPerPage = 10,
		pagination = 'default',
		emptyState = 'No items found.',
		flexible = false,
	} = props

	const mode = Sections.useSectionsMode()
	const activeColumns = mode === 'stacked' ? columns.stacked : columns.tabs
	const activeItems = items(mode)
	const totalPages = Math.ceil(totalItems / itemsPerPage)

	const gridTemplateColumns = activeColumns
		.map((col) => {
			if (typeof col.width === 'number') return `${col.width}px`
			if (typeof col.width === 'string')
				return col.minWidth
					? `minmax(${col.minWidth}px, ${col.width})`
					: col.width
			if (col.minWidth) return `minmax(${col.minWidth}px, auto)`
			return 'auto'
		})
		.join(' ')

	return (
		<div className="flex flex-col min-h-0">
			<div className="relative w-full">
				<div
					className={cx(
						'w-full text-[14px] rounded-t-[2px] grid',
						flexible && 'min-w-max',
					)}
					style={{ gridTemplateColumns }}
				>
					<div className="grid col-span-full border-b border-dashed border-distinct grid-cols-subgrid">
						{activeColumns.map((column, index) => {
							const key = `header-${index}`
							return (
								<div
									key={key}
									className={cx(
										'px-[10px] first:pl-[16px] last:pr-[16px] h-[40px] flex items-center',
										'text-[13px] text-tertiary font-normal whitespace-nowrap',
										column.align === 'end' ? 'justify-end' : 'justify-start',
									)}
								>
									{column.label}
								</div>
							)
						})}
					</div>
					{activeItems.length === 0 ? (
						<div
							className="px-[16px] py-[32px] text-tertiary col-span-full flex items-center justify-center"
							style={{ minHeight: itemsPerPage * 49 }}
						>
							{emptyState}
						</div>
					) : null}
					{activeItems.map((item, rowIndex) => {
						let maxLines = 1
						for (const cell of item.cells) {
							if (Array.isArray(cell) && cell.length > maxLines)
								maxLines = cell.length
						}
						return (
							<div
								key={`row-${rowIndex}-${page}`}
								className={cx(
									'grid col-span-full relative grid-cols-subgrid grid-flow-row border-b border-dashed border-distinct border-l-[3px] border-l-transparent [border-left-style:solid]',
									item.link &&
										'hover:bg-base-alt hover:border-solid transition-[background-color] duration-75 hover:-mt-[1px] hover:border-t hover:border-t-distinct',
									item.expanded && 'border-l-distinct',
									item.className,
								)}
							>
								{item.link && (
									<Link
										to={item.link.href}
										title={item.link.title}
										className="absolute inset-0 -left-[3px] z-0 [&:active~div]:translate-y-[0.5px] -outline-offset-2!"
									/>
								)}
								{Array.from({ length: maxLines }, (_, lineIndex) => {
									const key = `line-${rowIndex}-${lineIndex}`
									return (
										<React.Fragment key={key}>
											{item.cells.map((cell, cellIndex) => {
												const key = `cell-${rowIndex}-${cellIndex}-${lineIndex}`
												const column = activeColumns[cellIndex]
												const lines = Array.isArray(cell) ? cell : [cell]
												const content = lines[lineIndex] ?? null
												const isFirstColumn = cellIndex === 0
												const isLastColumn =
													cellIndex === activeColumns.length - 1
												return (
													<div
														key={key}
														className={cx(
															'px-[10px] py-[12px] flex items-start min-h-[48px]',
															'text-primary',
															isFirstColumn && 'pl-[16px]',
															isLastColumn && 'pr-[16px]',
															column?.align === 'end'
																? 'justify-end'
																: 'justify-start',
															item.link &&
																'pointer-events-none [&_a]:pointer-events-auto [&_a]:relative [&_a]:z-[1] [&_button]:pointer-events-auto [&_button]:relative [&_button]:z-[1]',
														)}
													>
														{content}
													</div>
												)
											})}
											{lineIndex < maxLines - 1 && (
												<div className="col-span-full border-b border-dashed border-distinct" />
											)}
										</React.Fragment>
									)
								})}
								{item.expanded && typeof item.expanded !== 'boolean' && (
									<div className="col-span-full px-[16px] pb-[12px] [contain:inline-size] -mt-[4px]">
										{item.expanded}
									</div>
								)}
							</div>
						)
					})}
				</div>
			</div>
			<div className="mt-auto">
				{pagination === 'simple' ? (
					<div className="flex flex-col items-center sm:flex-row sm:justify-between gap-[12px] border-t border-dashed border-card-border px-[16px] py-[12px] text-[12px] text-tertiary">
						<Pagination.Simple
							page={page}
							totalPages={totalPages}
							isPending={isPending}
						/>
						<Pagination.Count totalItems={totalItems} itemsLabel={itemsLabel} />
					</div>
				) : (
					<Pagination
						page={page}
						totalPages={totalPages}
						totalItems={totalItems}
						itemsLabel={itemsLabel}
						isPending={isPending}
						compact={mode === 'stacked'}
					/>
				)}
			</div>
		</div>
	)
}

export namespace DataGrid {
	export interface Column {
		label: React.ReactNode
		align?: 'start' | 'end'
		minWidth?: number
		width?: number | `${number}fr`
	}

	export interface RowLink {
		href: string
		title: string
	}

	export type Cell = React.ReactNode | React.ReactNode[]

	export interface Row {
		cells: Cell[]
		link?: RowLink
		expanded?: boolean | React.ReactNode
		className?: string
	}

	export interface Props {
		columns: {
			stacked: Column[]
			tabs: Column[]
		}
		items: (mode: Sections.Mode) => Row[]
		totalItems: number
		page: number
		isPending: boolean
		itemsLabel?: string
		itemsPerPage?: number
		pagination?: 'default' | 'simple'
		emptyState?: React.ReactNode
		flexible?: boolean
	}
}

```

## File: apps/explorer/src/comps/DataGridSkeleton.tsx
```
import * as React from 'react'
import { DataGrid } from '#comps/DataGrid'

export function DataGridSkeleton(props: {
	columns: DataGrid.Column[]
	rows?: number
	totalItems?: number
	itemsLabel?: string
}) {
	const { columns, rows = 10, totalItems = 0, itemsLabel = 'items' } = props

	const id = React.useId()

	return (
		<DataGrid
			columns={{ stacked: columns, tabs: columns }}
			items={() =>
				Array.from({ length: rows }, (_, index) => ({
					cells: columns.map((_, colIndex) => (
						<div
							key={`skeleton-${index}-${colIndex}-${id}`}
							className="h-[20px]"
						/>
					)),
				}))
			}
			totalItems={totalItems}
			page={1}
			isPending={false}
			itemsLabel={itemsLabel}
			itemsPerPage={rows}
		/>
	)
}

```

## File: apps/explorer/src/comps/ErrorBoundary.tsx
```
import type { ErrorComponentProps } from '@tanstack/react-router'
import { Footer } from '#comps/Footer'
import { Header } from '#comps/Header'
import { useCopy } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

export function ErrorBoundary({ error }: ErrorComponentProps) {
	const copy = useCopy()
	console.error(error)
	return (
		<main className="flex min-h-dvh flex-col">
			<Header />
			<section className="flex flex-1 flex-col size-full items-center justify-center px-[16px] max-w-[600px] gap-[16px] m-auto">
				<div className="flex flex-col items-center gap-[8px]">
					<h1 className="text-[24px] lg:text-[40px] font-medium text-base-content">
						Something Went Wrong
					</h1>
					<p className="text-base-content-secondary text-[15px] lg:text-[18px] text-center">
						An unexpected error occurred while loading this page.
					</p>
				</div>
				{error?.message && (
					<div className="bg-surface border border-base-border rounded-[10px] p-[16px] max-w-full overflow-hidden relative">
						<pre className="text-[13px] text-base-content-secondary whitespace-pre-wrap pr-[32px] leading-[20px] min-h-[40px]">
							{error.message}
						</pre>
						{copy.notifying && (
							<span className="absolute bottom-[12px] right-[40px] text-[13px] leading-[16px] text-base-content-secondary whitespace-nowrap">
								copied
							</span>
						)}
						<button
							type="button"
							onClick={() => copy.copy(error.message)}
							className="absolute bottom-[8px] right-[8px] p-[4px] text-base-content-secondary press-down cursor-pointer"
						>
							<CopyIcon className="size-[16px]" />
						</button>
					</div>
				)}
				<button
					type="button"
					onClick={() => window.history.back()}
					className="text-accent rounded-[8px] press-down"
				>
					Go Back
				</button>
			</section>
			<Footer />
		</main>
	)
}

```

## File: apps/explorer/src/comps/ExploreInput.tsx
```
import { keepPreviousData, queryOptions, useQuery } from '@tanstack/react-query'
import { Address, Hex } from 'ox'
import * as React from 'react'
import { ProgressLine } from '#comps/ProgressLine'
import { RelativeTime } from '#comps/RelativeTime'
import { cx } from '#cva.config'
import { HexFormatter } from '#lib/formatting'
import type {
	AddressSearchResult,
	SearchApiResponse,
	SearchResult,
	TokenSearchResult,
} from '#routes/api/search'
import ArrowRight from '~icons/lucide/arrow-right'

export function ExploreInput(props: ExploreInput.Props) {
	const {
		onActivate,
		autoFocus,
		value,
		onChange,
		size = 'medium',
		disabled,
	} = props
	const formRef = React.useRef<HTMLFormElement>(null)
	const resultsRef = React.useRef<HTMLDivElement>(null)

	const inputRef = React.useRef<HTMLInputElement>(null)

	const [showResults, setShowResults] = React.useState(false)
	const [selectedIndex, setSelectedIndex] = React.useState(-1)
	const resultsId = React.useId()

	const query = value.trim()
	const { data: searchResults, isFetching } = useQuery(
		queryOptions({
			queryKey: ['search', query],
			queryFn: async (): Promise<SearchApiResponse> => {
				const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`)
				if (!res.ok) throw new Error('Search failed')
				return res.json()
			},
			enabled: query !== '',
			staleTime: 30_000,
			placeholderData: keepPreviousData,
		}),
	)
	const suggestions = searchResults?.results ?? []

	const groupedSuggestions = React.useMemo<
		ExploreInput.SuggestionGroup[]
	>(() => {
		const tokens: TokenSearchResult[] = []
		const addresses: AddressSearchResult[] = []

		for (const suggestion of suggestions) {
			// a tx result is always unique so we can return early
			if (suggestion.type === 'transaction')
				return [
					{ type: 'transaction', title: 'Transactions', items: [suggestion] },
				]

			if (suggestion.type === 'token') tokens.push(suggestion)
			else if (suggestion.type === 'address') addresses.push(suggestion)
		}

		const groups: ExploreInput.SuggestionGroup[] = []

		// addresses first
		if (addresses.length > 0)
			groups.push({ type: 'address', title: 'Addresses', items: addresses })

		if (tokens.length > 0)
			groups.push({ type: 'token', title: 'Tokens', items: tokens })

		return groups
	}, [suggestions])

	const flatSuggestions = React.useMemo(
		() => groupedSuggestions.flatMap((g) => g.items),
		[groupedSuggestions],
	)

	React.useEffect(() => {
		setShowResults(disabled ? false : query.length > 0)
	}, [query, disabled])

	const lastResultsKey = React.useRef('')
	const resultsKey = JSON.stringify(flatSuggestions)
	if (lastResultsKey.current !== resultsKey) {
		lastResultsKey.current = resultsKey
		setSelectedIndex(-1)
	}

	// click outside (TODO: move focus from input to results menu)
	React.useEffect(() => {
		if (!showResults) return
		const onMouseDown = (event: MouseEvent) => {
			if (
				resultsRef.current &&
				!resultsRef.current.contains(event.target as Node) &&
				inputRef.current &&
				!inputRef.current.contains(event.target as Node)
			) {
				setShowResults(false)
				setSelectedIndex(-1)
			}
		}
		document.addEventListener('mousedown', onMouseDown)
		return () => document.removeEventListener('mousedown', onMouseDown)
	}, [showResults])

	// cmd+k shortcut
	React.useEffect(() => {
		const handleKeyDown = (event: KeyboardEvent) => {
			if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'k') {
				event.preventDefault()
				inputRef.current?.focus()
			}
		}
		window.addEventListener('keydown', handleKeyDown)
		return () => window.removeEventListener('keydown', handleKeyDown)
	}, [])

	// the route transition appears to sometimes steal the focus,
	// so we need to re-focus in case it happens
	React.useEffect(() => {
		const timer = setTimeout(() => {
			if (autoFocus) inputRef.current?.focus()
		}, 100)
		return () => clearTimeout(timer)
	}, [autoFocus])

	const handleSelect = React.useCallback(
		(result: SearchResult) => {
			setShowResults(false)
			setSelectedIndex(-1)

			if (result.type === 'token') {
				onChange?.(result.address)
				onActivate?.({ type: 'token', value: result.address })
				return
			}

			if (result.type === 'address') {
				onChange?.(result.address)
				onActivate?.({ type: 'address', value: result.address })
				return
			}

			if (result.type === 'transaction') {
				onChange?.(result.hash)
				onActivate?.({ type: 'hash', value: result.hash })
				return
			}
		},
		[onChange, onActivate],
	)

	return (
		<form
			ref={formRef}
			onSubmit={(event) => {
				event.preventDefault()
				if (!formRef.current || disabled) return

				const data = new FormData(formRef.current)
				let formValue = data.get('value')
				if (!formValue || typeof formValue !== 'string') return

				formValue = formValue.trim()
				if (!formValue) return

				if (Address.validate(formValue)) {
					onActivate?.({ type: 'address', value: formValue })
					return
				}

				if (Hex.validate(formValue) && Hex.size(formValue) === 32) {
					onActivate?.({ type: 'hash', value: formValue })
					return
				}
			}}
			className="relative z-1 w-full max-w-[448px]"
		>
			<input
				ref={inputRef}
				autoCapitalize="none"
				autoComplete="off"
				autoCorrect="off"
				autoFocus={autoFocus}
				value={value}
				disabled={disabled}
				className={cx(
					'bg-surface border-base-border border pl-[16px] pr-[60px] w-full placeholder:text-tertiary text-base-content rounded-[10px] focus-visible:border-focus outline-0 disabled:cursor-not-allowed disabled:opacity-50',
					size === 'large' ? 'h-[52px] text-[17px]' : 'h-[42px] text-[15px]',
				)}
				data-1p-ignore
				name="value"
				placeholder="Enter an address, token or transaction…"
				spellCheck={false}
				type="text"
				onKeyDown={(event) => {
					if (event.key === 'Escape' && showResults) {
						event.preventDefault()
						setShowResults(false)
						setSelectedIndex(-1)
						return
					}

					if (!showResults || flatSuggestions.length === 0) return

					if (event.key === 'ArrowDown') {
						event.preventDefault()
						setSelectedIndex((prev) =>
							prev < flatSuggestions.length - 1 ? prev + 1 : 0,
						)
						return
					}

					if (event.key === 'ArrowUp') {
						event.preventDefault()
						setSelectedIndex((prev) =>
							prev > 0 ? prev - 1 : flatSuggestions.length - 1,
						)
						return
					}

					if (event.key === 'Enter') {
						const index = selectedIndex >= 0 ? selectedIndex : 0
						if (index < flatSuggestions.length) {
							event.preventDefault()
							handleSelect(flatSuggestions[index])
						}
						return
					}
				}}
				onChange={(event) => {
					onChange?.(event.target.value)
				}}
				onFocus={() => {
					if (query.length > 0 && flatSuggestions.length > 0)
						setShowResults(true)
				}}
				role="combobox"
				aria-expanded={showResults}
				aria-haspopup="listbox"
				aria-autocomplete="list"
				aria-controls={resultsId}
				aria-activedescendant={
					selectedIndex !== -1 ? `${resultsId}-${selectedIndex}` : undefined
				}
				title="Enter an address, token or transaction to explore (Cmd+K to focus)"
			/>
			<div
				className={cx(
					'absolute top-[50%] -translate-y-[50%]',
					size === 'large' ? 'right-[16px]' : 'right-[12px]',
				)}
			>
				<button
					type="submit"
					disabled={disabled}
					aria-label="Search"
					className={cx(
						'rounded-full! bg-accent text-base-plane flex items-center justify-center cursor-pointer active:translate-y-[0.5px] disabled:cursor-not-allowed disabled:opacity-50',
						size === 'large' ? 'size-[28px]' : 'size-[24px]',
					)}
				>
					<ArrowRight
						className={size === 'large' ? 'size-[16px]' : 'size-[14px]'}
					/>
				</button>
			</div>

			{showResults && (
				<div
					ref={resultsRef}
					id={resultsId}
					role="listbox"
					aria-label="Search suggestions"
					className={cx(
						'absolute left-0 right-0 mt-[8px]',
						'bg-surface border border-base-border rounded-[10px] overflow-hidden',
						'shadow-[0px_4px_44px_rgba(0,0,0,0.05)]',
					)}
				>
					<ProgressLine
						loading={isFetching}
						start={150}
						className="absolute top-0 left-0 right-0"
					/>
					{flatSuggestions.length === 0 ? (
						<div className="px-[16px] py-[12px] text-[14px] text-tertiary">
							{!searchResults ? 'Searching…' : 'No results'}
						</div>
					) : (
						<div className="flex flex-col py-[4px]">
							{groupedSuggestions.map((group, groupIndex) => (
								<div key={group.type} className="flex flex-col">
									<div
										className={cx(
											'flex justify-between items-center px-[12px] py-[6px]',
											groupIndex > 0 && 'pt-[12px]',
										)}
									>
										<div className="text-[12px] text-secondary">
											{group.type === 'token'
												? 'Tokens'
												: group.type === 'transaction'
													? 'Receipt'
													: 'Address'}
										</div>
										<div className="text-[12px] text-tertiary">
											{group.type === 'token'
												? 'Address'
												: group.type === 'transaction'
													? 'Time'
													: ''}
										</div>
									</div>
									{group.items.map((item) => {
										const flatIndex = flatSuggestions.indexOf(item)
										const key =
											item.type === 'transaction'
												? `tx-${item.hash}`
												: `${item.type}-${item.address}`
										return (
											<ExploreInput.SuggestionItem
												key={key}
												suggestion={item}
												isSelected={flatIndex === selectedIndex}
												onSelect={handleSelect}
												id={`${resultsId}-${flatIndex}`}
											/>
										)
									})}
								</div>
							))}
						</div>
					)}
				</div>
			)}
		</form>
	)
}

export namespace ExploreInput {
	export type ValueType = 'address' | 'hash'

	export interface Props {
		onActivate?: (
			data:
				| { value: Address.Address; type: 'address' }
				| { value: Address.Address; type: 'token' }
				| { value: Hex.Hex; type: 'hash' },
		) => void
		autoFocus?: boolean
		value: string
		onChange: (value: string) => void
		size?: 'large' | 'medium'
		disabled?: boolean
	}

	export type SuggestionGroup = {
		type: 'token' | 'address' | 'transaction'
		title: string
		items: SearchResult[]
	}

	export function SuggestionItem(props: SuggestionItem.Props) {
		const { suggestion, isSelected, onSelect, id } = props
		const itemRef = React.useRef<HTMLButtonElement>(null)

		React.useEffect(() => {
			if (isSelected) itemRef.current?.scrollIntoView({ block: 'nearest' })
		}, [isSelected])

		return (
			<button
				ref={itemRef}
				id={id}
				type="button"
				role="option"
				aria-selected={isSelected}
				onClick={() => onSelect(suggestion)}
				className={cx(
					'w-full flex items-center justify-between gap-[10px]',
					'text-left cursor-pointer px-[12px] py-[6px] press-down hover:bg-base-alt/25',
					isSelected && 'bg-base-alt/25',
				)}
			>
				{suggestion.type === 'token' && (
					<>
						<div className="flex items-center gap-[10px] min-w-0 flex-1">
							<span className="text-[16px] font-medium text-base-content truncate">
								{suggestion.name}
							</span>
							<span className="text-[11px] font-medium text-base-content bg-border-primary p-[4px] rounded-[4px] shrink-0">
								{suggestion.symbol}
							</span>
						</div>
						<span className="text-[13px] font-mono text-accent">
							{HexFormatter.shortenHex(suggestion.address, 6)}
						</span>
					</>
				)}
				{suggestion.type === 'address' && (
					<span className="text-[13px] font-mono text-accent truncate">
						{suggestion.address}
					</span>
				)}
				{suggestion.type === 'transaction' && (
					<>
						<span className="text-[13px] font-mono text-accent truncate min-w-0 flex-1">
							{HexFormatter.shortenHex(suggestion.hash, 8)}
						</span>
						{suggestion.timestamp ? (
							<RelativeTime
								timestamp={BigInt(suggestion.timestamp)}
								className="text-[12px] text-tertiary"
							/>
						) : (
							<span className="text-[12px] text-tertiary">−</span>
						)}
					</>
				)}
			</button>
		)
	}

	export namespace SuggestionItem {
		export interface Props {
			suggestion: SearchResult
			isSelected: boolean
			onSelect: (suggestion: SearchResult) => void
			id: string
		}
	}
}

```

## File: apps/explorer/src/comps/Footer.tsx
```
import { Link as RouterLink } from '@tanstack/react-router'

export function Footer() {
	return (
		<footer className="pt-[24px] pb-[48px] relative">
			<ul className="flex items-center justify-center gap-[24px] text-[15px] text-base-content-secondary select-none">
				<Footer.Link to="https://tempo.xyz" external>
					About
				</Footer.Link>
				<Footer.Link to="https://docs.tempo.xyz" external>
					Documentation
				</Footer.Link>
				<Footer.Link to="https://github.com/tempoxyz" external>
					GitHub
				</Footer.Link>
			</ul>
		</footer>
	)
}

export namespace Footer {
	export function Link(props: Link.Props) {
		const { to, params, children, external } = props
		return (
			<li className="flex">
				<RouterLink
					to={to}
					params={params}
					className="press-down"
					target={external ? '_blank' : undefined}
					rel={external ? 'noopener noreferrer' : undefined}
				>
					{children}
				</RouterLink>
			</li>
		)
	}

	export namespace Link {
		export interface Props {
			to: string
			params?: Record<string, string>
			children: React.ReactNode
			external?: boolean
		}
	}
}

```

## File: apps/explorer/src/comps/Header.tsx
```
import {
	Link,
	useNavigate,
	useRouter,
	useRouterState,
} from '@tanstack/react-router'
import * as React from 'react'
import { useChains, useWatchBlockNumber } from 'wagmi'
import { ExploreInput } from '#comps/ExploreInput'
import Music4 from '~icons/lucide/music-4'
import SquareSquare from '~icons/lucide/square-square'

export function Header(props: Header.Props) {
	const { initialBlockNumber } = props
	return (
		<header className="@container relative z-1">
			<div className="px-[24px] @min-[1240px]:pt-[48px] @min-[1240px]:px-[84px] flex items-center justify-between min-h-16 pt-[36px] select-none relative z-1">
				<div className="flex items-center gap-[12px] relative z-1 h-[28px]">
					<Link to="/" className="flex items-center press-down py-[4px]">
						<Header.TempoWordmark />
					</Link>
					<Header.NetworkBadge />
				</div>
				<Header.Search />
				<div className="relative z-1">
					<Header.BlockNumber initial={initialBlockNumber} />
				</div>
			</div>
		</header>
	)
}

export namespace Header {
	export interface Props {
		initialBlockNumber?: bigint
	}

	export function Search() {
		const router = useRouter()
		const navigate = useNavigate()
		const [inputValue, setInputValue] = React.useState('')
		const [isMounted, setIsMounted] = React.useState(false)
		const { currentPathname, isNavigating } = useRouterState({
			select: (state) => ({
				currentPathname:
					state.matches.at(-1)?.pathname ?? state.location.pathname,
				isNavigating: state.status === 'pending',
			}),
		})
		const showSearch = currentPathname !== '/'

		React.useEffect(() => setIsMounted(true), [])

		React.useEffect(() => {
			return router.subscribe('onResolved', ({ hrefChanged }) => {
				if (hrefChanged) setInputValue('')
			})
		}, [router])

		return (
			showSearch && (
				<div className="absolute left-0 right-0 justify-center hidden @min-[1240px]:flex z-1 h-0 items-center">
					<ExploreInput
						value={inputValue}
						onChange={setInputValue}
						disabled={isMounted && isNavigating}
						onActivate={({ value, type }) => {
							if (type === 'hash') {
								navigate({ to: '/receipt/$hash', params: { hash: value } })
								return
							}
							if (type === 'token') {
								navigate({ to: '/token/$address', params: { address: value } })
								return
							}
							if (type === 'address') {
								navigate({
									to: '/address/$address',
									params: { address: value },
								})
								return
							}
						}}
					/>
				</div>
			)
		)
	}

	export function BlockNumber(props: BlockNumber.Props) {
		const { initial } = props

		const ref = React.useRef<HTMLSpanElement>(null)
		useWatchBlockNumber({
			onBlockNumber: (blockNumber) => {
				if (ref.current) ref.current.textContent = String(blockNumber)
			},
		})

		return (
			<Link
				to="/block/$id"
				params={{ id: 'latest' }}
				className="flex items-center gap-[6px] text-[15px] font-medium text-secondary press-down"
				title="View latest block"
			>
				<SquareSquare className="size-[18px] text-accent" />
				<div className="text-nowrap">
					<span
						ref={ref}
						className="text-primary font-medium tabular-nums min-w-[6ch] inline-block"
					>
						{initial ? String(initial) : '…'}
					</span>
				</div>
			</Link>
		)
	}

	export namespace BlockNumber {
		export interface Props {
			initial?: bigint
		}
	}

	export function NetworkBadge() {
		const [chain] = useChains()
		const network = chain.name.match(/Tempo (.+)/)?.[1]
		if (!network) return null
		return (
			<div className="flex items-center gap-[4px] px-[8px] h-[28px] border border-distinct bg-base-alt text-base-content rounded-[14px] text-[14px] font-medium">
				<Music4 width={14} height={14} className="text-accent" />
				{network}
			</div>
		)
	}

	export function TempoWordmark(props: TempoWordmark.Props) {
		const { className } = props

		const baseClass = 'h-6 w-auto fill-current text-primary'
		const classes = className ? `${baseClass} ${className}` : baseClass

		return (
			<svg
				aria-label="Tempo"
				viewBox="0 0 102 25"
				className={classes}
				role="img"
			>
				<path d="M95.1 16.1c1.74 0 3.35-1.25 3.35-3.73 0-2.49-1.6-3.74-3.34-3.74-1.74 0-3.34 1.25-3.34 3.74 0 2.48 1.6 3.74 3.34 3.74Zm0-10.7c3.93 0 6.9 2.9 6.9 6.97a6.73 6.73 0 0 1-6.9 6.97 6.75 6.75 0 0 1-6.88-6.97A6.75 6.75 0 0 1 95.1 5.4ZM77.34 24.01h-3.56V5.8h3.45v1.6c.59-1.01 2.06-1.9 4.03-1.9 3.85 0 6.07 2.94 6.07 6.84s-2.49 6.92-6.2 6.92c-1.82 0-3.15-.72-3.8-1.6V24Zm6.49-11.64c0-2.33-1.45-3.69-3.26-3.69-1.82 0-3.29 1.36-3.29 3.69 0 2.32 1.47 3.71 3.29 3.71 1.81 0 3.26-1.36 3.26-3.71ZM56 18.94h-3.56V5.8h3.39v1.6c.72-1.28 2.4-1.98 3.85-1.98 1.79 0 3.23.78 3.9 2.2a4.57 4.57 0 0 1 4.16-2.2c2.43 0 4.76 1.47 4.76 5v8.52h-3.45v-7.8c0-1.42-.7-2.48-2.32-2.48-1.52 0-2.43 1.17-2.43 2.59v7.69h-3.53v-7.8c0-1.42-.72-2.48-2.32-2.48-1.6 0-2.46 1.14-2.46 2.59v7.69Zm-14.13-8.07h5.87c-.05-1.3-.9-2.59-2.93-2.59a2.84 2.84 0 0 0-2.94 2.6Zm6.22 3.42 2.97.88c-.67 2.27-2.75 4.17-5.99 4.17-3.6 0-6.78-2.6-6.78-7.03 0-4.2 3.1-6.92 6.46-6.92 4.06 0 6.5 2.6 6.5 6.82 0 .5-.06 1.04-.06 1.1h-9.4c.08 1.73 1.55 2.98 3.31 2.98 1.66 0 2.56-.83 3-2Z" />
				<path d="M41.08 3.5H35.1v15.44h-3.71V3.5H25.4V0h15.68v3.5Z" />
				<path
					fillRule="evenodd"
					clipRule="evenodd"
					d="M18.96 18.95H0V.01h18.96v18.94ZM6.46 5.26a.27.27 0 0 0-.25.19l-.82 2.44c-.03.1.04.19.13.19H7.9c.1 0 .16.09.13.18l-1.75 5.25c-.03.1.04.19.14.19h2.53c.12 0 .22-.08.26-.19l1.75-5.25a.27.27 0 0 1 .25-.18h2.37c.12 0 .22-.08.26-.19l.81-2.44a.14.14 0 0 0-.13-.19H6.46Z"
				/>
			</svg>
		)
	}

	export namespace TempoWordmark {
		export interface Props {
			className?: string
		}
	}
}

```

## File: apps/explorer/src/comps/InfoCard.tsx
```
import type { ReactNode } from 'react'
import { cx } from '#cva.config.ts'

export function InfoCard(props: InfoCard.Props) {
	const { title, sections, titlePosition = 'outside', className } = props

	const isInside = titlePosition === 'inside'

	const sectionsContent = sections.map((section, index) => {
		const isSectionEntry =
			section && typeof section === 'object' && 'label' in section
		const isLast = index === sections.length - 1
		const key = `section-${index}`

		return (
			<div
				key={key}
				className={cx(
					'px-[18px] py-[12px] flex items-center',
					!isInside && !isLast && 'border-b border-dashed border-card-border',
				)}
			>
				{isSectionEntry ? (
					<div className="flex items-center gap-[8px] justify-between w-full">
						<span className="text-[13px] font-normal capitalize text-tertiary">
							{section.label}
						</span>
						{section.value}
					</div>
				) : (
					section
				)}
			</div>
		)
	})

	return (
		<section
			className={cx(
				'font-mono',
				'w-full min-[1240px]:w-fit',
				'rounded-[10px] border border-card-border bg-card-header overflow-hidden',
				isInside
					? 'divide-y divide-dashed divide-card-border shadow-[0px_12px_40px_rgba(0,0,0,0.06)]'
					: 'shadow-[0px_4px_44px_rgba(0,0,0,0.05)]',
				className,
			)}
		>
			{isInside ? (
				<div className="px-[18px] pt-[14px] pb-[12px]">{title}</div>
			) : (
				title
			)}
			{isInside ? (
				sectionsContent
			) : (
				<div className="rounded-t-[10px] border-t border border-card-border bg-card -mb-px -mx-px">
					{sectionsContent}
				</div>
			)}
		</section>
	)
}

export declare namespace InfoCard {
	export type Props = {
		title: ReactNode
		sections: Array<ReactNode | { label: string; value: ReactNode }>
		titlePosition?: 'inside' | 'outside'
		className?: string
	}
}

```

## File: apps/explorer/src/comps/InfoRow.tsx
```
export function InfoRow(props: { label: string; children: React.ReactNode }) {
	const { label, children } = props
	return (
		<div className="flex items-start gap-[16px] px-[18px] py-[12px] border-b border-dashed border-card-border last:border-b-0">
			<span className="text-[13px] text-tertiary min-w-[140px] shrink-0">
				{label}
			</span>
			<div className="text-[13px] break-all">{children}</div>
		</div>
	)
}

```

## File: apps/explorer/src/comps/Intro.tsx
```
export function Intro() {
	return (
		<svg fill="none" width={170} height={112} viewBox="0 0 170 112">
			<title>Search. Explore. Discover.</title>
			<path
				d="M20.247 67.573V39.762h18.02v4.182H25.224v7.497h12.329v4.01H25.225v7.94h13.042v4.182zm19.188 0 6.618-10.196-6.54-10.234h5.401l4.11 7.17h.096l4.09-7.17h5.248l-6.579 10.1 6.502 10.33h-5.228l-4.264-7.324h-.097l-4.225 7.324zm20.288 6.746V47.143h4.785v3.527h.116q.597-1.233 1.505-2.1a6.6 6.6 0 0 1 2.141-1.37 7.3 7.3 0 0 1 2.682-.482q2.605 0 4.495 1.292 1.91 1.272 2.933 3.662 1.042 2.39 1.042 5.685v.02q0 3.276-1.042 5.666-1.023 2.37-2.913 3.662-1.872 1.272-4.438 1.272a7.7 7.7 0 0 1-2.7-.463 6.6 6.6 0 0 1-2.181-1.33 6.8 6.8 0 0 1-1.524-2.062h-.116v10.195zm9.82-10.37q1.544 0 2.663-.809 1.119-.81 1.717-2.274.618-1.484.617-3.489v-.019q0-2.062-.617-3.527-.598-1.484-1.736-2.274-1.119-.79-2.644-.79-1.485 0-2.623.81-1.139.808-1.795 2.293-.636 1.464-.636 3.488v.02q0 2.004.636 3.488.657 1.464 1.795 2.274t2.623.81m11.935 3.623V39.762h4.804v27.81zm16.757.405q-3.01 0-5.228-1.272-2.219-1.292-3.454-3.662-1.215-2.39-1.215-5.686v-.038q0-3.277 1.234-5.647 1.235-2.39 3.454-3.662 2.219-1.292 5.19-1.292 2.99 0 5.209 1.292 2.238 1.272 3.473 3.642t1.234 5.667v.038q0 3.315-1.234 5.705-1.216 2.37-3.435 3.643-2.218 1.272-5.228 1.272m.02-3.874q1.523 0 2.642-.79 1.12-.79 1.718-2.294.617-1.523.617-3.662v-.038q0-2.121-.617-3.624-.618-1.504-1.756-2.293-1.119-.79-2.643-.79-1.485 0-2.624.79-1.119.79-1.756 2.293-.618 1.503-.617 3.624v.038q0 2.14.617 3.662.637 1.504 1.756 2.293 1.138.79 2.662.79m11.78 3.47v-20.43h4.785v3.527h.116q.463-1.85 1.678-2.89 1.234-1.06 3.01-1.06a6 6 0 0 1 1.524.192v4.337q-.29-.117-.83-.193a8 8 0 0 0-1.138-.077q-1.35 0-2.334.559-.984.54-1.505 1.6-.522 1.06-.521 2.582v11.853zm20.616.405q-3.067 0-5.286-1.292-2.2-1.29-3.377-3.662-1.177-2.37-1.177-5.608v-.02q0-3.218 1.177-5.608 1.197-2.409 3.338-3.739 2.162-1.33 5.094-1.33 2.913 0 5.035 1.292 2.142 1.272 3.28 3.584 1.158 2.313 1.158 5.397v1.542h-16.708v-3.2h14.412l-2.316 2.988v-1.85q0-2.005-.617-3.335t-1.698-1.985q-1.08-.675-2.489-.674-1.427-.001-2.546.694-1.1.675-1.737 2.023-.617 1.35-.617 3.277v1.85q0 1.87.617 3.2.637 1.31 1.795 2.023 1.157.693 2.759.694 1.195 0 2.103-.367.906-.385 1.485-.983.598-.597.83-1.29l.038-.136h4.476l-.038.212a7.7 7.7 0 0 1-.926 2.313q-.676 1.118-1.814 2.024t-2.701 1.445q-1.563.52-3.55.52m13.728-.096q-1.177 0-1.987-.81a2.68 2.68 0 0 1-.81-1.965q0-1.175.81-1.985t1.987-.81q1.158 0 1.968.81.811.81.811 1.985 0 1.156-.811 1.966a2.68 2.68 0 0 1-1.968.81M39.53 25.99q-2.893 0-5.053-.87-2.162-.87-3.416-2.49-1.238-1.619-1.394-3.864l-.018-.261h4.287l.035.209q.192 1.08.941 1.862.75.784 1.97 1.219 1.237.417 2.805.418 1.586 0 2.736-.436 1.167-.435 1.795-1.236a3.03 3.03 0 0 0 .627-1.897v-.017q0-1.41-1.063-2.229-1.046-.818-3.485-1.34l-2.701-.557q-3.694-.765-5.542-2.507-1.847-1.758-1.847-4.56v-.018q.017-2.229 1.203-3.882Q32.612 1.863 34.72.94 36.83 0 39.53 0q2.736 0 4.792.905 2.057.906 3.224 2.524 1.185 1.62 1.307 3.76l.017.296h-4.286l-.035-.226q-.157-1.096-.82-1.863-.66-.783-1.742-1.2-1.08-.419-2.492-.418-1.464 0-2.544.435-1.063.418-1.656 1.183a2.88 2.88 0 0 0-.575 1.776v.018q0 1.323 1.063 2.158 1.08.819 3.346 1.288l2.701.557q2.633.54 4.287 1.463 1.656.922 2.44 2.315.801 1.392.801 3.342v.018q0 2.332-1.184 4.056-1.168 1.723-3.381 2.663-2.196.94-5.263.94m19.806-.07q-2.77 0-4.775-1.166-1.986-1.166-3.05-3.307-1.062-2.142-1.062-5.066v-.018q0-2.907 1.063-5.065 1.08-2.176 3.014-3.377 1.952-1.202 4.6-1.202 2.632 0 4.55 1.167 1.933 1.149 2.962 3.238 1.045 2.088 1.045 4.874v1.393h-15.09V14.5h13.016l-2.09 2.698v-1.671q0-1.81-.558-3.012-.558-1.2-1.534-1.793-.975-.609-2.248-.609-1.29 0-2.3.627-.993.609-1.568 1.828-.558 1.218-.558 2.959v1.671q0 1.69.558 2.89.575 1.183 1.62 1.828 1.046.626 2.492.626 1.08 0 1.9-.33.819-.349 1.341-.888.54-.54.75-1.166l.035-.122h4.043l-.035.191a6.9 6.9 0 0 1-.837 2.09 6.9 6.9 0 0 1-1.638 1.827q-1.027.817-2.44 1.306-1.411.47-3.206.47m15.502-.052q-1.83 0-3.242-.696-1.394-.713-2.178-1.967-.767-1.27-.767-2.907v-.035q0-1.654.82-2.82.836-1.184 2.404-1.863 1.569-.696 3.8-.835l7.057-.436v2.873l-6.448.4q-1.604.105-2.457.766-.855.662-.854 1.758v.018q0 1.131.854 1.793.871.645 2.3.644 1.255 0 2.23-.505a4 4 0 0 0 1.57-1.375q.573-.87.574-1.967v-5.536q0-1.394-.889-2.193-.87-.819-2.526-.819-1.534 0-2.457.662-.924.645-1.15 1.67l-.035.158h-4.008l.017-.21a5.6 5.6 0 0 1 1.098-2.924q.959-1.305 2.649-2.054 1.707-.749 4.043-.749 2.317 0 4.008.766 1.707.767 2.63 2.142.942 1.375.942 3.237v12.691H80.5v-2.838h-.104a5.9 5.9 0 0 1-1.36 1.672 6 6 0 0 1-1.916 1.096 6.7 6.7 0 0 1-2.283.383m12.435-.313V7.102h4.322v3.186h.105q.418-1.67 1.516-2.611 1.115-.958 2.718-.958a5.4 5.4 0 0 1 1.377.175v3.916a3.4 3.4 0 0 0-.75-.174 7 7 0 0 0-1.028-.07q-1.22 0-2.108.505a3.2 3.2 0 0 0-1.36 1.445q-.47.958-.47 2.333v10.706zm18.656.365q-2.736 0-4.74-1.166t-3.102-3.325q-1.08-2.158-1.08-5.118v-.017q0-2.942 1.098-5.083 1.098-2.16 3.084-3.325 2.004-1.167 4.688-1.167 2.44 0 4.217.94 1.777.924 2.788 2.455a7 7 0 0 1 1.15 3.377v.122h-4.077l-.035-.14a4.13 4.13 0 0 0-1.272-2.28q-.994-.957-2.719-.957-1.36 0-2.387.749-1.011.73-1.569 2.088-.557 1.358-.557 3.256v.017q0 1.915.557 3.273.576 1.357 1.586 2.089 1.028.714 2.388.714 1.655 0 2.666-.888 1.028-.906 1.324-2.35l.035-.157h4.095l-.017.122a7.16 7.16 0 0 1-1.22 3.447q-1.045 1.53-2.806 2.437-1.76.887-4.095.887m9.786-.365V.435h4.339v9.766h.087q.732-1.671 2.179-2.576 1.463-.906 3.52-.906 2.004 0 3.467.923 1.464.906 2.266 2.56.801 1.635.801 3.864v11.489h-4.339V14.919q0-2.124-1.028-3.325-1.027-1.22-2.893-1.219-1.22 0-2.143.592a3.87 3.87 0 0 0-1.411 1.602q-.506 1.01-.506 2.35v10.636zm21.444.279q-1.063 0-1.795-.732a2.42 2.42 0 0 1-.732-1.775q0-1.062.732-1.793.732-.732 1.795-.731 1.046 0 1.777.73.732.732.732 1.794 0 1.044-.732 1.775a2.42 2.42 0 0 1-1.777.732M0 111V78.589h11.837q4.851 0 8.288 1.887 3.436 1.886 5.278 5.48 1.842 3.593 1.842 8.715v.045q0 5.12-1.842 8.782-1.82 3.64-5.278 5.57Q16.688 111 11.837 111zm5.795-4.874h5.435q3.28 0 5.526-1.303 2.246-1.324 3.414-3.841 1.168-2.538 1.168-6.244v-.045q0-3.615-1.19-6.132-1.17-2.516-3.437-3.795-2.246-1.303-5.48-1.303H5.794zM30.065 111V87.191h5.593V111zm2.785-27.223q-1.302 0-2.2-.898a2.94 2.94 0 0 1-.9-2.156q0-1.281.9-2.157.898-.898 2.2-.898 1.326 0 2.224.898.899.876.898 2.157 0 1.257-.898 2.156-.898.898-2.224.898m15.489 27.695q-3.123 0-5.346-.921-2.201-.921-3.46-2.583-1.234-1.685-1.504-3.886l-.022-.202h5.503l.044.202q.315 1.55 1.483 2.403 1.191.854 3.324.854 1.37 0 2.336-.337t1.482-.988q.54-.652.54-1.528v-.022q0-1.056-.72-1.707-.718-.674-2.582-1.101l-3.953-.876q-2.27-.516-3.796-1.415-1.527-.899-2.291-2.223-.764-1.348-.764-3.123v-.022q0-2.178 1.19-3.818 1.191-1.64 3.347-2.56 2.156-.922 5.009-.922 2.965 0 5.076.989 2.112.987 3.257 2.65a6.87 6.87 0 0 1 1.258 3.728l.022.248h-5.21l-.023-.18a3.5 3.5 0 0 0-1.303-2.359q-1.123-.943-3.077-.943-1.236 0-2.156.36-.899.359-1.393 1.01-.472.651-.472 1.528v.022q0 .674.337 1.213.337.54 1.078.943.743.383 1.977.674l3.953.876q3.705.832 5.279 2.38 1.572 1.528 1.572 4.111v.023q0 2.246-1.28 3.953-1.28 1.685-3.55 2.628-2.246.921-5.165.921m22.698 0q-3.527 0-6.11-1.505t-3.998-4.29q-1.392-2.785-1.392-6.604v-.022q0-3.796 1.415-6.559 1.414-2.786 3.975-4.29 2.583-1.505 6.042-1.505 3.145 0 5.436 1.213 2.29 1.191 3.594 3.167a9 9 0 0 1 1.482 4.358v.157h-5.256l-.045-.18a5.3 5.3 0 0 0-1.64-2.942q-1.279-1.236-3.503-1.236-1.752 0-3.077.966-1.304.945-2.022 2.695-.719 1.754-.719 4.2v.023q0 2.47.72 4.223.74 1.752 2.043 2.695 1.326.921 3.077.921 2.134 0 3.437-1.145 1.325-1.169 1.707-3.033l.045-.202h5.278l-.022.157q-.225 2.472-1.573 4.448t-3.616 3.144q-2.269 1.146-5.278 1.146m22.99 0q-3.504 0-6.087-1.483-2.583-1.505-4.02-4.267-1.416-2.786-1.416-6.626v-.045q0-3.82 1.438-6.581 1.437-2.786 4.02-4.268 2.583-1.505 6.042-1.505 3.482 0 6.065 1.505 2.606 1.483 4.043 4.245t1.437 6.604v.045q0 3.862-1.437 6.648-1.416 2.763-3.998 4.245t-6.087 1.483m.022-4.515q1.775 0 3.077-.921t2-2.673q.718-1.774.718-4.267v-.045q0-2.47-.718-4.223-.72-1.752-2.044-2.673-1.303-.92-3.078-.92-1.729 0-3.054.92-1.303.921-2.044 2.673-.72 1.752-.719 4.223v.045q0 2.493.719 4.267.74 1.752 2.044 2.673 1.324.921 3.1.921M113.333 111l-8.422-23.809h5.952l5.525 18.621h.135l5.525-18.62h5.818L119.488 111zm25.349.472q-3.571 0-6.154-1.505-2.561-1.505-3.931-4.268t-1.37-6.536v-.022q0-3.751 1.37-6.537 1.393-2.807 3.886-4.357 2.515-1.55 5.929-1.55 3.392 0 5.863 1.505 2.493 1.482 3.818 4.178 1.347 2.695 1.348 6.289v1.797H129.99v-3.729h16.778l-2.695 3.482v-2.156q0-2.337-.719-3.886-.719-1.55-1.977-2.314-1.257-.786-2.897-.786-1.662 0-2.965.809-1.28.786-2.022 2.358-.718 1.572-.718 3.819v2.156q0 2.178.718 3.728.742 1.528 2.089 2.359 1.348.808 3.212.808 1.393 0 2.448-.426 1.056-.45 1.73-1.146.696-.696.966-1.505l.045-.157h5.211l-.045.247a8.9 8.9 0 0 1-1.078 2.695q-.787 1.303-2.112 2.359-1.325 1.055-3.144 1.684-1.82.607-4.133.607m12.95-.472V87.191h5.57v4.11h.135q.539-2.156 1.954-3.368 1.437-1.236 3.504-1.236a7 7 0 0 1 1.774.225v5.054q-.336-.135-.965-.225a9 9 0 0 0-1.326-.09q-1.572 0-2.717.651-1.146.63-1.752 1.865t-.607 3.01V111zm15.084.359q-1.37 0-2.314-.943-.943-.944-.943-2.291 0-1.37.943-2.313t2.314-.944a3.12 3.12 0 0 1 2.291.944q.943.943.943 2.313 0 1.347-.943 2.291-.944.943-2.291.943"
				style={{ fill: 'light-dark(#000, #fff)' }}
			/>
		</svg>
	)
}

```

## File: apps/explorer/src/comps/NotFound.tsx
```
import { Link, useMatch } from '@tanstack/react-router'
import { Hex } from 'ox'
import { apostrophe } from '#lib/chars'

export function NotFound() {
	const txMatch = useMatch({
		from: '/_layout/tx/$hash',
		shouldThrow: false,
	})

	const hash = (txMatch?.params as { hash: string | undefined })?.hash
	const isValidHash = hash && Hex.validate(hash) && Hex.size(hash) === 32
	const isTx = txMatch?.status === 'notFound' && isValidHash

	const [title, message] = isTx
		? [
				'Transaction Not Found',
				`The transaction doesn${apostrophe}t exist or hasn${apostrophe}t been processed yet.`,
			]
		: [
				'Page Not Found',
				`The page you${apostrophe}re looking for doesn${apostrophe}t exist or has been moved.`,
			]

	return (
		<section className="flex flex-1 size-full items-center justify-center relative">
			<div className="flex flex-col items-center gap-[8px] z-1 px-[16px] w-full max-w-[600px]">
				<h1 className="text-[32px] lg:text-[40px] font-medium text-base-content">
					{title}
				</h1>
				<p className="text-base-content-secondary text-[15px] lg:text-[18px] text-center">
					{message}
				</p>
				{isTx && hash && (
					<pre className="text-[13px] text-base-content-secondary break-all bg-surface border border-base-border rounded-[10px] p-[12px] my-[16px] w-full whitespace-pre-wrap text-center">
						{hash}
					</pre>
				)}
				<div className="flex gap-[12px] items-center">
					<Link to="/" className="text-accent rounded-[8px] press-down">
						Go back
					</Link>
				</div>
			</div>
		</section>
	)
}

```

## File: apps/explorer/src/comps/Pagination.tsx
```
import { Link } from '@tanstack/react-router'
import { cx } from '#cva.config.ts'
import ChevronFirst from '~icons/lucide/chevron-first'
import ChevronLast from '~icons/lucide/chevron-last'
import ChevronLeft from '~icons/lucide/chevron-left'
import ChevronRight from '~icons/lucide/chevron-right'

/**
 * useful links:
 * - `<Link search />` https://tanstack.com/router/v1/docs/framework/react/guide/search-params#link-search-
 */

export function Pagination(props: Pagination.Props) {
	const {
		page,
		totalPages,
		totalItems,
		itemsLabel: itemsLabel_,
		isPending,
		compact: compact_,
		hideOnSinglePage = true,
	} = props

	const compact = compact_ || totalPages > 999

	// TODO: better pluralization
	const itemsLabel =
		totalItems === 1 ? itemsLabel_.replace(/s$/, '') : itemsLabel_

	if (hideOnSinglePage && totalPages <= 1)
		return (
			<div className="flex items-center justify-end px-[16px] py-[12px] text-[12px] text-tertiary">
				<span className="text-primary tabular-nums">
					{Pagination.numFormat.format(totalItems)}
				</span>
				<span className="ml-[8px]">{itemsLabel}</span>
			</div>
		)

	if (compact)
		return (
			<div className="flex flex-col items-center gap-[12px] sm:flex-row sm:justify-between px-[16px] py-[12px] text-[12px] text-tertiary w-full">
				<div className="flex items-center gap-[6px]">
					<Link
						to="."
						resetScroll={false}
						search={(previous) => ({ ...previous, page: 1 })}
						disabled={page <= 1 || isPending}
						className={cx(
							'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[24px] text-primary',
						)}
						title="First page"
					>
						<ChevronFirst className="size-[14px]" />
					</Link>

					<Link
						to="."
						resetScroll={false}
						search={(previous) => ({
							...previous,
							page: (previous?.page ?? 1) - 1,
						})}
						disabled={page <= 1 || isPending}
						className={cx(
							'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[24px] text-primary',
						)}
						title="Previous page"
					>
						<ChevronLeft className="size-[14px]" />
					</Link>

					<span className="text-primary font-medium tabular-nums px-[4px] whitespace-nowrap">
						Page {Pagination.numFormat.format(page)} of{' '}
						{Pagination.numFormat.format(totalPages)}
					</span>

					<Link
						to="."
						type="button"
						resetScroll={false}
						search={(previous) => ({
							...previous,
							page: (previous?.page ?? 1) + 1,
						})}
						disabled={page >= totalPages || isPending}
						className={cx(
							'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[24px] text-primary',
						)}
						title="Next page"
					>
						<ChevronRight className="size-[14px]" />
					</Link>

					<Link
						to="."
						type="button"
						resetScroll={false}
						search={(previous) => ({
							...previous,
							page: totalPages,
						})}
						disabled={page >= totalPages || isPending}
						className={cx(
							'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[24px] text-primary',
						)}
						title="Last page"
					>
						<ChevronLast className="size-[14px]" />
					</Link>
				</div>

				<Pagination.Count totalItems={totalItems} itemsLabel={itemsLabel} />
			</div>
		)

	return (
		<div className="flex flex-col gap-[12px] px-[16px] py-[12px] text-[12px] text-tertiary md:flex-row md:items-center md:justify-between">
			<div className="flex flex-row items-center gap-[8px] mx-auto md:mx-0">
				<Link
					to="."
					resetScroll={false}
					search={(previous) => ({
						...previous,
						page: (previous?.page ?? 1) - 1,
					})}
					disabled={page <= 1 || isPending}
					className={cx(
						'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[28px] text-primary',
					)}
					title="Previous page"
				>
					<ChevronLeft className="size-[16px]" />
				</Link>

				<div className="flex items-center gap-[6px]">
					{(() => {
						const pages = Pagination.getPagination(page, totalPages)
						let ellipsisCount = 0

						return pages.map((p) =>
							p === Pagination.Ellipsis ? (
								<span
									key={`ellipsis-${ellipsisCount++}`}
									className="text-tertiary flex w-[28px] h-[28px] items-center justify-center"
								>
									…
								</span>
							) : (
								<Link
									key={p}
									to="."
									resetScroll={false}
									disabled={page === p || isPending}
									search={(previous) => ({ ...previous, page: p })}
									className={`rounded-[4px] flex w-[28px] h-[28px] items-center justify-center ${
										page === p
											? 'border border-accent/50 text-primary cursor-default'
											: 'cursor-pointer press-down hover:bg-alt text-primary'
									} ${isPending && page !== p ? 'opacity-50 cursor-not-allowed' : ''}`}
								>
									{p}
								</Link>
							),
						)
					})()}
				</div>

				<Link
					to="."
					resetScroll={false}
					search={(previous) => ({
						...previous,
						page: (previous?.page ?? 1) + 1,
					})}
					disabled={page >= totalPages || isPending}
					className={cx(
						'rounded-full! border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer press-down aria-disabled:cursor-default aria-disabled:opacity-50 size-[28px] text-primary',
					)}
					title="Next page"
				>
					<ChevronRight className="size-[16px]" />
				</Link>
			</div>

			<Pagination.Count
				page={page}
				totalPages={totalPages}
				totalItems={totalItems}
				itemsLabel={itemsLabel}
			/>
		</div>
	)
}

export namespace Pagination {
	export interface Props {
		page: number
		totalPages: number
		totalItems: number
		itemsLabel: string
		isPending: boolean
		compact?: boolean
		hideOnSinglePage?: boolean
	}

	export const Ellipsis = -1

	export const numFormat = new Intl.NumberFormat('en-US', {
		minimumFractionDigits: 0,
		maximumFractionDigits: 0,
	})

	export function getPagination(page: number, totalPages: number): number[] {
		if (totalPages <= 7)
			return Array.from({ length: totalPages }, (_, i) => i + 1)

		if (page <= 4)
			return [
				...Array.from({ length: 5 }, (_, i) => i + 1),
				Ellipsis,
				totalPages,
			]

		if (page >= totalPages - 3)
			return [
				1,
				Ellipsis,
				...Array.from({ length: 5 }, (_, i) => totalPages - 4 + i),
			]

		return [1, Ellipsis, page - 1, page, page + 1, Ellipsis, totalPages]
	}

	export function Simple(props: Simple.Props) {
		const { page, totalPages, isPending } = props
		return (
			<div className="flex items-center justify-center sm:justify-start gap-[6px]">
				<Link
					to="."
					resetScroll={false}
					search={(prev) => ({ ...prev, page: 1, live: true })}
					disabled={page <= 1 || isPending}
					className={cx(
						'rounded-full border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer active:translate-y-[0.5px] disabled:cursor-not-allowed disabled:opacity-50 size-[24px] text-primary',
					)}
					title="First page"
				>
					<ChevronFirst className="size-[14px]" />
				</Link>
				<Link
					to="."
					resetScroll={false}
					search={(prev) => {
						const newPage = (prev?.page ?? 1) - 1
						return { ...prev, page: newPage, live: newPage === 1 }
					}}
					disabled={page <= 1 || isPending}
					className={cx(
						'rounded-full border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer active:translate-y-[0.5px] disabled:cursor-not-allowed disabled:opacity-50 size-[24px] text-primary',
					)}
					title="Previous page"
				>
					<ChevronLeft className="size-[14px]" />
				</Link>
				<span className="text-primary font-medium tabular-nums px-[4px] whitespace-nowrap">
					Page {Pagination.numFormat.format(page)} of{' '}
					{Pagination.numFormat.format(totalPages)}
				</span>
				<Link
					to="."
					resetScroll={false}
					search={(prev) => ({
						...prev,
						page: (prev?.page ?? 1) + 1,
						live: false,
					})}
					disabled={page >= totalPages || isPending}
					className={cx(
						'rounded-full border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer active:translate-y-[0.5px] disabled:cursor-not-allowed disabled:opacity-50 size-[24px] text-primary',
					)}
					title="Next page"
				>
					<ChevronRight className="size-[14px]" />
				</Link>
				<Link
					to="."
					resetScroll={false}
					search={(prev) => ({ ...prev, page: totalPages, live: false })}
					disabled={page >= totalPages || isPending}
					className={cx(
						'rounded-full border border-base-border hover:bg-alt flex items-center justify-center cursor-pointer active:translate-y-[0.5px] disabled:cursor-not-allowed disabled:opacity-50 size-[24px] text-primary',
					)}
					title="Last page"
				>
					<ChevronLast className="size-[14px]" />
				</Link>
			</div>
		)
	}

	export namespace Simple {
		export interface Props {
			page: number
			totalPages: number
			isPending?: boolean
		}
	}

	export function Count(props: Count.Props) {
		const { page, totalPages, totalItems, itemsLabel } = props
		return (
			<div className="flex items-center justify-center sm:justify-end gap-[8px]">
				{page != null && totalPages != null && (
					<>
						<span className="text-tertiary">Page</span>
						<span className="text-primary">{page}</span>
						<span className="text-tertiary">of</span>
						<span className="text-primary">{totalPages}</span>
						<span className="text-tertiary">•</span>
					</>
				)}
				<span className="text-primary tabular-nums">
					{Pagination.numFormat.format(totalItems)}
				</span>
				<span className="text-tertiary">{itemsLabel}</span>
			</div>
		)
	}

	export namespace Count {
		export interface Props {
			page?: number
			totalPages?: number
			totalItems: number
			itemsLabel: string
		}
	}
}

```

## File: apps/explorer/src/comps/ProgressLine.tsx
```
import { useEffect, useState } from 'react'
import { cx } from '#cva.config'

interface ProgressLineProps {
	loading: boolean
	start?: number
	interval?: number
	className?: string
}

export function ProgressLine({
	loading,
	start = 0,
	interval = 300,
	className,
}: ProgressLineProps) {
	const endDelay = 200

	const [show, setShow] = useState(false)
	const [progress, setProgress] = useState(0)

	// Start delay
	useEffect(() => {
		if (!loading) return
		if (start === 0) {
			setShow(true)
			return
		}
		const delayTimer = setTimeout(() => setShow(true), start)
		return () => clearTimeout(delayTimer)
	}, [loading, start])

	// Progress interval
	useEffect(() => {
		if (!show || !loading) return

		setProgress(0)
		const progressTimer = setInterval(() => {
			setProgress((prev) => {
				if (prev >= 90) return prev
				return prev + Math.random() * 10
			})
		}, interval)

		return () => clearInterval(progressTimer)
	}, [show, loading, interval])

	// Finish progress
	useEffect(() => {
		if (loading) return

		setProgress(99)
		const hideTimer = setTimeout(() => {
			setShow(false)
			setProgress(0)
		}, endDelay)
		return () => clearTimeout(hideTimer)
	}, [loading])

	if (!show) return null
	return (
		<div
			className={cx('h-[1px] bg-inverse pointer-events-none', className)}
			style={{
				width: `${progress}%`,
				opacity: progress >= 99 ? 0 : 1,
				transition: progress >= 99 ? 'width 0.1s ease-out' : 'width 0.1s ease',
			}}
		/>
	)
}

```

## File: apps/explorer/src/comps/Receipt.tsx
```
import { Link } from '@tanstack/react-router'
import type { Address, Hex } from 'ox'
import { useState } from 'react'
import { ReceiptMark } from '#comps/ReceiptMark'
import { TxEventDescription } from '#comps/TxEventDescription'
import type { KnownEvent } from '#lib/domain/known-events'
import { DateFormatter, HexFormatter, PriceFormatter } from '#lib/formatting'
import { useCopy } from '#lib/hooks'

export function Receipt(props: Receipt.Props) {
	const {
		blockNumber,
		sender,
		hash,
		timestamp,
		events = [],
		fee,
		total,
		feeDisplay,
		totalDisplay,
		feeBreakdown = [],
	} = props
	const [hashExpanded, setHashExpanded] = useState(false)
	const copyHash = useCopy()
	const formattedTime = DateFormatter.formatTimestampTime(timestamp)

	const hasFee = feeDisplay !== undefined || (fee !== undefined && fee !== null)
	const hasTotal =
		totalDisplay !== undefined || (total !== undefined && total !== null)
	const showFeeBreakdown = feeBreakdown.length > 0

	return (
		<>
			<div className="flex flex-col w-[360px] bg-base-plane border border-base-border shadow-[0px_4px_44px_rgba(0,0,0,0.05)] rounded-[10px] text-base-content">
				<div className="flex gap-[40px] px-[20px] pt-[24px] pb-[16px]">
					<div className="shrink-0">
						<ReceiptMark />
					</div>
					<div className="flex flex-col gap-[8px] font-mono text-[13px] leading-[16px] flex-1">
						<div className="flex justify-between items-end">
							<span className="text-tertiary capitalize">Block</span>
							<Link
								to="/block/$id"
								params={{ id: blockNumber.toString() }}
								className="text-accent text-right before:content-['#'] press-down"
							>
								{String(blockNumber)}
							</Link>
						</div>
						<div className="flex justify-between items-end">
							<span className="text-tertiary capitalize">Sender</span>
							<Link
								to="/address/$address"
								params={{ address: sender }}
								className="text-accent text-right press-down"
								title={sender}
							>
								{HexFormatter.shortenHex(sender)}
							</Link>
						</div>
						<div className="flex justify-between items-start">
							<div className="relative">
								<span className="text-tertiary capitalize">Hash</span>
								{copyHash.notifying && (
									<span className="absolute left-[calc(100%+8px)] text-[13px] leading-[16px] text-accent">
										copied
									</span>
								)}
							</div>
							{hashExpanded ? (
								<button
									type="button"
									onClick={() => copyHash.copy(hash)}
									className="text-right break-all max-w-[11ch] cursor-pointer press-down"
								>
									{hash}
								</button>
							) : (
								<button
									type="button"
									onClick={() => setHashExpanded(true)}
									className="text-right cursor-pointer press-down"
									title={hash}
								>
									{HexFormatter.shortenHex(hash)}
								</button>
							)}
						</div>
						<div className="flex justify-between items-end">
							<span className="text-tertiary capitalize">Date</span>
							<span className="text-right">
								{DateFormatter.formatTimestampDate(timestamp)}
							</span>
						</div>
						<div className="flex justify-between items-end">
							<span className="text-tertiary capitalize">Time</span>
							<span className="text-right">
								{formattedTime.time} {formattedTime.timezone}
								<span className="text-tertiary">{formattedTime.offset}</span>
							</span>
						</div>
					</div>
				</div>
				{events.length > 0 && (
					<>
						<div className="border-t border-dashed border-base-border" />
						<div className="flex flex-col gap-3 px-[20px] py-[16px] font-mono text-[13px] leading-4 [counter-reset:event]">
							{events.map((event, index) => {
								// Calculate total amount from event parts
								// For swaps, only show the first amount (what's being swapped out)
								const amountParts = event.parts.filter(
									(part) => part.type === 'amount',
								)
								const firstAmountPart = amountParts[0]
								const totalAmountBigInt =
									event.type === 'swap' && amountParts.length > 0
										? firstAmountPart?.type === 'amount'
											? firstAmountPart.value.value
											: 0n
										: amountParts.reduce((sum, part) => {
												if (part.type === 'amount')
													return sum + part.value.value
												return sum
											}, 0n)
								const decimals =
									firstAmountPart?.type === 'amount'
										? (firstAmountPart.value.decimals ?? 6)
										: 6

								return (
									<div
										key={`${event.type}-${index}`}
										className="[counter-increment:event]"
									>
										<div className="flex flex-col gap-[8px]">
											<div className="flex flex-row justify-between items-start gap-[10px]">
												<div className="flex flex-row items-start gap-[4px] grow min-w-0 text-tertiary">
													<div className="flex items-center text-tertiary before:content-[counter(event)_'.'] shrink-0 leading-[24px] min-w-[20px]"></div>
													<TxEventDescription event={event} />
												</div>
												<div className="flex items-center text-right shrink-0 leading-[24px]">
													{totalAmountBigInt > 0n && (
														<span
															title={PriceFormatter.format(totalAmountBigInt, {
																decimals,
															})}
														>
															{PriceFormatter.format(totalAmountBigInt, {
																decimals,
																format: 'short',
															})}
														</span>
													)}
												</div>
											</div>
											{event.note && (
												<div className="flex flex-row items-center pl-[24px] gap-[11px] overflow-hidden">
													<div className="border-l border-base-border pl-[10px]">
														{typeof event.note === 'string' ? (
															<span
																className="text-tertiary items-end overflow-hidden text-ellipsis whitespace-nowrap"
																title={event.note}
															>
																{event.note}
															</span>
														) : (
															<div className="flex flex-col gap-1 text-secondary text-[13px]">
																{event.note.map(([label, part], index) => {
																	const key = `${label}${index}`
																	return (
																		<div key={key} className="flex gap-2">
																			<div className="text-tertiary">
																				{label}:
																			</div>
																			<TxEventDescription.Part part={part} />
																		</div>
																	)
																})}
															</div>
														)}
													</div>
												</div>
											)}
										</div>
									</div>
								)
							})}
						</div>
					</>
				)}
				{(showFeeBreakdown || hasFee || hasTotal) && (
					<>
						<div className="border-t border-dashed border-base-border" />
						<div className="flex flex-col gap-2 px-[20px] py-[16px] font-mono text-[13px] leading-4">
							{showFeeBreakdown
								? feeBreakdown.map((item, index) => {
										const formattedAmount = PriceFormatter.format(item.amount, {
											decimals: item.decimals,
											format: 'short',
										})
										const isSponsored =
											item.payer &&
											item.payer.toLowerCase() !== sender.toLowerCase()
										return (
											<div
												key={`${item.token ?? item.symbol ?? 'fee'}-${index}`}
												className="flex flex-wrap gap-2 items-center justify-between"
											>
												<span className="text-tertiary">
													Fee{' '}
													{item.symbol && (
														<span>
															(
															{item.token ? (
																<Link
																	to="/token/$address"
																	params={{ address: item.token }}
																	className="text-base-content-positive press-down"
																>
																	{item.symbol}
																</Link>
															) : (
																<span className="text-base-content-positive">
																	{item.symbol}
																</span>
															)}
															)
														</span>
													)}
												</span>
												<div className="flex items-center gap-1">
													{isSponsored && item.payer && (
														<>
															<Link
																to="/address/$address"
																params={{ address: item.payer }}
																className="text-accent press-down"
																title={item.payer}
															>
																{HexFormatter.shortenHex(item.payer)}
															</Link>
															<span className="text-tertiary">paid</span>
														</>
													)}
													<span>{formattedAmount}</span>
												</div>
											</div>
										)
									})
								: hasFee && (
										<div className="flex justify-between items-center">
											<span className="text-tertiary">Fee</span>
											<span className="text-right">
												{feeDisplay ??
													PriceFormatter.format(fee ?? 0, { format: 'short' })}
											</span>
										</div>
									)}
							{hasTotal && (
								<div className="flex justify-between items-center">
									<span className="text-tertiary">Total</span>
									<span className="text-right">
										{totalDisplay ??
											PriceFormatter.format(total ?? 0, { format: 'short' })}
									</span>
								</div>
							)}
						</div>
					</>
				)}
			</div>

			<div className="flex flex-col items-center -mt-5 w-full">
				<div className="max-w-[360px] w-full">
					<Link
						to="/tx/$hash"
						params={{ hash }}
						className="press-down text-[11px] px-[4px] flex"
					>
						View transaction
					</Link>
				</div>
			</div>
		</>
	)
}

export namespace Receipt {
	export interface Props {
		blockNumber: bigint
		sender: Address.Address
		hash: Hex.Hex
		timestamp: bigint
		events?: KnownEvent[]
		fee?: number
		feeDisplay?: string
		total?: number
		totalDisplay?: string
		feeBreakdown?: FeeBreakdownItem[]
	}

	export interface FeeBreakdownItem {
		amount: bigint
		decimals: number
		symbol?: string
		token?: Address.Address
		payer?: Address.Address
	}
}

```

## File: apps/explorer/src/comps/ReceiptMark.tsx
```
export function ReceiptMark() {
	return (
		<svg xmlns="http://www.w3.org/2000/svg" width={92} height={36} fill="none">
			<title>Tempo Receipt</title>
			<path
				className="fill-background-inverse"
				d="M83.722 19.168c2.086 0 4.01-1.495 4.01-4.451s-1.924-4.45-4.01-4.45-4.01 1.494-4.01 4.45 1.925 4.45 4.01 4.45m0-12.747C88.438 6.42 92 9.885 92 14.716s-3.56 8.296-8.278 8.296c-4.717 0-8.277-3.497-8.277-8.296 0-4.8 3.56-8.296 8.277-8.296M62.376 29.098h-4.267v-22.2h4.139v1.908c.706-1.207 2.47-2.258 4.844-2.258 4.62 0 7.282 3.497 7.282 8.138 0 4.64-2.983 8.233-7.442 8.233-2.182 0-3.786-.86-4.556-1.908zm7.796-14.381c0-2.765-1.732-4.386-3.914-4.386s-3.945 1.621-3.945 4.386 1.765 4.418 3.945 4.418 3.914-1.622 3.914-4.418M36.74 22.539h-4.268V6.898h4.074v1.907c.867-1.526 2.887-2.352 4.62-2.352 2.15 0 3.883.922 4.685 2.606 1.252-1.907 2.919-2.606 5.004-2.606 2.919 0 5.71 1.749 5.71 5.944v10.14h-4.138v-9.281c0-1.685-.834-2.956-2.792-2.956-1.829 0-2.919 1.398-2.919 3.083v9.154H42.48v-9.281c0-1.685-.866-2.956-2.79-2.956s-2.95 1.367-2.95 3.083zm-16.964-9.601h7.058c-.064-1.557-1.09-3.083-3.53-3.083-2.213 0-3.432 1.653-3.528 3.083m7.476 4.068 3.56 1.049c-.802 2.702-3.304 4.958-7.186 4.958-4.33 0-8.15-3.084-8.15-8.36 0-4.991 3.723-8.233 7.765-8.233 4.876 0 7.796 3.083 7.796 8.106 0 .604-.065 1.24-.065 1.303H19.68c.097 2.066 1.86 3.56 3.979 3.56 1.989 0 3.08-.986 3.594-2.383"
			/>
			<path
				className="fill-background-inverse"
				d="M18.833 4.164h-7.186v18.373h-4.46V4.164H0V0h18.833zm72.781 30.141v1.158h-33.81v-1.158zm0-3.182v1.157h-33.81v-1.157zm0-3.183v1.158H64.446V27.94zm-81.497 4.668H8.395v3.22H7.188v-8.253h2.894c1.721 0 2.784.96 2.784 2.522 0 1.075-.601 1.968-1.547 2.288l1.704 3.443h-1.365zm-1.722-4.021v3.06h1.518c1.103 0 1.727-.555 1.727-1.527s-.619-1.533-1.686-1.533zM19.58 34.77v1.058h-5.065v-8.253h5.065v1.058h-3.846v2.5h3.63v.995h-3.63v2.642zm4.555.138c1.05 0 1.715-.641 1.739-1.682h1.225c0 1.67-1.184 2.774-2.958 2.774-2.008 0-3.18-1.298-3.18-3.535v-1.527c0-2.237 1.172-3.535 3.18-3.535 1.82 0 2.935 1.081 2.958 2.894h-1.225c-.035-1.08-.735-1.802-1.745-1.802-1.26 0-1.92.841-1.92 2.443v1.527c0 1.602.66 2.442 1.926 2.442m9.503-.137v1.058h-5.065v-8.253h5.065v1.058h-3.845v2.5h3.63v.995h-3.63v2.642zm6.692 1.058h-4.646v-1.035H37.4V28.61h-1.716v-1.035h4.645v1.035h-1.715v6.183h1.715zm2.08-8.253h2.883c1.675 0 2.766 1.058 2.766 2.694 0 1.63-1.109 2.688-2.801 2.688H43.63v2.871h-1.22zm1.22 1.018v3.352h1.365c1.185 0 1.827-.59 1.827-1.676 0-1.093-.642-1.676-1.827-1.676zm9.042 7.235H51.46v-7.195h-2.504v-1.058h6.22v1.058h-2.503z"
			/>
		</svg>
	)
}

```

## File: apps/explorer/src/comps/RelativeTime.tsx
```
import * as React from 'react'
import { DateFormatter } from '#lib/formatting'

export function RelativeTime(props: RelativeTime.Props) {
	const { timestamp, ...props_ } = props
	const timeProps = RelativeTime.useRelativeTime<HTMLTimeElement>(timestamp)
	return <time {...timeProps} {...props_} />
}

export namespace RelativeTime {
	export interface Props extends React.HTMLAttributes<HTMLTimeElement> {
		timestamp: bigint
	}

	export function useRelativeTime<T extends HTMLElement = HTMLElement>(
		timestamp: bigint,
	) {
		const ref = React.useRef<T>(null)
		const prev = React.useRef<string>('')

		React.useEffect(() => {
			const updateTime = () => {
				if (!ref.current) return
				const { text } = DateFormatter.formatRelativeTime(timestamp)
				if (text === prev.current) return
				ref.current.textContent = prev.current = text
			}

			updateTime()
			const interval = setInterval(updateTime, 1000)
			return () => clearInterval(interval)
		}, [timestamp])

		const { text, fullDate } = DateFormatter.formatRelativeTime(timestamp)
		const iso = new Date(Number(timestamp) * 1_000).toISOString()

		return {
			ref,
			title: fullDate,
			children: text,
			dateTime: iso,
		}
	}
}

```

## File: apps/explorer/src/comps/Sections.tsx
```
import * as React from 'react'
import { cx } from '#cva.config.ts'

export function Sections(props: Sections.Props) {
	const {
		sections,
		activeSection = 0,
		onSectionChange,
		className,
		mode = Sections.defaultMode,
	} = props

	const [collapsedSections, setCollapsedSections] = React.useState<boolean[]>(
		new Array(sections.length).fill(true),
	)

	const toggleSection = (index: number) => {
		setCollapsedSections((collapsed) =>
			collapsed.map((v, i) => (i === index ? !v : v)),
		)
	}

	if (mode === 'stacked')
		return (
			<Sections.Context.Provider value={{ mode }}>
				<div className={cx('flex flex-col gap-[14px]', className)}>
					{sections.map((section, index) => {
						const itemsLabel = section.itemsLabel ?? 'items'
						const isCollapsed =
							section.autoCollapse !== false && collapsedSections[index]

						const canCollapse = section.autoCollapse !== false

						return (
							<section
								key={section.title}
								className={cx(
									'flex flex-col font-mono w-full overflow-hidden',
									'rounded-[10px] border border-card-border bg-card-header',
									'shadow-[0px_4px_44px_rgba(0,0,0,0.05)]',
								)}
							>
								{canCollapse ? (
									<button
										type="button"
										onClick={() => toggleSection(index)}
										className={cx(
											'h-[54px] flex items-center justify-between px-[18px] cursor-pointer press-down -outline-offset-[2px]!',
											isCollapsed ? 'rounded-[10px]!' : 'rounded-t-[10px]!',
										)}
									>
										<h1 className="text-[13px] font-medium uppercase text-primary">
											{section.title}
										</h1>
										<div className="flex items-center gap-[12px]">
											{isCollapsed && (
												<span className="text-[13px] text-tertiary">
													{section.totalItems} {itemsLabel}
												</span>
											)}
											<div
												className={cx(
													'accent text-[16px] font-mono',
													isCollapsed ? 'text-accent' : 'text-tertiary',
												)}
											>
												[{isCollapsed ? '+' : '–'}]
											</div>
										</div>
									</button>
								) : (
									<div className="h-[54px] flex items-center justify-between px-[18px] rounded-t-[10px]">
										<h1 className="text-[13px] font-medium uppercase text-primary">
											{section.title}
										</h1>
									</div>
								)}

								{!isCollapsed && (
									<div className="rounded-t-[10px] border-t border border-card-border bg-card -mb-[1px] -mx-[1px] flex flex-col min-h-0 overflow-x-auto focus-visible:outline-2 focus-visible:outline-accent focus-visible:-outline-offset-2! focus-visible:rounded-[2px]!">
										{section.contextual && (
											<div className="px-[18px] py-[10px] border-b border-dashed border-card-border">
												{section.contextual}
											</div>
										)}
										{section.content}
									</div>
								)}
							</section>
						)
					})}
				</div>
			</Sections.Context.Provider>
		)

	const currentSection = sections[activeSection]
	if (!currentSection)
		throw new Error(`Invalid activeSection index: ${activeSection}`)

	return (
		<Sections.Context.Provider value={{ mode }}>
			<section
				className={cx(
					'flex flex-col font-mono w-full overflow-hidden min-h-0 self-start',
					'rounded-[10px] border border-card-border bg-card-header',
					'shadow-[0px_4px_44px_rgba(0,0,0,0.05)]',
					className,
				)}
			>
				<div className="h-[40px] flex items-center justify-between">
					<div className="flex items-center h-full">
						{sections.length === 1 ? (
							<div className="h-full flex items-center gap-[8px] text-[13px] font-medium pl-[18px] pr-[12px]">
								<span className="text-primary">{sections[0].title}</span>
								<span className="text-tertiary">
									({sections[0].totalItems})
								</span>
							</div>
						) : (
							sections.map((section, index) => (
								<button
									key={section.title}
									type="button"
									onClick={() => onSectionChange?.(index)}
									className={cx(
										'h-full flex items-center text-[13px] font-medium',
										'focus-visible:-outline-offset-2! press-down cursor-pointer transition-[color]',
										index === 0
											? 'pl-[18px] pr-[12px] !rounded-tl-[10px]'
											: 'px-[12px]',
										activeSection === index
											? 'text-primary'
											: 'text-tertiary hover:text-secondary',
									)}
								>
									<div className="relative h-full flex items-center">
										{section.title}
										{activeSection === index && (
											<div className="absolute h-[2px] bg-accent -bottom-[1.5px] left-0 right-0 -mx-[2px]" />
										)}
									</div>
								</button>
							))
						)}
					</div>
					{currentSection.contextual && (
						<div className="pr-[18px]">{currentSection.contextual}</div>
					)}
				</div>

				<div className="rounded-t-[10px] border-t border border-card-border bg-card -mb-[1px] -mx-[1px] flex flex-col min-h-0 overflow-x-auto focus-visible:outline-2 focus-visible:outline-accent focus-visible:-outline-offset-2! focus-visible:rounded-[2px]!">
					{currentSection.content}
				</div>
			</section>
		</Sections.Context.Provider>
	)
}

export namespace Sections {
	export interface Props {
		sections: Section[]
		activeSection?: number
		onSectionChange?: (index: number) => void
		className?: string
		mode?: Mode
	}

	export type Mode = 'tabs' | 'stacked'

	export interface Section {
		title: string
		content: React.ReactNode
		totalItems: number
		itemsLabel?: string
		contextual?: React.ReactNode
		autoCollapse?: boolean
	}

	export const defaultMode = 'tabs'

	export const Context = React.createContext<{
		mode: Mode
	}>({ mode: defaultMode })

	export function useSectionsMode() {
		const { mode } = React.useContext(Context)
		return mode
	}
}

```

## File: apps/explorer/src/comps/Sphere.tsx
```
export function Sphere(props: Sphere.Props) {
	const { animate } = props
	return (
		<div className="fixed bottom-0 w-full pointer-events-none overflow-hidden h-[280px] z-0">
			<div
				ref={(el) => {
					if (!el) return
					el.style.opacity = '1'
					el.style.transform = 'translate3d(0, 0, 0) scale3d(1, 1, 1)'
				}}
				className="absolute top-0 z-0 w-full flex justify-center pointer-events-none transition-[transform,opacity] duration-1000 ease-out"
				style={
					animate
						? {
								opacity: 0,
								transform: 'translate3d(0, 20px, 0) scale3d(1.03, 1.03, 1)',
							}
						: undefined
				}
			>
				<Sphere.Svg />
			</div>
		</div>
	)
}

export namespace Sphere {
	export interface Props {
		animate?: boolean
	}
	export function Svg() {
		return (
			<svg
				fill="none"
				width={720}
				height={620}
				viewBox="0 0 720 620"
				aria-hidden="true"
			>
				<path
					strokeLinecap="round"
					strokeLinejoin="round"
					d="M360 312.533c-.172-31.193 17.71-59.928 41.328-79.219 38.266-31.179 89.225-43.814 137.942-42.664 46.086 1.451 93.682 15.424 128.699 46.373 21.462 18.989 37.174 46.315 37.03 75.51.158 29.195-15.568 56.522-37.03 75.511-35.017 30.949-82.613 44.921-128.699 46.373-48.717 1.15-99.676-11.486-137.942-42.664-23.632-19.291-41.486-48.026-41.328-79.22m0 0c-.072-52.813 43.901-81.232 92.647-83.632 42.593-2.286 85.142 11.097 121.885 32.027 51.103 29.669 102.781 82.64 104.204 144.955.33 40.623-27.499 69.789-65.694 79.449-30.676 7.878-63.537 4.6-93.667-4.154-50.499-15.079-97.103-45.812-128.943-88.031-17.164-23.244-30.288-51.26-30.432-80.614m0 0c.431-67.159 51.822-76.388 102.896-47.71 30.777 17.135 56.853 42.262 78.674 69.675 32.789 42.362 61.194 95.98 62.387 150.532.058 56.752-39.157 76.057-88.866 54.552-41.227-18.241-74.376-51.476-100.883-87.298-28.879-40.637-53.101-89.051-54.208-139.751m0 0c.072-52.813-43.901-81.232-92.646-83.632-42.593-2.286-85.143 11.097-121.886 32.027-51.103 29.669-102.78 82.64-104.204 144.955-.33 40.623 27.5 69.789 65.694 79.449 30.676 7.878 63.537 4.6 93.667-4.154 50.499-15.079 97.103-45.812 128.943-88.031 17.164-23.244 30.288-51.26 30.432-80.614m0 0c.173-31.193-17.71-59.928-41.328-79.219-38.266-31.179-89.225-43.814-137.942-42.664-46.086 1.451-93.682 15.424-128.699 46.373-21.462 18.989-37.174 46.315-37.03 75.51-.158 29.195 15.583 56.522 37.03 75.511 35.017 30.949 82.613 44.921 128.699 46.373 48.717 1.15 99.676-11.486 137.942-42.664 23.632-19.291 41.486-48.026 41.328-79.22m0 0c-.144-29.353-13.268-57.37-30.432-80.614-31.84-42.218-78.444-72.952-128.943-88.031-30.13-8.754-62.991-12.031-93.667-4.154-38.223 9.674-66.01 38.841-65.694 79.449C42.73 283.51 97.93 338.336 151.391 367.43c36.9 19.823 79.479 32.099 121.597 28.29 46.819-4.04 87.141-32.947 87.012-83.187m0 0c.144-29.353 13.268-57.37 30.432-80.614 31.841-42.218 78.444-72.952 128.943-88.031 30.13-8.754 62.991-12.031 93.668-4.154 38.223 9.674 66.009 38.841 65.693 79.449C677.27 283.51 622.07 338.336 568.61 367.43c-36.901 19.823-79.48 32.099-121.598 28.29-46.819-4.04-87.141-32.947-87.012-83.187m0 0c.029-30.46 15.769-58.979 36.326-80.628 34.844-36.282 83.446-57.973 132.853-65.146 33.12-4.571 68.008-2.616 99.446 9.315 38.036 14.058 70.049 46.315 69.747 88.864-1.61 68.812-69.287 118.017-129.691 136.848-49.881 15.367-107.007 16.876-154.344-7.331-30.963-15.769-54.754-46.143-54.337-81.922m-.001-.001c-.388-35.865 23.331-66.08 54.338-81.921 47.336-24.208 104.462-22.698 154.343-7.332 60.418 18.831 128.081 68.036 129.691 136.848.317 42.535-31.725 74.821-69.747 88.865-31.438 11.931-66.326 13.886-99.446 9.315-49.407-7.173-98.008-28.865-132.853-65.147-20.571-21.662-36.282-50.167-36.326-80.628m0 0c-.431-67.159-51.821-76.387-102.895-47.709-30.777 17.135-56.853 42.262-78.675 69.675-32.789 42.362-61.194 95.98-62.387 150.532-.057 56.752 39.157 76.057 88.866 54.552 41.227-18.241 74.376-51.476 100.883-87.298 28.88-40.637 53.102-89.052 54.208-139.752m0 0c.389-35.865-23.33-66.08-54.337-81.921-47.337-24.208-104.463-22.698-154.344-7.332C90.9 242.11 23.238 291.315 21.628 360.127c-.317 42.535 31.725 74.821 69.747 88.865 31.438 11.931 66.326 13.886 99.446 9.315 49.406-7.173 98.008-28.865 132.853-65.147 20.57-21.662 36.282-50.167 36.325-80.628m0 0c-.028-30.46-15.769-58.978-36.325-80.627-34.845-36.282-83.447-57.973-132.854-65.146-33.12-4.571-68.008-2.616-99.445 9.315-38.037 14.058-70.05 46.315-69.748 88.864 1.625 68.812 69.288 118.017 129.691 136.848 49.881 15.367 107.007 16.876 154.344-7.331 30.964-15.769 54.754-46.144 54.337-81.923m0 0c-1.106-50.714-25.328-99.113-54.208-139.751-26.507-35.822-59.656-69.056-100.883-87.298-49.852-21.576-88.923-2.055-88.866 54.552 1.208 54.567 29.598 108.156 62.387 150.533 21.822 27.413 47.898 52.54 78.675 69.675 51.217 28.749 102.464 19.319 102.895-47.711m0 0c1.107-50.714 25.33-99.113 54.209-139.751 26.507-35.822 59.656-69.056 100.883-87.298 49.853-21.576 88.924-2.055 88.866 54.552-1.207 54.567-29.598 108.156-62.387 150.533-21.821 27.413-47.897 52.54-78.674 69.675-51.218 28.749-102.465 19.319-102.897-47.711m.001-50.526V607m0-588.934V363.06m286.852 84.998c-1.178-56.119-38.251-108.875-78.314-145.674-32.301-28.922-71.53-52.655-114.756-59.971-45.482-7.734-88.578 10.608-93.336 60.762-5.549 77.235 67.102 159.056 131.732 193.398 27.657 14.748 59.239 25.529 90.936 22.784 39.732-3.45 64.126-31.697 63.738-71.299m-95.177 67.318c-1.107-53.244-21.031-105.841-45.77-152.43-5.06-9.3-11.112-19.478-16.905-28.333-19.507-29.037-46.489-63.867-79.997-76.631-45.051-14.878-51.62 37.115-48.343 69.588 6.555 65.304 37.39 133.886 76.475 186.225 18.026 22.885 40.236 48.084 68.77 57.154 36.182 9.876 46.143-27.082 45.77-55.573m-59.655 22.54c-1.05-58.175-16.158-115.818-36.038-170.212-12.521-32.214-34.241-83.46-62.229-103.958-25.142-16.804-32.229 16.502-33.293 35.232-1.897 31.438 2.976 63.177 9.272 93.896 11.744 53.489 29.138 106.589 56.278 154.328 30.762 53.416 65.463 66.972 66.01-9.286m-64.716 13.871c-.216-40.494-4.384-81.189-9.861-121.28-5.736-40.393-12.923-80.973-23.791-120.317-3.536-13.685-23.546-78.817-31.567-32.487-4.356 34.169-1.193 69.056 1.581 103.24 4.773 49.492 12.276 99.042 23.417 147.513 3.364 14.26 7.202 28.994 11.831 42.895 3.291 9.3 6.612 19.176 12.319 27.312 16.272 20.469 16.042-39.373 16.071-46.876m-134.609 0c.216-40.494 4.385-81.189 9.862-121.28 5.735-40.393 12.923-80.973 23.79-120.317 3.536-13.685 23.546-78.817 31.567-32.487 4.356 34.169 1.194 69.056-1.581 103.24-4.772 49.492-12.276 99.042-23.417 147.513-3.363 14.26-7.201 28.994-11.83 42.895-3.292 9.3-6.613 19.176-12.319 27.312-16.273 20.469-16.043-39.373-16.072-46.876m-64.714-13.871c1.05-58.175 16.158-115.818 36.038-170.212 12.521-32.214 34.242-83.46 62.23-103.958 25.141-16.804 32.228 16.502 33.292 35.232 1.897 31.438-2.976 63.177-9.272 93.896-11.744 53.489-29.138 106.589-56.278 154.328-30.762 53.416-65.463 66.972-66.01-9.286m-59.657-22.54c1.107-53.244 21.03-105.841 45.769-152.43 5.06-9.3 11.112-19.478 16.905-28.333 19.507-29.037 46.489-63.867 79.997-76.631 45.051-14.878 51.62 37.115 48.343 69.588-6.555 65.304-37.389 133.886-76.475 186.225-18.026 22.885-40.235 48.084-68.77 57.154-36.181 9.876-46.143-27.082-45.769-55.573m-95.175-67.318c1.178-56.119 38.252-108.875 78.315-145.674 32.3-28.922 71.529-52.655 114.755-59.971 45.482-7.734 88.578 10.608 93.336 60.762 5.549 77.235-67.102 159.056-131.732 193.398-27.657 14.748-59.239 25.529-90.936 22.784-39.732-3.45-64.126-31.697-63.738-71.299m0-271.051c-.302-42.017 26.521-69.904 68.482-71.644 34.528-1.337 68.18 12.046 97.376 29.526 44.648 27.513 82.684 67.389 105.368 114.883 12.061 26.234 20.096 56.594 12.866 85.257-8.395 33.119-37.835 49.521-70.581 49.277-53.087-.949-102.25-30.949-140.171-66.225-37.834-36.512-72.176-86.895-73.34-141.074m95.174-67.316c-.388-30.504 10.911-67.504 49.019-54.553 29.037 11.155 50.844 36.857 69.201 61.05 37.72 52.482 68.338 121.582 73.154 186.469 2.559 34.112-7.331 80.973-52.023 63.178-32.387-14.433-57.284-46.589-76.676-75.382-5.793-8.855-11.859-19.032-16.905-28.332-24.739-46.589-44.663-99.172-45.77-152.43m59.658-25.793c.087-15.726 1.495-57.859 25.142-52.856 18.558 5.735 34.011 31.94 43.456 48.098 26.565 48.543 43.786 102.118 54.998 156.167 5.563 28.664 9.761 58.276 7.964 87.528-1.179 20.671-9.186 53.676-35.578 33.594-27.14-22.425-47.207-69.646-59.944-102.32-19.88-54.394-34.988-112.036-36.038-170.211m64.714-20.786c0-8.222-.086-67.202 16.072-46.876 5.706 8.136 9.027 18.012 12.319 27.312 4.629 13.915 8.467 28.62 11.831 42.894 11.14 48.472 18.644 98.022 23.416 147.514 2.775 34.184 5.937 69.071 1.582 103.24-8.036 46.387-28.075-18.96-31.568-32.487-10.867-39.344-18.055-79.924-23.79-120.317-5.477-40.091-9.646-80.786-9.862-121.28m134.609 0c0-8.222.086-67.202-16.071-46.876-5.707 8.136-9.028 18.012-12.319 27.312-4.629 13.915-8.467 28.62-11.831 42.894-11.141 48.472-18.644 98.022-23.417 147.514-2.774 34.184-5.937 69.071-1.581 103.24 8.035 46.387 28.074-18.96 31.567-32.487 10.868-39.344 18.055-79.924 23.791-120.317 5.477-40.091 9.645-80.786 9.861-121.28m64.717 20.786c-.087-15.726-1.495-57.859-25.142-52.856-18.558 5.735-34.011 31.94-43.456 48.098-26.565 48.543-43.786 102.118-54.998 156.167-5.563 28.664-9.761 58.276-7.964 87.528 1.179 20.671 9.186 53.676 35.578 33.594 27.14-22.425 47.207-69.646 59.944-102.32 19.88-54.394 34.988-112.036 36.038-170.211m59.654 25.793c.388-30.504-10.911-67.504-49.019-54.553-29.037 11.155-50.844 36.857-69.201 61.05-37.719 52.482-68.338 121.582-73.154 186.469-2.558 34.112 7.332 80.973 52.023 63.178 32.387-14.433 57.284-46.589 76.676-75.382 5.793-8.855 11.86-19.032 16.905-28.332 24.74-46.589 44.663-99.172 45.77-152.43m95.177 67.316c.302-42.017-26.522-69.904-68.482-71.644-34.529-1.337-68.181 12.046-97.376 29.526-44.649 27.513-82.685 67.389-105.369 114.883-12.06 26.234-20.096 56.594-12.865 85.257 8.395 33.119 37.835 49.521 70.581 49.277 53.087-.949 102.249-30.949 140.17-66.225 37.835-36.512 72.177-86.895 73.341-141.074"
					style={{ stroke: 'light-dark(#e8e8e8, #303030)' }}
				/>
			</svg>
		)
	}
}

```

## File: apps/explorer/src/comps/TimeFormat.tsx
```
import * as React from 'react'
import { RelativeTime } from '#comps/RelativeTime'

export type TimeFormat = 'relative' | 'local' | 'utc' | 'unix'

export function useTimeFormat(initialFormat: TimeFormat = 'relative') {
	const [timeFormat, setTimeFormat] = React.useState<TimeFormat>(initialFormat)

	const cycleTimeFormat = React.useCallback(() => {
		setTimeFormat((current) => {
			if (current === 'relative') return 'local'
			if (current === 'local') return 'utc'
			if (current === 'utc') return 'unix'
			return 'relative'
		})
	}, [])

	const formatLabel = React.useMemo(() => {
		if (timeFormat === 'relative') return 'relative'
		if (timeFormat === 'local') return 'local'
		if (timeFormat === 'utc') return 'UTC'
		return 'unix'
	}, [timeFormat])

	return { timeFormat, setTimeFormat, cycleTimeFormat, formatLabel }
}

export function FormattedTimestamp(props: {
	timestamp: bigint
	format: TimeFormat
	className?: string
}) {
	const { timestamp, format, className } = props
	const date = new Date(Number(timestamp) * 1000)

	if (format === 'relative') {
		return <RelativeTime timestamp={timestamp} className={className} />
	}

	if (format === 'unix') {
		return (
			<time dateTime={date.toISOString()} className={className}>
				{timestamp.toString()}
			</time>
		)
	}

	if (format === 'local') {
		const formatted = new Intl.DateTimeFormat('en-US', {
			month: 'short',
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit',
			second: '2-digit',
			hour12: false,
		}).format(date)
		const tz =
			new Intl.DateTimeFormat('en-US', { timeZoneName: 'short' })
				.formatToParts(date)
				.find((p) => p.type === 'timeZoneName')?.value ?? ''
		return (
			<time dateTime={date.toISOString()} className={className}>
				{formatted} {tz}
			</time>
		)
	}

	// utc
	const formatted = new Intl.DateTimeFormat('en-US', {
		month: 'short',
		day: 'numeric',
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit',
		hour12: false,
		timeZone: 'UTC',
	}).format(date)
	return (
		<time dateTime={date.toISOString()} className={className}>
			{formatted} UTC
		</time>
	)
}

export function TimeColumnHeader(props: {
	label?: string
	formatLabel: string
	onCycle: () => void
	className?: string
}) {
	const { label = 'Time', formatLabel, onCycle, className } = props
	return (
		<button
			type="button"
			onClick={onCycle}
			className={className}
			title={`Showing ${formatLabel} time - click to change`}
		>
			{label}
		</button>
	)
}

```

## File: apps/explorer/src/comps/TimestampCell.tsx
```
import { Link } from '@tanstack/react-router'
import { FormattedTimestamp, type TimeFormat } from '#comps/TimeFormat'

export function TimestampCell(props: {
	timestamp: bigint
	link?: string
	format?: TimeFormat
	className?: string
}) {
	const { timestamp, link, format = 'relative', className } = props

	if (link) {
		return (
			<div className="text-nowrap">
				<Link to={link} className="text-tertiary hover:text-secondary">
					<FormattedTimestamp timestamp={timestamp} format={format} />
				</Link>
			</div>
		)
	}

	return (
		<FormattedTimestamp
			timestamp={timestamp}
			format={format}
			className={className ?? 'text-tertiary'}
		/>
	)
}

```

## File: apps/explorer/src/comps/TransactionCell.tsx
```
import { Link } from '@tanstack/react-router'
import type { Hex } from 'ox'
import { TruncatedHash } from '#comps/TruncatedHash'

export function TransactionCell(props: { hash: Hex.Hex; chars?: number }) {
	const { hash, chars = 6 } = props
	return (
		<Link
			to="/receipt/$hash"
			params={{ hash }}
			className="text-[13px] text-tertiary press-down"
			title={hash}
		>
			<TruncatedHash hash={hash} minChars={chars} />
		</Link>
	)
}

```

## File: apps/explorer/src/comps/TruncatedHash.tsx
```
import type { Hex } from 'ox'
import * as React from 'react'
import { cx } from '#cva.config.ts'
import { HexFormatter } from '#lib/formatting.ts'

/**
 * Displays a hex hash that truncates in the middle when space is limited.
 * Dynamically adjusts based on available container width.
 */
export function TruncatedHash(props: TruncatedHash.Props) {
	const { hash, minChars = 16, className } = props

	const containerRef = React.useRef<HTMLSpanElement>(null)
	const measureRef = React.useRef<HTMLSpanElement>(null)
	const textRef = React.useRef<HTMLSpanElement>(null)

	React.useLayoutEffect(() => {
		const container = containerRef.current
		const measure = measureRef.current
		const text = textRef.current
		if (!container || !measure || !text) return

		const calculateDisplay = () => {
			const containerWidth = container.offsetWidth

			// Measure the width of the full hash
			measure.textContent = hash
			const fullWidth = measure.offsetWidth

			if (fullWidth <= containerWidth) {
				// Full hash fits
				text.textContent = hash
				return
			}

			// Measure width of ellipsis
			measure.textContent = '…'
			const ellipsisWidth = measure.offsetWidth

			// Available width for hash characters
			const availableWidth = containerWidth - ellipsisWidth

			// Measure width of a single character (use '0' as reference for monospace)
			measure.textContent = '0'
			const charWidth = measure.offsetWidth

			// Calculate how many total chars we can fit
			const maxChars = Math.floor(availableWidth / charWidth)

			// Split evenly between start and end, but ensure minimum
			const prefixLength = 2 // "0x"
			const charsPerSide = Math.max(
				minChars,
				Math.floor((maxChars - prefixLength) / 2),
			)

			text.textContent = HexFormatter.shortenHex(hash, charsPerSide)
		}

		// Initial calculation
		calculateDisplay()

		// Watch for resize with debounce to reduce flicker
		let rafId: number | null = null
		const resizeObserver = new ResizeObserver(() => {
			if (rafId) cancelAnimationFrame(rafId)
			rafId = requestAnimationFrame(calculateDisplay)
		})
		resizeObserver.observe(container)

		return () => {
			if (rafId) cancelAnimationFrame(rafId)
			resizeObserver.disconnect()
		}
	}, [hash, minChars])

	return (
		<span
			ref={containerRef}
			className={cx('block overflow-hidden whitespace-nowrap', className)}
		>
			{/* Hidden span for measuring text width */}
			<span
				ref={measureRef}
				aria-hidden
				className="absolute invisible whitespace-nowrap pointer-events-none"
			/>
			{/* Text span that gets updated directly via ref to avoid re-renders */}
			<span ref={textRef}>{HexFormatter.shortenHex(hash, minChars)}</span>
		</span>
	)
}

declare namespace TruncatedHash {
	export interface Props {
		hash: Hex.Hex
		minChars?: number
		className?: string
	}
}

```

## File: apps/explorer/src/comps/TxDecodedCalldata.tsx
```
import type { AbiFunction } from 'abitype'
import { useMemo, useState } from 'react'
import {
	type Abi,
	type Address,
	decodeAbiParameters,
	type Hex,
	parseAbiItem,
	slice,
} from 'viem'
import {
	formatAbiValue,
	getAbiItem,
	useAutoloadAbi,
	useLookupSignature,
} from '#lib/abi'
import { useCopy } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

export function TxDecodedCalldata(props: TxDecodedCalldata.Props) {
	const { address, data } = props
	const selector = slice(data, 0, 4)
	const copySignature = useCopy()
	const copyRaw = useCopy()
	const [showRaw, setShowRaw] = useState(false)

	const { data: autoloadAbi } = useAutoloadAbi({
		address,
		enabled: Boolean(data) && data !== '0x',
	})

	const { data: signature, isFetched } = useLookupSignature({
		selector,
	})

	const signatureAbi = useMemo(() => {
		if (!signature) return
		return [parseAbiItem(`function ${signature}`) as AbiFunction] as const
	}, [signature])

	const abiItem = useMemo(() => {
		const autoloadAbiItem =
			autoloadAbi &&
			(getAbiItem({
				abi: autoloadAbi as unknown as Abi,
				selector,
			}) as AbiFunction)

		const signatureAbiItem =
			signatureAbi &&
			(getAbiItem({
				abi: signatureAbi,
				selector,
			}) as AbiFunction)

		if (autoloadAbiItem) {
			if (
				(signatureAbiItem?.inputs?.length || 0) >
				(autoloadAbiItem?.inputs?.length || 0)
			)
				return signatureAbiItem
			return autoloadAbiItem
		}

		return signatureAbiItem
	}, [autoloadAbi, signatureAbi, selector])

	const rawArgs = abiItem && data.length > 10 ? slice(data, 4) : undefined
	const { args } = useMemo(() => {
		if (abiItem && rawArgs && 'name' in abiItem && 'inputs' in abiItem) {
			try {
				return {
					args: decodeAbiParameters(abiItem.inputs, rawArgs),
				}
			} catch {}
		}
		return { args: undefined }
	}, [abiItem, rawArgs])

	if (!isFetched || !abiItem)
		return (
			<div className="bg-distinct rounded-[6px] overflow-hidden">
				<div className="relative px-[10px] py-[8px]">
					<pre className="text-[12px] text-primary break-all whitespace-pre-wrap font-mono max-h-[300px] overflow-auto pr-[40px]">
						{data}
					</pre>
					<div className="absolute top-[8px] right-[10px] flex items-center gap-[4px] text-tertiary bg-distinct pl-[8px]">
						{copyRaw.notifying && (
							<span className="text-[11px] select-none">copied</span>
						)}
						<button
							type="button"
							className="press-down cursor-pointer hover:text-secondary p-[4px]"
							onClick={() => copyRaw.copy(data)}
							title="Copy raw data"
						>
							<CopyIcon className="size-[14px]" />
						</button>
					</div>
				</div>
			</div>
		)

	return (
		<div className="flex flex-col gap-[8px]">
			<div className="bg-distinct rounded-[6px] overflow-hidden">
				<div className="flex items-center justify-between px-[10px] py-[8px] border-b border-card-border">
					<code className="text-[12px] text-primary font-mono">
						<span className="text-base-content-positive">
							{'name' in abiItem ? abiItem.name : selector}
						</span>
						<span className="text-secondary">(</span>
						{abiItem.inputs?.map((input, i) => (
							<span key={`${input.type}-${input.name ?? i}`}>
								{i > 0 && <span className="text-secondary">, </span>}
								<span className="text-secondary">{input.type}</span>
								{input.name && (
									<span className="text-primary"> {input.name}</span>
								)}
							</span>
						))}
						<span className="text-secondary">)</span>
					</code>
					<div className="flex items-center gap-[4px] text-tertiary">
						{copySignature.notifying && (
							<span className="text-[11px] select-none">copied</span>
						)}
						<button
							type="button"
							className="press-down cursor-pointer hover:text-secondary p-[4px]"
							onClick={() =>
								copySignature.copy(
									`${abiItem.name}(${abiItem.inputs?.map((input) => `${input.type}${input.name ? ` ${input.name}` : ''}`).join(', ') ?? ''})`,
								)
							}
							title="Copy signature"
						>
							<CopyIcon className="size-[14px]" />
						</button>
					</div>
				</div>
				{args && args.length > 0 && (
					<div className="divide-y divide-card-border">
						{abiItem.inputs?.map((input, i) => (
							<TxDecodedCalldata.ArgumentRow
								key={`${input.type}-${input.name ?? i}`}
								input={input}
								value={args[i]}
							/>
						))}
					</div>
				)}
			</div>
			<button
				type="button"
				onClick={() => setShowRaw(!showRaw)}
				className="text-[11px] text-accent hover:underline text-left cursor-pointer press-down"
			>
				{showRaw ? 'Hide' : 'Show'} raw
			</button>
			{showRaw && (
				<div className="bg-distinct rounded-[6px] overflow-hidden">
					<div className="relative px-[10px] py-[8px]">
						<pre className="text-[12px] text-primary break-all whitespace-pre-wrap font-mono max-h-[300px] overflow-auto pr-[40px]">
							{data}
						</pre>
						<div className="absolute top-[8px] right-[10px] flex items-center gap-[4px] text-tertiary bg-distinct pl-[8px]">
							{copyRaw.notifying && (
								<span className="text-[11px] select-none">copied</span>
							)}
							<button
								type="button"
								className="press-down cursor-pointer hover:text-secondary p-[4px]"
								onClick={() => copyRaw.copy(data)}
								title="Copy raw data"
							>
								<CopyIcon className="size-[14px]" />
							</button>
						</div>
					</div>
				</div>
			)}
		</div>
	)
}

export namespace TxDecodedCalldata {
	export interface Props {
		address?: Address | null
		data: Hex
	}

	export function ArgumentRow(props: ArgumentRow.Props) {
		const { input, value } = props
		const { copy, notifying } = useCopy()
		const formattedValue = formatAbiValue(value)

		return (
			<button
				type="button"
				onClick={() => copy(formattedValue)}
				className="flex items-start gap-[12px] px-[10px] py-[8px] text-[12px] font-mono w-full text-left cursor-pointer press-down hover:bg-base-alt/50 transition-colors"
			>
				<span className="text-secondary shrink-0 min-w-[120px]">
					{notifying ? (
						<span className="text-primary">copied</span>
					) : (
						<>
							{input.type}
							{input.name && (
								<span className="text-primary"> {input.name}</span>
							)}
						</>
					)}
				</span>
				<span className="text-primary break-all">{formattedValue}</span>
			</button>
		)
	}

	export namespace ArgumentRow {
		export interface Props {
			input: { type: string; name?: string }
			value: unknown
		}
	}
}

```

## File: apps/explorer/src/comps/TxDecodedTopics.tsx
```
import type { AbiEvent } from 'abitype'
import { useMemo, useState } from 'react'
import {
	type Abi,
	decodeEventLog,
	getAbiItem,
	type Hex,
	type Log,
	parseAbiItem,
} from 'viem'
import {
	decodeEventLog_guessed,
	formatAbiValue,
	useAutoloadAbi,
	useLookupSignature,
} from '#lib/abi'
import { useCopy } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

export function TxDecodedTopics(props: TxDecodedTopics.Props) {
	const { log } = props
	const eventSelector = log.topics[0]

	const { data: autoloadAbi } = useAutoloadAbi({
		address: log.address,
		enabled: Boolean(eventSelector),
	})

	const { data: signature, isFetched } = useLookupSignature({
		selector: eventSelector,
	})

	const autoloadAbiItem = useMemo(() => {
		if (!autoloadAbi || !eventSelector) return undefined
		return getAbiItem({
			abi: autoloadAbi as unknown as Abi,
			name: eventSelector,
		}) as AbiEvent | undefined
	}, [autoloadAbi, eventSelector])

	const signatureAbiItem = useMemo(() => {
		if (!signature) return undefined
		try {
			return parseAbiItem(`event ${signature}`) as AbiEvent
		} catch {
			return undefined
		}
	}, [signature])

	const abiItem = autoloadAbiItem ?? signatureAbiItem

	const decoded = useMemo(() => {
		if (!abiItem) return undefined

		try {
			return decodeEventLog({
				abi: [abiItem],
				topics: log.topics as [Hex, ...Hex[]],
				data: log.data,
			})
		} catch {
			// If decoding with given indexed parameters fails, try to guess the
			// positions of the indexed parameters
			return decodeEventLog_guessed({
				abiItem,
				topics: log.topics,
				data: log.data,
			})
		}
	}, [abiItem, log.topics, log.data])

	if (!isFetched) return <TxDecodedTopics.RawTopics log={log} />
	if (!abiItem) return <TxDecodedTopics.RawTopics log={log} />

	return (
		<div className="flex flex-col gap-[8px] w-full min-w-0 max-w-full overflow-hidden">
			<div className="bg-distinct rounded-[6px] overflow-hidden w-full min-w-0">
				<TxDecodedTopics.SignatureHeader abiItem={abiItem} />
				<TxDecodedTopics.ArgumentsSection
					abiItem={abiItem}
					args={decoded?.args}
					log={log}
				/>
			</div>
		</div>
	)
}

export namespace TxDecodedTopics {
	export interface Props {
		log: Log
	}

	export function SignatureHeader(props: SignatureHeader.Props) {
		const { abiItem } = props
		const { copy, notifying } = useCopy()

		const signatureText = useMemo(
			() =>
				`${abiItem.name}(${abiItem.inputs
					.map(
						(input, i) =>
							`${
								input.indexed ? `index_topic_${i + 1} ` : ''
							}${input.type}${input.name ? ` ${input.name}` : ''}`,
					)
					.join(', ')})`,
			[abiItem],
		)

		return (
			<div className="flex items-start justify-between px-[10px] py-[8px] border-b border-card-border gap-[8px]">
				<code className="text-[11px] text-primary font-mono break-all">
					<span className="text-tertiary">Name </span>
					<span className="text-base-content-positive">{abiItem.name}</span>
					<span className="text-secondary"> (</span>
					{abiItem.inputs.map((input, i) => (
						<span key={`${input.type}-${input.name ?? i}`}>
							{i > 0 && <span className="text-secondary">, </span>}
							{input.indexed && (
								<span className="text-tertiary">index_topic_{i + 1} </span>
							)}
							<span className="text-secondary">{input.type}</span>
							{input.name && (
								<span className="text-primary"> {input.name}</span>
							)}
						</span>
					))}
					<span className="text-secondary">)</span>
				</code>
				<div className="flex items-center gap-[4px] text-tertiary shrink-0">
					{notifying && <span className="text-[11px] select-none">copied</span>}
					<button
						type="button"
						className="press-down cursor-pointer hover:text-secondary p-[4px]"
						onClick={() => copy(signatureText)}
						title="Copy signature"
					>
						<CopyIcon className="size-[14px]" />
					</button>
				</div>
			</div>
		)
	}
	export namespace SignatureHeader {
		export interface Props {
			abiItem: AbiEvent
		}
	}

	export function ArgumentsSection(props: ArgumentsSection.Props) {
		const { abiItem, args, log } = props
		const [showRaw, setShowRaw] = useState(false)

		if (!args || abiItem.inputs.length === 0) return null

		return (
			<div className="px-[10px] py-[8px]">
				<div className="text-[11px] text-tertiary mb-[6px]">
					Arguments{' '}
					<button
						type="button"
						onClick={() => setShowRaw(!showRaw)}
						className="text-accent hover:underline cursor-pointer press-down"
					>
						({showRaw ? 'raw' : 'decoded'})
					</button>
				</div>
				{showRaw ? (
					<div className="flex flex-col gap-[8px]">
						<div className="flex flex-col gap-[4px]">
							{log.topics.map((topic, i) => (
								<RawTopicRow key={topic} index={i} topic={topic} />
							))}
						</div>
						{log.data && log.data !== '0x' && <RawDataInline data={log.data} />}
					</div>
				) : (
					<div className="flex flex-col gap-[4px]">
						{abiItem.inputs.map((input, index) => {
							const argValue =
								(args as Record<string, unknown>)[input.name ?? ''] ??
								(args as readonly unknown[])[index]

							return (
								<ArgumentRow
									key={input.name ?? index}
									input={input}
									value={argValue}
								/>
							)
						})}
					</div>
				)}
			</div>
		)
	}
	export namespace ArgumentsSection {
		export interface Props {
			abiItem: AbiEvent
			args?: Record<string, unknown> | readonly unknown[]
			log: Log
		}
	}

	export function ArgumentRow(props: ArgumentRow.Props) {
		const { input, value } = props
		const { copy, notifying } = useCopy()

		const displayValue = value !== undefined ? formatAbiValue(value) : ''
		const label = input.name || input.type

		return (
			<button
				type="button"
				onClick={() => copy(displayValue)}
				className="flex items-start gap-[8px] text-left cursor-pointer press-down hover:bg-base-alt/50 rounded-[4px] px-[4px] py-[2px] -mx-[4px] w-full"
			>
				<span className="text-[11px] text-tertiary shrink-0">
					{notifying ? (
						<span className="text-primary">copied</span>
					) : (
						<>{label}:</>
					)}
				</span>
				<span className="text-[11px] text-primary font-mono break-all min-w-0">
					{displayValue}
				</span>
			</button>
		)
	}
	export namespace ArgumentRow {
		export interface Props {
			input: AbiEvent['inputs'][number]
			value?: unknown
		}
	}

	export function RawDataInline(props: RawDataInline.Props) {
		const { data } = props
		const { copy, notifying } = useCopy()

		return (
			<div>
				<div className="text-[11px] text-tertiary mb-[4px]">
					{notifying ? <span className="text-primary">copied</span> : 'Data'}
				</div>
				<button
					type="button"
					onClick={() => copy(data)}
					className="w-full text-left cursor-pointer press-down hover:bg-base-alt/50 rounded-[4px] px-[4px] py-[2px] -mx-[4px] min-w-0 max-w-full"
				>
					<span className="text-[11px] text-primary font-mono break-all block [overflow-wrap:anywhere] min-w-0">
						{data}
					</span>
				</button>
			</div>
		)
	}
	export namespace RawDataInline {
		export interface Props {
			data: Hex
		}
	}

	export function RawTopics(props: RawTopics.Props) {
		const { log } = props

		return (
			<div className="flex flex-col gap-[8px] w-full min-w-0 max-w-full overflow-hidden">
				<div className="bg-distinct rounded-[6px] overflow-hidden w-full min-w-0">
					<div className="px-[10px] py-[8px] border-b border-card-border">
						<span className="text-[11px] text-tertiary">Raw event</span>
					</div>
					<div className="divide-y divide-card-border">
						<div className="px-[10px] py-[8px] min-w-0">
							<div className="text-[11px] text-tertiary mb-[6px]">Topics</div>
							<div className="flex flex-col gap-[4px]">
								{log.topics.map((topic, i) => (
									<RawTopicRow key={topic} index={i} topic={topic} />
								))}
							</div>
						</div>
						{log.data && log.data !== '0x' && (
							<RawDataSection data={log.data} />
						)}
					</div>
				</div>
			</div>
		)
	}
	export namespace RawTopics {
		export interface Props {
			log: Log
		}
	}

	export function RawTopicRow(props: RawTopicRow.Props) {
		const { index, topic } = props
		const { copy, notifying } = useCopy()

		return (
			<button
				type="button"
				onClick={() => copy(topic)}
				className="flex items-start gap-[8px] text-left cursor-pointer press-down hover:bg-base-alt/50 rounded-[4px] px-[4px] py-[2px] -mx-[4px]"
			>
				<span className="text-[11px] text-tertiary shrink-0">
					{notifying ? (
						<span className="text-primary">copied</span>
					) : (
						`topic[${index}]`
					)}
				</span>
				<span className="text-[11px] text-primary font-mono break-all min-w-0">
					{topic}
				</span>
			</button>
		)
	}
	export namespace RawTopicRow {
		export interface Props {
			index: number
			topic: Hex
		}
	}

	export function RawDataSection(props: RawDataSection.Props) {
		const { data } = props
		const { copy, notifying } = useCopy()

		return (
			<div className="px-[10px] py-[8px] min-w-0">
				<div className="text-[11px] text-tertiary mb-[6px]">
					{notifying ? <span className="text-primary">copied</span> : 'Data'}
				</div>
				<button
					type="button"
					onClick={() => copy(data)}
					className="w-full text-left cursor-pointer press-down hover:bg-base-alt/50 rounded-[4px] px-[4px] py-[2px] -mx-[4px] min-w-0 max-w-full"
				>
					<span className="text-[11px] text-primary font-mono break-all block [overflow-wrap:anywhere] min-w-0">
						{data}
					</span>
				</button>
			</div>
		)
	}
	export namespace RawDataSection {
		export interface Props {
			data: Hex
		}
	}
}

```

## File: apps/explorer/src/comps/TxEventDescription.tsx
```
import { Link } from '@tanstack/react-router'
import { type Address as AddressType, Value } from 'ox'
import * as React from 'react'
import { isAddressEqual } from 'viem'
import { Address } from '#comps/Address'
import { Amount } from '#comps/Amount'
import { cx } from '#cva.config.ts'
import type { KnownEvent, KnownEventPart } from '#lib/domain/known-events.ts'
import { DateFormatter, HexFormatter, PriceFormatter } from '#lib/formatting.ts'

export function TxEventDescription(props: TxEventDescription.Props) {
	const { event, seenAs, className } = props
	return (
		<div
			className={cx(
				'flex flex-row items-center gap-[6px] leading-[18px] flex-wrap',
				className,
			)}
		>
			{event.parts.map((part, index) => (
				<TxEventDescription.Part
					key={`${part.type}${index}`}
					part={part}
					seenAs={seenAs}
				/>
			))}
		</div>
	)
}

export namespace TxEventDescription {
	export interface Props {
		event: KnownEvent
		seenAs?: AddressType.Address
		className?: string | undefined
	}

	export function Part(props: Part.Props) {
		const { part, seenAs } = props
		switch (part.type) {
			case 'account':
				return (
					<Address
						address={part.value}
						className="text-accent items-end press-down whitespace-nowrap"
						self={seenAs ? isAddressEqual(part.value, seenAs) : false}
					/>
				)
			case 'action':
				return (
					<span className="inline-flex items-center h-[24px] px-[5px] bg-base-alt text-base-content capitalize">
						{part.value}
					</span>
				)
			case 'amount':
				return <Amount {...part.value} />
			case 'duration':
				return <span>{DateFormatter.formatDuration(part.value)}</span>
			case 'hex':
				return (
					<span className="items-end whitespace-nowrap" title={part.value}>
						{HexFormatter.shortenHex(part.value)}
					</span>
				)
			case 'number':
				return (
					<span className="items-end">
						{PriceFormatter.formatAmount(
							Array.isArray(part.value)
								? Value.format(...part.value)
								: Value.format(BigInt(part.value)),
						)}
					</span>
				)
			case 'text':
				return <span>{part.value}</span>
			case 'tick':
				return <span className="items-end">{part.value}</span>
			case 'token':
				return (
					<Link
						to="/token/$address"
						params={{ address: part.value.address }}
						title={part.value.address}
						className="press-down whitespace-nowrap"
					>
						<span className="text-base-content-positive items-end">
							{part.value.symbol || HexFormatter.shortenHex(part.value.address)}
						</span>
					</Link>
				)
			default:
				return null
		}
	}

	export namespace Part {
		export interface Props {
			part: KnownEventPart
			seenAs?: AddressType.Address
		}
	}

	export function ExpandGroup(props: ExpandGroup.Props) {
		const {
			events,
			seenAs,
			transformEvent,
			emptyContent = '…',
			limit = 1,
			limitFilter,
		} = props
		const [expanded, setExpanded] = React.useState(false)

		if (!events || events.length === 0) {
			return (
				<div className="text-tertiary flex items-center">
					<span className="inline-block">{emptyContent}</span>
				</div>
			)
		}

		let eventsToShow = events
		if (!expanded) {
			let filtered = limitFilter ? events.filter(limitFilter) : events
			if (filtered.length === 0) filtered = events
			eventsToShow = filtered.slice(0, limit)
		}
		const remainingCount = events.length - eventsToShow.length
		const displayEvents = transformEvent
			? eventsToShow.map(transformEvent)
			: eventsToShow

		return (
			<div className="flex flex-col gap-[4px]">
				{displayEvents.map((event, index) => (
					<div
						key={`${event.type}-${index}`}
						className="inline-flex items-center gap-[6px] flex-wrap"
					>
						<TxEventDescription
							event={event}
							seenAs={seenAs}
							className="flex flex-row items-center gap-[6px]"
						/>
						{index === displayEvents.length - 1 && remainingCount > 0 && (
							<button
								type="button"
								onClick={() => setExpanded(true)}
								className="text-base-content-secondary cursor-pointer press-down shrink-0"
							>
								and {remainingCount} more
							</button>
						)}
					</div>
				))}
			</div>
		)
	}

	export namespace ExpandGroup {
		export interface Props {
			events: KnownEvent[]
			seenAs?: AddressType.Address
			transformEvent?: (event: KnownEvent) => KnownEvent
			emptyContent?: React.ReactNode
			limit?: number
			limitFilter?: (event: KnownEvent) => boolean
		}
	}
}

```

## File: apps/explorer/src/comps/TxRawTransaction.tsx
```
import { Json } from 'ox'
import { useMemo } from 'react'
import * as z from 'zod/mini'
import { useCopy } from '#lib/hooks'

export function TxRawTransaction(props: TxRawTransaction.Props) {
	const { data } = props
	const parsed = useMemo(() => {
		try {
			return TxRawTransaction.TxDataSchema.safeParse(Json.parse(data))
		} catch {
			return { success: false } as const
		}
	}, [data])

	const maxKeyLength = useMemo(() => {
		if (!parsed.success) return 0
		const txMax = TxRawTransaction.getMaxKeyLength(parsed.data.tx)
		const receiptMax = TxRawTransaction.getMaxKeyLength(parsed.data.receipt)
		return Math.max(txMax, receiptMax)
	}, [parsed])

	if (!parsed.success) return <pre className="whitespace-pre-wrap">{data}</pre>

	return (
		<div className="font-mono flex flex-col gap-[32px]">
			<TxRawTransaction.Section
				title="TX"
				data={parsed.data.tx}
				maxKeyLength={maxKeyLength}
			/>
			<TxRawTransaction.Section
				title="RECEIPT"
				data={parsed.data.receipt}
				maxKeyLength={maxKeyLength}
			/>
		</div>
	)
}

export namespace TxRawTransaction {
	export interface Props {
		data: string
	}

	export const TxDataSchema = z.object({
		receipt: z.record(z.string(), z.unknown()),
		tx: z.record(z.string(), z.unknown()),
	})

	export function formatValue(value: unknown): string {
		if (value === null || value === undefined) return ''
		return typeof value === 'object' ? stringify(value) : String(value)
	}

	export function getMaxKeyLength(data: Record<string, unknown>): number {
		let max = 0
		for (const [key, value] of Object.entries(data)) {
			max = Math.max(max, key.length)
			if (typeof value === 'object' && value !== null && !Array.isArray(value))
				max = Math.max(max, getMaxKeyLength(value as Record<string, unknown>))
			else if (Array.isArray(value))
				for (const item of value)
					if (typeof item === 'object' && item !== null && !Array.isArray(item))
						max = Math.max(
							max,
							getMaxKeyLength(item as Record<string, unknown>),
						)
		}
		return max
	}

	export function Section(props: Section.Props) {
		const { title, data, maxKeyLength } = props
		const entries = Object.entries(data).sort(([a], [b]) => a.localeCompare(b))

		return (
			<div className="flex flex-col">
				<div className="text-primary uppercase mb-[4px]">{title}</div>
				<div className="flex flex-col">
					{entries.map(([key, value]) => (
						<Row
							depth={0}
							key={key}
							label={key}
							pad={maxKeyLength}
							value={value}
						/>
					))}
				</div>
			</div>
		)
	}

	export namespace Section {
		export interface Props {
			title: string
			data: Record<string, unknown>
			maxKeyLength: number
		}
	}

	export function Row(props: Row.Props) {
		const { label, value, pad = 21, depth = 0 } = props

		const { copy, notifying } = useCopy()

		const isArray = Array.isArray(value)
		const isFilledArray = isArray && value.length > 0
		const isObject =
			typeof value === 'object' && value !== null && !Array.isArray(value)
		const indent = depth * 8

		if (isFilledArray)
			return (
				<div className="flex flex-col">
					<button
						className="text-tertiary press-down cursor-pointer text-left"
						onClick={() => copy(stringify(value))}
						style={{
							paddingLeft: `${indent}px`,
							width: `${pad}ch`,
						}}
						type="button"
					>
						{notifying ? <span className="text-primary">copied</span> : label}
					</button>
					{value.map((item, index) => (
						<ArrayItem
							key={`${index}${item}`}
							index={index}
							value={item}
							pad={pad}
							depth={depth + 1}
						/>
					))}
				</div>
			)

		if (isObject) {
			const entries = Object.entries(value as Record<string, unknown>).sort(
				([a], [b]) => a.localeCompare(b),
			)
			return (
				<div className="flex flex-col">
					<button
						className="text-tertiary press-down cursor-pointer text-left"
						onClick={() => copy(stringify(value))}
						style={{
							paddingLeft: `${indent}px`,
							width: `${pad}ch`,
						}}
						type="button"
					>
						{notifying ? <span className="text-primary">copied</span> : label}
					</button>
					{entries.map(([key, val]) => (
						<Row
							key={key}
							label={key}
							value={val}
							pad={pad}
							depth={depth + 1}
						/>
					))}
				</div>
			)
		}

		return (
			<div className="flex gap-[16px]">
				<button
					className="flex items-start press-down cursor-pointer text-left"
					type="button"
					onClick={() => copy(TxRawTransaction.formatValue(value))}
					style={{
						paddingLeft: `${indent}px`,
						minWidth: `${pad}ch`,
					}}
				>
					<span className="text-tertiary shrink-0">
						{notifying ? <span className="text-primary">copied</span> : label}
					</span>
				</button>
				<button
					className="flex items-start press-down cursor-pointer text-left"
					type="button"
					onClick={() => copy(TxRawTransaction.formatValue(value))}
				>
					<span>{TxRawTransaction.formatValue(value)}</span>
				</button>
			</div>
		)
	}

	export namespace Row {
		export interface Props {
			label: string
			value: unknown
			pad?: number
			depth?: number
		}
	}

	export function ArrayItem(props: ArrayItem.Props) {
		const { index, value, pad = 21, depth = 0 } = props

		const { copy, notifying } = useCopy()

		const isObject =
			typeof value === 'object' && value !== null && !Array.isArray(value)
		const indent = depth * 8

		if (isObject) {
			const entries = Object.entries(value as Record<string, unknown>).sort(
				([a], [b]) => a.localeCompare(b),
			)
			return (
				<div className="flex flex-col">
					<div
						className="text-tertiary"
						style={{
							paddingLeft: `${indent}px`,
							width: `${pad}ch`,
						}}
					>
						[{index}]
					</div>
					{entries.map(([key, val]) => (
						<Row
							key={key}
							label={key}
							value={val}
							pad={pad}
							depth={depth + 1}
						/>
					))}
				</div>
			)
		}

		return (
			<div className="flex gap-[16px]">
				<button
					className="text-tertiary text-left"
					onClick={() => copy(TxRawTransaction.formatValue(value))}
					style={{
						paddingLeft: `${indent}px`,
						width: `${pad}ch`,
					}}
					type="button"
				>
					{notifying ? (
						<span className="text-primary">copied</span>
					) : (
						`[${index}]`
					)}
				</button>
				<button
					className="press-down cursor-pointer text-left"
					type="button"
					onClick={() => copy(TxRawTransaction.formatValue(value))}
				>
					{TxRawTransaction.formatValue(value)}
				</button>
			</div>
		)
	}

	export namespace ArrayItem {
		export interface Props {
			index: number
			value: unknown
			pad?: number
			depth?: number
		}
	}
}

function stringify(value: unknown): string {
	return Json.stringify(value, (_, value) => {
		if (typeof value === 'bigint') return value.toString()
		return value
	})
}

```

## File: apps/explorer/src/comps/TxTransactionCard.tsx
```
import { Link } from '@tanstack/react-router'
import type { Address, Hex } from 'ox'
import { InfoCard } from '#comps/InfoCard'
import { ReceiptMark } from '#comps/ReceiptMark'
import { FormattedTimestamp } from '#comps/TimeFormat'
import { TruncatedHash } from '#comps/TruncatedHash'
import { cx } from '#cva.config.ts'
import { useCopy } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

export function TxTransactionCard(props: TxTransactionCard.Props) {
	const { hash, status, blockNumber, timestamp, from, to, className } = props
	const { copy, notifying } = useCopy()
	return (
		<InfoCard
			title={
				<div className="flex items-center justify-between px-[18px] pt-[10px] pb-[8px]">
					<h1 className="text-[13px] uppercase text-tertiary select-none">
						Transaction
					</h1>
					<StatusBadge status={status} />
				</div>
			}
			className={className}
			sections={[
				<button
					key="hash"
					type="button"
					onClick={() => copy(hash)}
					className="w-full text-left cursor-pointer press-down text-tertiary"
					title={hash}
				>
					<div className="flex items-center gap-[8px] mb-[8px]">
						<span className="text-[13px] font-normal capitalize">Hash</span>
						<div className="relative flex items-center">
							<CopyIcon className="w-[12px] h-[12px]" />
							{notifying && (
								<span className="absolute left-[calc(100%+8px)] text-[13px] leading-[16px]">
									copied
								</span>
							)}
						</div>
					</div>
					<p className="text-[14px] font-normal leading-[17px] tracking-[0.02em] text-primary break-all max-w-[23ch]">
						{hash}
					</p>
				</button>,
				{
					label: 'Block',
					value: (
						<Link
							to="/block/$id"
							params={{ id: String(blockNumber) }}
							className="text-[13px] text-accent hover:underline press-down"
						>
							{blockNumber}
						</Link>
					),
				},
				{
					label: 'Time',
					value: (
						<FormattedTimestamp
							timestamp={timestamp}
							format="relative"
							className="text-[13px] text-primary"
						/>
					),
				},
				{
					label: 'From',
					value: (
						<Link
							to="/address/$address"
							params={{ address: from }}
							className="text-[13px] text-accent hover:underline press-down"
							title={from}
						>
							<TruncatedHash hash={from} minChars={6} />
						</Link>
					),
				},
				to
					? {
							label: 'To',
							value: (
								<Link
									to="/address/$address"
									params={{ address: to }}
									className="text-[13px] text-accent hover:underline press-down"
									title={to}
								>
									<TruncatedHash hash={to} minChars={6} />
								</Link>
							),
						}
					: {
							label: 'To',
							value: (
								<span className="text-[13px] text-tertiary">
									Contract Creation
								</span>
							),
						},
				<Link
					key="receipt"
					to="/receipt/$hash"
					params={{ hash }}
					className="press-down flex items-end justify-between w-full"
				>
					<span className="text-[13px] text-tertiary">View</span>
					<ReceiptMark />
				</Link>,
			]}
		/>
	)
}

function StatusBadge(props: { status: 'success' | 'reverted' }) {
	const { status } = props
	const isSuccess = status === 'success'
	return (
		<span
			className={cx(
				'text-[11px] uppercase font-normal',
				isSuccess ? 'text-base-content-positive' : 'text-base-content-negative',
			)}
		>
			{isSuccess ? 'Success' : 'Failed'}
		</span>
	)
}

export declare namespace TxTransactionCard {
	type Props = {
		hash: Hex.Hex
		status: 'success' | 'reverted'
		blockNumber: bigint
		timestamp: bigint
		from: Address.Address
		to: Address.Address | null
		className?: string
	}
}

```

## File: apps/explorer/src/comps/TxTransactionRow.tsx
```
import { Link } from '@tanstack/react-router'
import { Address, Hex, Value } from 'ox'
import * as React from 'react'
import type { RpcTransaction as Transaction, TransactionReceipt } from 'viem'
import type { getBlock } from 'wagmi/actions'
import { FormattedTimestamp, type TimeFormat } from '#comps/TimeFormat'
import { TxEventDescription } from '#comps/TxEventDescription'
import {
	type KnownEvent,
	type KnownEventPart,
	preferredEventsFilter,
} from '#lib/domain/known-events'
import { PriceFormatter } from '#lib/formatting'

export type TransactionData = {
	receipt: TransactionReceipt
	block: Awaited<ReturnType<typeof getBlock>>
	knownEvents: KnownEvent[]
}

type BatchTransactionDataContextValue = {
	transactionDataMap: Map<Hex.Hex, TransactionData>
	isLoading: boolean
}

export const BatchTransactionDataContext =
	React.createContext<BatchTransactionDataContextValue>({
		transactionDataMap: new Map(),
		isLoading: true,
	})

export function useTransactionDataFromBatch(hash: Hex.Hex) {
	return React.useContext(BatchTransactionDataContext).transactionDataMap.get(
		hash,
	)
}

export function TransactionFee(props: { receipt?: TransactionReceipt }) {
	const { receipt } = props

	if (!receipt) return <span className="text-tertiary">…</span>

	const fee = Number(
		Value.format(receipt.effectiveGasPrice * receipt.gasUsed, 18),
	)

	return <span className="text-tertiary">{PriceFormatter.format(fee)}</span>
}

export function TransactionDescription(props: {
	transaction: Transaction
	knownEvents: Array<KnownEvent>
	transactionReceipt: TransactionReceipt | undefined
	accountAddress: Address.Address
}) {
	const { knownEvents, accountAddress } = props

	const transformEvent = React.useCallback(
		(event: KnownEvent) => getPerspectiveEvent(event, accountAddress),
		[accountAddress],
	)

	return (
		<TxEventDescription.ExpandGroup
			events={knownEvents}
			seenAs={accountAddress}
			transformEvent={transformEvent}
			limitFilter={preferredEventsFilter}
		/>
	)
}

export function getPerspectiveEvent(
	event: KnownEvent,
	accountAddress?: Address.Address,
) {
	if (!accountAddress) return event
	if (event.type !== 'send') return event
	const toMatches =
		event.meta?.to && Address.isEqual(event.meta.to, accountAddress)
	const fromMatches =
		event.meta?.from && Address.isEqual(event.meta.from, accountAddress)
	if (!toMatches || fromMatches) return event

	const sender = event.meta?.from
	const updatedParts = event.parts.map((part) => {
		if (part.type === 'action') return { ...part, value: 'Received' }
		if (part.type === 'text' && part.value.toLowerCase() === 'to')
			return { ...part, value: 'from' }
		if (part.type === 'account' && sender) return { ...part, value: sender }
		return part
	})
	return { ...event, parts: updatedParts }
}

export function TransactionTimestamp(props: {
	timestamp: bigint
	link?: string
	format?: TimeFormat
}) {
	const { timestamp, link, format = 'relative' } = props

	return (
		<div className="text-nowrap">
			{link ? (
				<Link to={link} className="text-tertiary">
					<FormattedTimestamp timestamp={timestamp} format={format} />
				</Link>
			) : (
				<FormattedTimestamp
					timestamp={timestamp}
					format={format}
					className="text-tertiary"
				/>
			)}
		</div>
	)
}

export function TransactionTotal(props: { transaction: Transaction }) {
	const { transaction } = props
	const batchData = useTransactionDataFromBatch(transaction.hash)

	const amountParts = React.useMemo(() => {
		if (!batchData) return

		return batchData.knownEvents.flatMap((event) =>
			event.parts.filter(
				(part): part is Extract<KnownEventPart, { type: 'amount' }> =>
					part.type === 'amount',
			),
		)
	}, [batchData])
	if (!amountParts?.length) return <>$0.00</>

	const totalValue = amountParts.reduce((sum, part) => {
		const decimals = part.value.decimals ?? 6
		return sum + Number(Value.format(part.value.value, decimals))
	}, 0)

	if (totalValue === 0) {
		const value = transaction.value ? Hex.toBigInt(transaction.value) : 0n
		if (value === 0n) return <span className="text-tertiary">—</span>
		return (
			<span className="text-primary">
				{PriceFormatter.format(value, { decimals: 18, format: 'short' })}
			</span>
		)
	}

	return (
		<span className="text-primary">{PriceFormatter.format(totalValue)}</span>
	)
}

```

## File: apps/explorer/src/cva.config.ts
```
import { defineConfig } from 'cva'
import { twMerge } from 'tailwind-merge'

export const { cva, cx, compose } = defineConfig({
	hooks: {
		onComplete: (className) => twMerge(className),
	},
})

```

## File: apps/explorer/src/data/tokens-index.json
```
[
	["0x20c0000000000000000000000000000000000000","pathUSD","pathUSD"],
	["0x20c0000000000000000000000000000000000001","AlphaUSD","AlphaUSD"],
	["0x20c0000000000000000000000000000000000002","BetaUSD","BetaUSD"],
	["0x20c0000000000000000000000000000000000003","ThetaUSD","ThetaUSD"],
	["0x20c000000000000000000000000000000000050e","TEST","testUSD"],
	["0x20c000000000000000000000000000000000050d","DAN","DanUSD"],
	["0x20c000000000000000000000000000000000050c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000050b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000050a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000509","gUSD","gg123USD"],
	["0x20c0000000000000000000000000000000000508","gUSD","gg123USD"],
	["0x20c0000000000000000000000000000000000507","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000506","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000505","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000504","gUSD","ggUSD"],
	["0x20c0000000000000000000000000000000000503","ggUSD","georgeUSD"],
	["0x20c0000000000000000000000000000000000502","myTestUSD","myTestUsd"],
	["0x20c0000000000000000000000000000000000501","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000500","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ff","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004fe","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004fd","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004fc","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004fb","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004fa","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004f9","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004f8","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004f7","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004f6","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004f5","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004f4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004f3","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004f2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004f1","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004f0","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004ef","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004ee","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004ed","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004ec","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004eb","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004ea","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004e9","TEST","testUSD"],
	["0x20c00000000000000000000000000000000004e8","DAN","danUSD"],
	["0x20c00000000000000000000000000000000004e7","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004e6","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004e5","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004e4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004e3","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004e2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004e1","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004e0","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004df","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004de","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004dd","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004dc","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004db","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004da","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d9","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004d8","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d7","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004d6","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d5","TEST4","Test Token 4"],
	["0x20c00000000000000000000000000000000004d4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d3","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004d1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004d0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004cf","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ce","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004cd","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004cc","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004cb","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ca","STEVE","stevenUSD"],
	["0x20c00000000000000000000000000000000004c9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004c8","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004c7","TEST","testUSD"],
	["0x20c00000000000000000000000000000000004c6","FOO","fooUSD"],
	["0x20c00000000000000000000000000000000004c5","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000004c4","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000004c3","TEST","testUSD"],
	["0x20c00000000000000000000000000000000004c2","TEST","testUSD"],
	["0x20c00000000000000000000000000000000004c1","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000004c0","DEMO","DEMO"],
	["0x20c00000000000000000000000000000000004bf","DEMO","DEMO"],
	["0x20c00000000000000000000000000000000004be","test","ziggy"],
	["0x20c00000000000000000000000000000000004bd","test","ziggy"],
	["0x20c00000000000000000000000000000000004bc","test","ziggy"],
	["0x20c00000000000000000000000000000000004bb","test","ziggy"],
	["0x20c00000000000000000000000000000000004ba","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b8","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b7","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b5","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b4","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b3","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b2","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004b0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004af","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ae","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ad","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ac","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004ab","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004aa","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004a9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004a8","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004a7","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004a6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000004a5","asd","asd"],
	["0x20c00000000000000000000000000000000004a4","asd","asd"],
	["0x20c00000000000000000000000000000000004a3","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004a2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004a1","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000004a0","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000049f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000049e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000049d","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000049c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000049b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000049a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000499","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000497","TEST","Test"],
	["0x20c0000000000000000000000000000000000498","TEST","Test"],
	["0x20c0000000000000000000000000000000000496","TEST","Test"],
	["0x20c0000000000000000000000000000000000495","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000494","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000492","TEST","Test"],
	["0x20c0000000000000000000000000000000000493","TEST","Test"],
	["0x20c0000000000000000000000000000000000491","TEST","Test"],
	["0x20c0000000000000000000000000000000000490","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000048a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000489","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000488","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000487","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000486","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000485","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000484","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000483","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000482","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000481","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000047f","TEST","Test"],
	["0x20c0000000000000000000000000000000000480","TEST","Test"],
	["0x20c000000000000000000000000000000000047e","TEST","Test"],
	["0x20c000000000000000000000000000000000047c","TEST","Test"],
	["0x20c000000000000000000000000000000000047d","TEST","Test"],
	["0x20c000000000000000000000000000000000047b","TEST","Test"],
	["0x20c0000000000000000000000000000000000479","TEST","Test"],
	["0x20c000000000000000000000000000000000047a","TEST","Test"],
	["0x20c0000000000000000000000000000000000478","TEST","Test"],
	["0x20c0000000000000000000000000000000000476","TEST","Test"],
	["0x20c0000000000000000000000000000000000477","TEST","Test"],
	["0x20c0000000000000000000000000000000000475","TEST","Test"],
	["0x20c0000000000000000000000000000000000473","TEST","Test"],
	["0x20c0000000000000000000000000000000000474","TEST","Test"],
	["0x20c0000000000000000000000000000000000472","TEST","Test"],
	["0x20c0000000000000000000000000000000000470","TEST","Test"],
	["0x20c0000000000000000000000000000000000471","TEST","Test"],
	["0x20c000000000000000000000000000000000046f","TEST","Test"],
	["0x20c000000000000000000000000000000000046e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000046d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000046c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000046b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000046a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000469","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000468","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000467","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000466","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000465","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000464","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000463","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000462","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000461","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000460","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000045a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000459","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000458","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000457","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000456","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000455","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000454","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000453","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000452","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000451","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000450","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000044a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000449","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000448","ACMEUSD","ACME USD"],
	["0x20c0000000000000000000000000000000000447","ACMEUSD","ACME USD"],
	["0x20c0000000000000000000000000000000000446","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000445","ACMEUSD","ACME USD"],
	["0x20c0000000000000000000000000000000000444","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000443","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000442","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000441","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000440","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000043a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000439","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000438","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000437","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000436","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000435","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000434","acmeUSD","Acme USD"],
	["0x20c0000000000000000000000000000000000433","AcmeUSD","AcmeUSD"],
	["0x20c0000000000000000000000000000000000432","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000431","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000430","acmeUSD","Acme USD"],
	["0x20c000000000000000000000000000000000042f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000042e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000042d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000042c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000042b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000042a","TEST","Test"],
	["0x20c0000000000000000000000000000000000429","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000428","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000427","AUSD","AcmeUSD"],
	["0x20c0000000000000000000000000000000000426","AUSD","AcmeUSD"],
	["0x20c0000000000000000000000000000000000425","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000424","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000423","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000422","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000421","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000420","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000041f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000041e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000041d","AUSD","AcmeUSD"],
	["0x20c000000000000000000000000000000000041c","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000041b","DEMO","Example"],
	["0x20c000000000000000000000000000000000041a","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000419","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000418","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000417","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000416","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000415","BUSD","Acme USD"],
	["0x20c0000000000000000000000000000000000413","TEST","Test"],
	["0x20c0000000000000000000000000000000000414","TEST","Test"],
	["0x20c0000000000000000000000000000000000412","TEST","Test"],
	["0x20c0000000000000000000000000000000000410","TEST","Test"],
	["0x20c0000000000000000000000000000000000411","TEST","Test"],
	["0x20c000000000000000000000000000000000040f","TEST","Test"],
	["0x20c000000000000000000000000000000000040e","AUSD","Acme USD"],
	["0x20c000000000000000000000000000000000040d","TEST","Test"],
	["0x20c000000000000000000000000000000000040c","TEST","Test"],
	["0x20c000000000000000000000000000000000040b","TEST","Test"],
	["0x20c000000000000000000000000000000000040a","TEST","Test"],
	["0x20c0000000000000000000000000000000000409","TEST","Test"],
	["0x20c0000000000000000000000000000000000408","TEST","Test"],
	["0x20c0000000000000000000000000000000000407","TEST","Test"],
	["0x20c0000000000000000000000000000000000406","TEST","Test"],
	["0x20c0000000000000000000000000000000000405","TEST","Test"],
	["0x20c0000000000000000000000000000000000404","TEST","Test"],
	["0x20c0000000000000000000000000000000000403","TEST","Test"],
	["0x20c0000000000000000000000000000000000402","TEST","Test"],
	["0x20c0000000000000000000000000000000000401","ACMEUSD","AcmeUSD"],
	["0x20c0000000000000000000000000000000000400","ACMEUSD","AcmeUSD"],
	["0x20c00000000000000000000000000000000003ff","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003fe","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003fd","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003fc","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003fb","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003fa","ACMEUSD","AcmeUSD"],
	["0x20c00000000000000000000000000000000003f9","ACMEUSD","AcmeUSD"],
	["0x20c00000000000000000000000000000000003f8","ACMEUSD","AcmeUSD"],
	["0x20c00000000000000000000000000000000003f7","TEST","Test"],
	["0x20c00000000000000000000000000000000003f6","TEST","Test"],
	["0x20c00000000000000000000000000000000003f5","TEST","Test"],
	["0x20c00000000000000000000000000000000003f4","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003f3","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003f2","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003f1","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003f0","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003ef","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003ee","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003ed","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003ec","dd","aa"],
	["0x20c00000000000000000000000000000000003eb","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003ea","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e9","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e8","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e7","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e6","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e5","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e4","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003e3","asd","asd"],
	["0x20c00000000000000000000000000000000003e2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003e1","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003e0","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003df","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003de","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000003dd","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003dc","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003db","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003da","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d9","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d8","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d7","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000003d5","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d3","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d1","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003d0","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003cf","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003ce","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000003cd","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003cc","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003cb","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003ca","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003c9","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003c8","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003c7","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003c6","TEST","testcoin"],
	["0x20c00000000000000000000000000000000003c5","39193","390390"],
	["0x20c00000000000000000000000000000000003c4","AUSD","Acme USD"],
	["0x20c00000000000000000000000000000000003c3","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003c2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000003c1","ACMEUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000003c0","ACMEUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000003bf","FDR","fffxxxUSSST"],
	["0x20c00000000000000000000000000000000003bd","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003be","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000003bc","BURN","Burnable Token"],
	["0x20c00000000000000000000000000000000003bb","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000003ba","TST","Test Token"],
	["0x20c00000000000000000000000000000000003b9","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003b7","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000003b8","BURN","Burnable Token"],
	["0x20c00000000000000000000000000000000003b6","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000003b5","TST","Test Token"],
	["0x20c00000000000000000000000000000000003b4","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003b3","BURN","Burnable Token"],
	["0x20c00000000000000000000000000000000003b2","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000003b1","TST","Test Token"],
	["0x20c00000000000000000000000000000000003b0","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000003af","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003ae","BURN","Burnable Token"],
	["0x20c00000000000000000000000000000000003ac","TST","Test Token"],
	["0x20c00000000000000000000000000000000003ad","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000003aa","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003ab","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000003a9","TST","Test Token"],
	["0x20c00000000000000000000000000000000003a7","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000003a8","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003a6","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000003a5","TST","Test Token"],
	["0x20c00000000000000000000000000000000003a4","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003a2","XFER","Transfer Token"],
	["0x20c00000000000000000000000000000000003a3","TST","Test Token"],
	["0x20c00000000000000000000000000000000003a1","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000039f","TEST","Test Token"],
	["0x20c00000000000000000000000000000000003a0","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000039e","TST","Test Token"],
	["0x20c000000000000000000000000000000000039d","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000039b","TEST","Test Token"],
	["0x20c000000000000000000000000000000000039c","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000039a","TST","Test Token"],
	["0x20c0000000000000000000000000000000000399","MINT","Mintable Token"],
	["0x20c0000000000000000000000000000000000398","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000397","TST","Test Token"],
	["0x20c0000000000000000000000000000000000396","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000394","MINT","Mintable Token"],
	["0x20c0000000000000000000000000000000000395","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000393","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000391","TST","Test Token"],
	["0x20c0000000000000000000000000000000000392","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000390","MINT","Mintable Token"],
	["0x20c000000000000000000000000000000000038f","TEST","Test Token"],
	["0x20c000000000000000000000000000000000038c","MINT","Mintable Token"],
	["0x20c000000000000000000000000000000000038d","TST","Test Token"],
	["0x20c000000000000000000000000000000000038e","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000038b","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000038a","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000389","TEST2","Test Token 2"],
	["0x20c0000000000000000000000000000000000388","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000387","TST","Test Token"],
	["0x20c0000000000000000000000000000000000386","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000385","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000384","TEST2","Test Token 2"],
	["0x20c0000000000000000000000000000000000383","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000382","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000380","TST","Test Token"],
	["0x20c0000000000000000000000000000000000381","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000037f","TUSD","Test USD"],
	["0x20c000000000000000000000000000000000037e","TEST2","Test Token 2"],
	["0x20c000000000000000000000000000000000037d","TUSD","Test USD"],
	["0x20c000000000000000000000000000000000037b","TUSD","Test USD"],
	["0x20c000000000000000000000000000000000037c","TST","Test Token"],
	["0x20c000000000000000000000000000000000037a","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000379","TEST2","Test Token 2"],
	["0x20c0000000000000000000000000000000000378","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000376","TST","Test Token"],
	["0x20c0000000000000000000000000000000000377","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000375","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000374","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000372","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000373","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000371","TUSD","Test USD"],
	["0x20c0000000000000000000000000000000000370","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000036f","TST","Test Token"],
	["0x20c000000000000000000000000000000000036e","TEST","Test Token"],
	["0x20c000000000000000000000000000000000036c","TST","Test Token"],
	["0x20c000000000000000000000000000000000036d","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000036b","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000036a","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000369","TST","Test Token"],
	["0x20c0000000000000000000000000000000000368","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000366","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000367","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000364","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000365","TST","Test Token"],
	["0x20c0000000000000000000000000000000000363","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000362","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000361","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000360","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000035f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000035e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000035d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000035c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000035b","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000035a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000359","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000358","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000357","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000356","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000355","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000354","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000353","fafoUSDT","fafoUSDT"],
	["0x20c0000000000000000000000000000000000352","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000351","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000350","ACMEUSD","Acme USD"],
	["0x20c000000000000000000000000000000000034f","ACMEUSD","Acme USD"],
	["0x20c000000000000000000000000000000000034e","ACMEUSD","Acme USD"],
	["0x20c000000000000000000000000000000000034d","ACMEUSD","AcmeUSD"],
	["0x20c000000000000000000000000000000000034c","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000034b","TEST","TEST"],
	["0x20c000000000000000000000000000000000034a","TEST","TEST"],
	["0x20c0000000000000000000000000000000000349","ACMEUSD","Acme USD"],
	["0x20c0000000000000000000000000000000000348","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000347","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000346","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000345","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000344","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000343","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000342","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000341","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000340","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000033f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000033e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000033d","TEST","TEST"],
	["0x20c000000000000000000000000000000000033c","ACMEUSD","AcmeUSD"],
	["0x20c000000000000000000000000000000000033b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000033a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000339","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000338","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000337","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000336","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000335","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000334","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000333","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000332","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000331","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000330","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000032f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000032e","PMAIN","Proposed Main Token"],
	["0x20c000000000000000000000000000000000032d","PLINK","Proposed Quote Token"],
	["0x20c000000000000000000000000000000000032c","PMAIN","Proposed Main Token"],
	["0x20c000000000000000000000000000000000032b","PLINK","Proposed Quote Token"],
	["0x20c000000000000000000000000000000000032a","PMAIN","Proposed Main Token"],
	["0x20c0000000000000000000000000000000000329","PLINK","Proposed Quote Token"],
	["0x20c0000000000000000000000000000000000328","PMAIN","Proposed Main Token"],
	["0x20c0000000000000000000000000000000000327","PLINK","Proposed Quote Token"],
	["0x20c0000000000000000000000000000000000326","WMAIN","Watch Main Token"],
	["0x20c0000000000000000000000000000000000325","WLINK","Watch Quote Token"],
	["0x20c0000000000000000000000000000000000324","WMAIN","Watch Main Token"],
	["0x20c0000000000000000000000000000000000323","WLINK","Watch Quote Token"],
	["0x20c0000000000000000000000000000000000322","WMAIN","Watch Main Token"],
	["0x20c0000000000000000000000000000000000321","WLINK","Watch Quote Token"],
	["0x20c0000000000000000000000000000000000320","WMAIN","Watch Main Token"],
	["0x20c000000000000000000000000000000000031f","WLINK","Watch Quote Token"],
	["0x20c000000000000000000000000000000000031e","FXFER","Filtered Transfer Token"],
	["0x20c000000000000000000000000000000000031d","FXFER","Filtered Transfer Token"],
	["0x20c000000000000000000000000000000000031c","FXFER","Filtered Transfer Token"],
	["0x20c000000000000000000000000000000000031b","FXFER","Filtered Transfer Token"],
	["0x20c000000000000000000000000000000000031a","XFER","Transfer Watch Token"],
	["0x20c0000000000000000000000000000000000319","XFER","Transfer Watch Token"],
	["0x20c0000000000000000000000000000000000318","XFER","Transfer Watch Token"],
	["0x20c0000000000000000000000000000000000317","XFER","Transfer Watch Token"],
	["0x20c0000000000000000000000000000000000316","FROLE","Filtered Role Token"],
	["0x20c0000000000000000000000000000000000315","FROLE","Filtered Role Token"],
	["0x20c0000000000000000000000000000000000314","FROLE","Filtered Role Token"],
	["0x20c0000000000000000000000000000000000313","FROLE","Filtered Role Token"],
	["0x20c0000000000000000000000000000000000312","ROLE","Role Watch Token"],
	["0x20c0000000000000000000000000000000000311","ROLE","Role Watch Token"],
	["0x20c0000000000000000000000000000000000310","ROLE","Role Watch Token"],
	["0x20c000000000000000000000000000000000030f","ROLE","Role Watch Token"],
	["0x20c000000000000000000000000000000000030e","ADMIN","Admin Role Watch Token"],
	["0x20c000000000000000000000000000000000030d","ADMIN","Admin Role Watch Token"],
	["0x20c000000000000000000000000000000000030c","ADMIN","Admin Role Watch Token"],
	["0x20c000000000000000000000000000000000030b","ADMIN","Admin Role Watch Token"],
	["0x20c000000000000000000000000000000000030a","FBURN","Filtered Burn Token"],
	["0x20c0000000000000000000000000000000000309","FBURN","Filtered Burn Token"],
	["0x20c0000000000000000000000000000000000308","FBURN","Filtered Burn Token"],
	["0x20c0000000000000000000000000000000000307","FBURN","Filtered Burn Token"],
	["0x20c0000000000000000000000000000000000306","BURN","Burn Watch Token"],
	["0x20c0000000000000000000000000000000000305","BURN","Burn Watch Token"],
	["0x20c0000000000000000000000000000000000304","BURN","Burn Watch Token"],
	["0x20c0000000000000000000000000000000000303","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000302","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000301","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000300","BURN","Burn Watch Token"],
	["0x20c00000000000000000000000000000000002ff","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002fe","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002fd","FAPPR","Filtered Approval Token"],
	["0x20c00000000000000000000000000000000002fc","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002fb","FAPPR","Filtered Approval Token"],
	["0x20c00000000000000000000000000000000002fa","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002f9","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002f8","FAPPR","Filtered Approval Token"],
	["0x20c00000000000000000000000000000000002f7","FAPPR","Filtered Approval Token"],
	["0x20c00000000000000000000000000000000002f6","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002f5","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002f4","APPR","Approval Watch Token"],
	["0x20c00000000000000000000000000000000002f2","APPR","Approval Watch Token"],
	["0x20c00000000000000000000000000000000002f3","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002f1","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002f0","APPR","Approval Watch Token"],
	["0x20c00000000000000000000000000000000002ee","APPR","Approval Watch Token"],
	["0x20c00000000000000000000000000000000002ef","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002ed","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002ec","FMINT","Filtered Mint Token"],
	["0x20c00000000000000000000000000000000002eb","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002ea","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002e9","FMINT","Filtered Mint Token"],
	["0x20c00000000000000000000000000000000002e7","FMINT","Filtered Mint Token"],
	["0x20c00000000000000000000000000000000002e8","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002e6","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002e5","FMINT","Filtered Mint Token"],
	["0x20c00000000000000000000000000000000002e4","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002e3","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002e2","MINT","Mint Watch Token"],
	["0x20c00000000000000000000000000000000002e1","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002e0","MINT","Mint Watch Token"],
	["0x20c00000000000000000000000000000000002df","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002de","MINT","Mint Watch Token"],
	["0x20c00000000000000000000000000000000002dd","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002dc","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002db","MINT","Mint Watch Token"],
	["0x20c00000000000000000000000000000000002da","FWATCH3","Filtered Watch Token 3"],
	["0x20c00000000000000000000000000000000002d9","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002d8","FWATCH2","Filtered Watch Token 2"],
	["0x20c00000000000000000000000000000000002d7","FWATCH1","Filtered Watch Token 1"],
	["0x20c00000000000000000000000000000000002d6","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002d5","SETUP","Setup Token"],
	["0x20c00000000000000000000000000000000002d4","FWATCH3","Filtered Watch Token 3"],
	["0x20c00000000000000000000000000000000002d3","FWATCH2","Filtered Watch Token 2"],
	["0x20c00000000000000000000000000000000002d2","FWATCH1","Filtered Watch Token 1"],
	["0x20c00000000000000000000000000000000002d0","SETUP","Setup Token"],
	["0x20c00000000000000000000000000000000002d1","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002cf","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002ce","FWATCH3","Filtered Watch Token 3"],
	["0x20c00000000000000000000000000000000002cd","FWATCH2","Filtered Watch Token 2"],
	["0x20c00000000000000000000000000000000002cc","FWATCH1","Filtered Watch Token 1"],
	["0x20c00000000000000000000000000000000002cb","SETUP","Setup Token"],
	["0x20c00000000000000000000000000000000002ca","FWATCH3","Filtered Watch Token 3"],
	["0x20c00000000000000000000000000000000002c9","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002c8","FWATCH2","Filtered Watch Token 2"],
	["0x20c00000000000000000000000000000000002c7","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002c6","FWATCH1","Filtered Watch Token 1"],
	["0x20c00000000000000000000000000000000002c5","SETUP","Setup Token"],
	["0x20c00000000000000000000000000000000002c4","WATCH2","Watch Test Token 2"],
	["0x20c00000000000000000000000000000000002c3","WATCH1","Watch Test Token 1"],
	["0x20c00000000000000000000000000000000002c2","WATCH2","Watch Test Token 2"],
	["0x20c00000000000000000000000000000000002c1","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002c0","WATCH1","Watch Test Token 1"],
	["0x20c00000000000000000000000000000000002be","WATCH2","Watch Test Token 2"],
	["0x20c00000000000000000000000000000000002bf","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002bd","WATCH1","Watch Test Token 1"],
	["0x20c00000000000000000000000000000000002bc","WATCH2","Watch Test Token 2"],
	["0x20c00000000000000000000000000000000002bb","WATCH1","Watch Test Token 1"],
	["0x20c00000000000000000000000000000000002ba","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002b9","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002b8","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000002b7","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002b6","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000002b5","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002b4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000002b3","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000002b2","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002b1","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002b0","TEST2","Test Token 2"],
	["0x20c00000000000000000000000000000000002ae","TEST2","Test Token 2"],
	["0x20c00000000000000000000000000000000002af","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002ad","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002ac","TEST2","Test Token 2"],
	["0x20c00000000000000000000000000000000002ab","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002aa","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002a9","TEST2","Test Token 2"],
	["0x20c00000000000000000000000000000000002a8","TEST","Test Token"],
	["0x20c00000000000000000000000000000000002a7","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002a5","TEST","Test Token"],
	["0x20c00000000000000000000000000000000002a6","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000002a4","TEST","Test Token"],
	["0x20c00000000000000000000000000000000002a2","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000002a3","TEST","Test Token"],
	["0x20c00000000000000000000000000000000002a0","GRADMIN","GetRoleAdmin DefaultAdmin"],
	["0x20c00000000000000000000000000000000002a1","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000029f","GRATID","GetRoleAdmin Token ID"],
	["0x20c000000000000000000000000000000000029d","GRASET","GetRoleAdmin After Set"],
	["0x20c000000000000000000000000000000000029e","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000029c","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000029b","GRATEST","GetRoleAdmin Test Token"],
	["0x20c000000000000000000000000000000000029a","HRTID","HasRole Token ID"],
	["0x20c0000000000000000000000000000000000299","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000298","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000297","HRREV","HasRole Revoke"],
	["0x20c0000000000000000000000000000000000296","HRMULTI","HasRole Multiple"],
	["0x20c0000000000000000000000000000000000295","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000293","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000294","HROAC","HasRole Other Account"],
	["0x20c0000000000000000000000000000000000292","HRTEST","HasRole Test Token"],
	["0x20c0000000000000000000000000000000000290","TKA","Token A"],
	["0x20c0000000000000000000000000000000000291","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000028e","TKB","Token B"],
	["0x20c000000000000000000000000000000000028f","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000028d","RESTR","Restricted Token"],
	["0x20c000000000000000000000000000000000028b","LINK2","Quote Token 2"],
	["0x20c000000000000000000000000000000000028c","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000028a","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000289","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000288","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000287","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000286","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000285","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000284","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000283","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000282","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000281","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000280","LINK","Quote Token"],
	["0x20c000000000000000000000000000000000027e","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000027f","MAIN","Main Token"],
	["0x20c000000000000000000000000000000000027c","LINK","Quote Token"],
	["0x20c000000000000000000000000000000000027d","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000027b","MAINID","Main Token ID"],
	["0x20c000000000000000000000000000000000027a","LINK3","Quote Token 3"],
	["0x20c0000000000000000000000000000000000279","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000278","MAINID","Main Token ID"],
	["0x20c0000000000000000000000000000000000276","LINK3","Quote Token 3"],
	["0x20c0000000000000000000000000000000000277","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000275","MAINID","Main Token ID"],
	["0x20c0000000000000000000000000000000000274","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000273","LINK3","Quote Token 3"],
	["0x20c0000000000000000000000000000000000272","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000271","MAINID","Main Token ID"],
	["0x20c0000000000000000000000000000000000270","LINK3","Quote Token 3"],
	["0x20c000000000000000000000000000000000026f","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000026e","RESTR","Restricted Token"],
	["0x20c000000000000000000000000000000000026d","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000026c","LINK2","Quote Token 2"],
	["0x20c000000000000000000000000000000000026b","MAIN","Main Token"],
	["0x20c000000000000000000000000000000000026a","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000269","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000268","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000266","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000267","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000265","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000264","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000263","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000262","MAIN","Main Token"],
	["0x20c0000000000000000000000000000000000260","LINK","Quote Token"],
	["0x20c0000000000000000000000000000000000261","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000025f","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000025e","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000025d","SPLIT","Split Role Token"],
	["0x20c000000000000000000000000000000000025c","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000025b","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000025a","RUNPAUSE","Restricted Unpause Token"],
	["0x20c0000000000000000000000000000000000259","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000258","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000257","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000256","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000255","UNPAUSE","Unpausable Token"],
	["0x20c0000000000000000000000000000000000254","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000253","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000252","UNPAUSE","Unpausable Token"],
	["0x20c0000000000000000000000000000000000251","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000250","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000024f","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000024e","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000024d","UNPAUSE","Unpausable Token"],
	["0x20c000000000000000000000000000000000024c","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000024b","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000024a","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000249","UNPAUSE","Unpausable Token"],
	["0x20c0000000000000000000000000000000000248","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000246","DPAUSE","Double Pause Token"],
	["0x20c0000000000000000000000000000000000247","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000245","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000244","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000243","DPAUSE","Double Pause Token"],
	["0x20c0000000000000000000000000000000000242","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000241","DPAUSE","Double Pause Token"],
	["0x20c0000000000000000000000000000000000240","DPAUSE","Double Pause Token"],
	["0x20c000000000000000000000000000000000023f","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000023e","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000023d","RPAUSE","Restricted Pause Token"],
	["0x20c000000000000000000000000000000000023c","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000023b","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000239","PAUSE","Pausable Token"],
	["0x20c000000000000000000000000000000000023a","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000238","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000237","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000235","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000236","PAUSE","Pausable Token"],
	["0x20c0000000000000000000000000000000000234","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000233","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000231","PAUSE","Pausable Token"],
	["0x20c0000000000000000000000000000000000232","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000230","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000022f","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000022e","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000022d","TST","Test Token"],
	["0x20c000000000000000000000000000000000022c","PAUSE","Pausable Token"],
	["0x20c000000000000000000000000000000000022b","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000022a","TST","Test Token"],
	["0x20c0000000000000000000000000000000000229","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000228","RBURN","Restricted Burn Token"],
	["0x20c0000000000000000000000000000000000227","TST","Test Token"],
	["0x20c0000000000000000000000000000000000226","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000225","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000224","BURN","Burnable Token"],
	["0x20c0000000000000000000000000000000000223","TST","Test Token"],
	["0x20c0000000000000000000000000000000000222","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000220","BURN","Burnable Token"],
	["0x20c0000000000000000000000000000000000221","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000021f","TST","Test Token"],
	["0x20c000000000000000000000000000000000021e","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000021d","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000021c","TST","Test Token"],
	["0x20c000000000000000000000000000000000021b","BURN","Burnable Token"],
	["0x20c000000000000000000000000000000000021a","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000218","BURN","Burnable Token"],
	["0x20c0000000000000000000000000000000000219","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000217","TST","Test Token"],
	["0x20c0000000000000000000000000000000000215","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000216","TST","Test Token"],
	["0x20c0000000000000000000000000000000000214","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000212","TST","Test Token"],
	["0x20c0000000000000000000000000000000000213","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000211","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000210","XFER","Transfer Token"],
	["0x20c000000000000000000000000000000000020f","TST","Test Token"],
	["0x20c000000000000000000000000000000000020e","BASE","Test Base Token"],
	["0x20c000000000000000000000000000000000020c","TST","Test Token"],
	["0x20c000000000000000000000000000000000020d","QUOTE","Test Quote Token"],
	["0x20c000000000000000000000000000000000020b","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000209","TEST","Test Token"],
	["0x20c000000000000000000000000000000000020a","MINT","Mintable Token"],
	["0x20c0000000000000000000000000000000000208","TST","Test Token"],
	["0x20c0000000000000000000000000000000000207","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000206","MINT","Mintable Token"],
	["0x20c0000000000000000000000000000000000205","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000204","TST","Test Token"],
	["0x20c0000000000000000000000000000000000203","MINT","Mintable Token"],
	["0x20c0000000000000000000000000000000000202","TEST2","Test Token 2"],
	["0x20c0000000000000000000000000000000000201","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000200","TST","Test Token"],
	["0x20c00000000000000000000000000000000001fe","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000001ff","MINT","Mintable Token"],
	["0x20c00000000000000000000000000000000001fd","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001fb","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001fc","TEST","Test Token"],
	["0x20c00000000000000000000000000000000001fa","TST","Test Token"],
	["0x20c00000000000000000000000000000000001f9","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000001f8","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001f7","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000001f6","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001f4","TEST","Test Token"],
	["0x20c00000000000000000000000000000000001f5","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001f3","TST","Test Token"],
	["0x20c00000000000000000000000000000000001f2","TUSD","Test USD"],
	["0x20c00000000000000000000000000000000001f1","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000001f0","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000001ee","TEST","Test Token"],
	["0x20c00000000000000000000000000000000001ef","TST","Test Token"],
	["0x20c00000000000000000000000000000000001ed","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000001ec","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000001eb","TST","Test Token"],
	["0x20c00000000000000000000000000000000001ea","TEST2","Test Token 2"],
	["0x20c00000000000000000000000000000000001e9","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001e8","BASE","Test Base Token"],
	["0x20c00000000000000000000000000000000001e7","TST","Test Token"],
	["0x20c00000000000000000000000000000000001e6","TEST","Test Token"],
	["0x20c00000000000000000000000000000000001e5","QUOTE","Test Quote Token"],
	["0x20c00000000000000000000000000000000001e4","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000001e3","ddd","ddd"],
	["0x20c00000000000000000000000000000000001e2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001e1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001e0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001df","asd","jake"],
	["0x20c00000000000000000000000000000000001de","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001dd","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001dc","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001db","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001da","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001d9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d8","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d7","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d5","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d4","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d3","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d2","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001d0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001cf","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000001ce","AUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000001cd","AUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000001cc","acmeUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000001cb","acmeUSD","acmeUSD"],
	["0x20c00000000000000000000000000000000001ca","TEST","Test"],
	["0x20c00000000000000000000000000000000001c9","TEST","Test"],
	["0x20c00000000000000000000000000000000001c8","TEST","Test"],
	["0x20c00000000000000000000000000000000001c7","TEST","Test"],
	["0x20c00000000000000000000000000000000001c6","TEST","Test"],
	["0x20c00000000000000000000000000000000001c5","TEST","Test"],
	["0x20c00000000000000000000000000000000001c4","TEST","Test"],
	["0x20c00000000000000000000000000000000001c3","TEST","Test"],
	["0x20c00000000000000000000000000000000001c2","TEST","Test"],
	["0x20c00000000000000000000000000000000001c1","TEST","Test"],
	["0x20c00000000000000000000000000000000001c0","TEST","Test"],
	["0x20c00000000000000000000000000000000001bf","TEST","Test"],
	["0x20c00000000000000000000000000000000001be","TEST","Test"],
	["0x20c00000000000000000000000000000000001bd","TEST","Test"],
	["0x20c00000000000000000000000000000000001bc","TEST","Test"],
	["0x20c00000000000000000000000000000000001bb","TEST","Test"],
	["0x20c00000000000000000000000000000000001ba","TEST","Test"],
	["0x20c00000000000000000000000000000000001b9","TEST","Test"],
	["0x20c00000000000000000000000000000000001b8","TEST","Test"],
	["0x20c00000000000000000000000000000000001b7","TEST","Test"],
	["0x20c00000000000000000000000000000000001b6","TEST","Test"],
	["0x20c00000000000000000000000000000000001b5","TEST","Test"],
	["0x20c00000000000000000000000000000000001b4","TEST","Test"],
	["0x20c00000000000000000000000000000000001b3","TEST","Test"],
	["0x20c00000000000000000000000000000000001b2","TEST","Test"],
	["0x20c00000000000000000000000000000000001b1","TEST","Test"],
	["0x20c00000000000000000000000000000000001b0","TEST","Test"],
	["0x20c00000000000000000000000000000000001af","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001ae","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001ad","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001ac","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001ab","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001aa","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a9","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a8","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a7","KLARNAUSD","Klarna USD"],
	["0x20c00000000000000000000000000000000001a6","DUSD2","DanUSD2"],
	["0x20c00000000000000000000000000000000001a5","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a4","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a3","lUSD","lambdaUSD"],
	["0x20c00000000000000000000000000000000001a2","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a1","TEST3","Test Token 3"],
	["0x20c00000000000000000000000000000000001a0","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000019f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000019e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000019d","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000019c","DAN","DanUSD"],
	["0x20c000000000000000000000000000000000019b","zfsUST","zfsUST"],
	["0x20c000000000000000000000000000000000019a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000199","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000198","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000197","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000196","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000195","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000194","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000193","aa","de"],
	["0x20c0000000000000000000000000000000000192","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000191","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000190","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000018f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000018e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000018d","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000018c","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000018b","DAN","DanUSD"],
	["0x20c000000000000000000000000000000000018a","DAN","DanUSD"],
	["0x20c0000000000000000000000000000000000189","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000188","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000187","DAN","DanUSD"],
	["0x20c0000000000000000000000000000000000186","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000185","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000184","YSD","Demo"],
	["0x20c0000000000000000000000000000000000183","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000182","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000181","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000180","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000017f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000017e","LIAM","liamUSD"],
	["0x20c000000000000000000000000000000000017d","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000017c","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000017b","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000017a","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000179","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000178","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000177","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000176","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000175","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000174","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000173","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000172","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000171","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000170","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016f","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016e","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016d","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016c","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016b","TEST3","Test Token 3"],
	["0x20c000000000000000000000000000000000016a","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000169","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000168","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000167","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000166","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000165","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000164","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000163","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000162","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000161","TEST3","Test Token 3"],
	["0x20c0000000000000000000000000000000000160","DEMO","demoUSD"],
	["0x20c000000000000000000000000000000000015f","DEMO","demoUSD"],
	["0x20c000000000000000000000000000000000015e","FOO","FooUSD"],
	["0x20c000000000000000000000000000000000015d","FOO","FooUSD"],
	["0x20c000000000000000000000000000000000015c","FOO","FooUSD"],
	["0x20c000000000000000000000000000000000015b","FOO","fooUSD"],
	["0x20c000000000000000000000000000000000015a","WAGMI","wagmiUSD"],
	["0x20c0000000000000000000000000000000000159","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000158","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000157","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000156","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000155","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000154","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000153","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000152","BASE","Test Base Token"],
	["0x20c0000000000000000000000000000000000151","QUOTE","Test Quote Token"],
	["0x20c0000000000000000000000000000000000150","TEST","Test Token"],
	["0x20c000000000000000000000000000000000014f","TEST","Test Token"],
	["0x20c000000000000000000000000000000000014e","TEST2","Test Token 2"],
	["0x20c000000000000000000000000000000000014d","TEST","Test Token"],
	["0x20c000000000000000000000000000000000014c","TEST","Test Token"],
	["0x20c000000000000000000000000000000000014b","TEST","Test Token"],
	["0x20c000000000000000000000000000000000014a","TEST2","Test Token 2"],
	["0x20c0000000000000000000000000000000000149","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000148","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000147","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000146","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000145","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000144","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000143","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000142","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000141","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000140","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013f","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013e","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013d","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013c","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013b","TEST","Test Token"],
	["0x20c000000000000000000000000000000000013a","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000139","TEST","Test Token"],
	["0x20c0000000000000000000000000000000000138","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000137","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000136","wUSD","WowzaUSD"],
	["0x20c0000000000000000000000000000000000135","asdf","asdf"],
	["0x20c0000000000000000000000000000000000134","Deni","Deno"],
	["0x20c0000000000000000000000000000000000133","asdf","asdf"],
	["0x20c0000000000000000000000000000000000132","asdf","asdf"],
	["0x20c0000000000000000000000000000000000131","tom","tom"],
	["0x20c0000000000000000000000000000000000130","moooUSD","moooUSD"],
	["0x20c000000000000000000000000000000000012f","moooUSD","moooUSD"],
	["0x20c000000000000000000000000000000000012e","moooUSD","moooUSD"],
	["0x20c000000000000000000000000000000000012d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000012c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000012b","FOO","FooUSD"],
	["0x20c000000000000000000000000000000000012a","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000129","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000128","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000127","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000126","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000125","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000124","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000123","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000121","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000122","tUSD1","testUSD1"],
	["0x20c0000000000000000000000000000000000120","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000011a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000119","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000118","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000117","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000116","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000115","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000114","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000113","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000112","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000111","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000110","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000010a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000109","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000108","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000107","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000106","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000105","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000104","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000103","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000102","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000101","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000100","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ff","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000fe","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000fd","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000fc","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000fb","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000fa","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f8","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f7","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f5","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f4","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f3","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f2","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000f0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ef","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ee","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ed","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ec","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000eb","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ea","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000e9","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000e8","DEMO","asd"],
	["0x20c00000000000000000000000000000000000e7","DEMO","asd"],
	["0x20c00000000000000000000000000000000000e6","DEMO","asd"],
	["0x20c00000000000000000000000000000000000e5","DEMO","asd"],
	["0x20c00000000000000000000000000000000000e4","asd","asd"],
	["0x20c00000000000000000000000000000000000e3","asd","asd"],
	["0x20c00000000000000000000000000000000000e2","as","asdas"],
	["0x20c00000000000000000000000000000000000e1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000e0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000df","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000de","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000dd","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000dc","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000db","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000da","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d9","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d8","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d7","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d6","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d5","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d4","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d3","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000d2","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000000d1","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000d0","FOO","FOOUSD"],
	["0x20c00000000000000000000000000000000000cf","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000ce","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000cd","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000cc","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000cb","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000ca","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c9","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c8","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c7","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c6","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c5","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c4","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c3","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c2","DEMO","demoUSD"],
	["0x20c00000000000000000000000000000000000c1","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000c0","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000bf","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000be","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000bd","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000bc","catUSD","CatenaUSD"],
	["0x20c00000000000000000000000000000000000bb","TBUCK","TestBuck"],
	["0x20c00000000000000000000000000000000000ba","VBUCK","VenaBuck"],
	["0x20c00000000000000000000000000000000000b9","VBUCK","VenaBuck"],
	["0x20c00000000000000000000000000000000000b8","VBUCK","VenaBuck"],
	["0x20c00000000000000000000000000000000000b7","VBUCK","VenaBuck"],
	["0x20c00000000000000000000000000000000000b6","VBUCK","VenaBuck"],
	["0x20c00000000000000000000000000000000000b5","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000000b4","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000000b3","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000000b2","FOO","FooUSD"],
	["0x20c00000000000000000000000000000000000b1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000b0","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000af","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ae","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ad","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ac","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000ab","DEMO","demoUSD"],
	["0x20c00000000000000000000000000000000000aa","DEMO","demoUSD"],
	["0x20c00000000000000000000000000000000000a9","DEMO","demoUSD"],
	["0x20c00000000000000000000000000000000000a8","aa","demoUSD"],
	["0x20c00000000000000000000000000000000000a7","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a6","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a5","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a4","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a3","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a2","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a1","tUSD","testUSD"],
	["0x20c00000000000000000000000000000000000a0","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000009a","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000099","das","asd"],
	["0x20c0000000000000000000000000000000000098","asd","asd"],
	["0x20c0000000000000000000000000000000000097","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000096","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000095","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000094","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000093","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000092","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000091","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000090","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000008a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000089","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000088","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000087","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000086","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000085","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000084","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000083","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000082","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000081","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000080","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000007f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000007e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000007d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000007c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000007b","Test","TestUSD"],
	["0x20c000000000000000000000000000000000007a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000079","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000078","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000077","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000076","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000075","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000074","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000073","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000072","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000071","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000070","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000006a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000069","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000068","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000067","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000066","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000065","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000064","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000063","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000062","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000061","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000060","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000005f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000005e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000005d","jlksdjafl","testUSD"],
	["0x20c000000000000000000000000000000000005c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000005b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000005a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000059","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000058","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000057","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000056","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000055","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000054","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000053","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000052","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000051","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000050","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000004a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000049","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000048","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000047","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000046","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000045","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000044","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000043","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000042","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000041","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000040","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000003a","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000039","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000038","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000037","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000036","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000035","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000034","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000033","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000032","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000031","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000030","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000002f","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000002e","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000002d","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000002c","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000002b","jake","jakeUSD"],
	["0x20c000000000000000000000000000000000002a","jake","jakeUSD"],
	["0x20c0000000000000000000000000000000000029","asdf","asdf"],
	["0x20c0000000000000000000000000000000000028","asdf","asdf"],
	["0x20c0000000000000000000000000000000000027","FOO","Foo"],
	["0x20c0000000000000000000000000000000000026","mpUSD","mmpUSD"],
	["0x20c0000000000000000000000000000000000025","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000024","FOO","Foo"],
	["0x20c0000000000000000000000000000000000023","asd","asd"],
	["0x20c0000000000000000000000000000000000022","FOO","Foo"],
	["0x20c0000000000000000000000000000000000021","asd","asd"],
	["0x20c0000000000000000000000000000000000020","asd","asd"],
	["0x20c000000000000000000000000000000000001f","a","asd"],
	["0x20c000000000000000000000000000000000001e","USD","demoUSD"],
	["0x20c000000000000000000000000000000000001d","MDEO","demoUSD"],
	["0x20c000000000000000000000000000000000001c","DEMO","demoUSD"],
	["0x20c000000000000000000000000000000000001b","tUSD","testUSD"],
	["0x20c000000000000000000000000000000000001a","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000019","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000018","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000017","FOO2","FooUSD2"],
	["0x20c0000000000000000000000000000000000016","FOO1","FooUSD"],
	["0x20c0000000000000000000000000000000000015","TEST","Test"],
	["0x20c0000000000000000000000000000000000014","TEST","Test"],
	["0x20c0000000000000000000000000000000000013","TEST","Test"],
	["0x20c0000000000000000000000000000000000012","TEST","Test"],
	["0x20c0000000000000000000000000000000000011","FOO","FooUSD"],
	["0x20c0000000000000000000000000000000000010","TEST","Test"],
	["0x20c000000000000000000000000000000000000f","TEST","Test"],
	["0x20c000000000000000000000000000000000000e","TEST","Test"],
	["0x20c000000000000000000000000000000000000d","TEST","Test"],
	["0x20c000000000000000000000000000000000000c","TEST","Test"],
	["0x20c000000000000000000000000000000000000b","TEST","Test"],
	["0x20c000000000000000000000000000000000000a","TEST","Test"],
	["0x20c0000000000000000000000000000000000009","DEMO","demoUSD"],
	["0x20c0000000000000000000000000000000000008","FOO3","FooUSD3"],
	["0x20c0000000000000000000000000000000000007","FOO2","FooUSD2"],
	["0x20c0000000000000000000000000000000000006","FooUSD","FooUSD"],
	["0x20c0000000000000000000000000000000000005","tUSD","testUSD"],
	["0x20c0000000000000000000000000000000000004","aa","aa"]
]

```

## File: apps/explorer/src/index.client.tsx
```
import { StartClient } from '@tanstack/react-start/client'
import * as React from 'react'
import { hydrateRoot } from 'react-dom/client'

hydrateRoot(
	document,
	<React.StrictMode>
		<StartClient />
	</React.StrictMode>,
)

```

## File: apps/explorer/src/index.server.ts
```
import handler, { type ServerEntry } from '@tanstack/react-start/server-entry'

export default {
	fetch: handler.fetch,
} satisfies ServerEntry

```

## File: apps/explorer/src/index.start.ts
```
import { createStart } from '@tanstack/react-start'

export const startInstance = createStart(() => ({
	defaultSsr: true, // default is true
}))

```

## File: apps/explorer/src/lib/abi.ts
```
import { loaders, whatsabi } from '@shazow/whatsabi'
import { queryOptions, useQuery } from '@tanstack/react-query'
import type { AbiEvent, AbiFunction } from 'abitype'
import {
	type Abi,
	type Address,
	decodeEventLog,
	getAbiItem as getAbiItem_viem,
	type Hex,
	stringify,
} from 'viem'
import { getPublicClient } from 'wagmi/actions'
import { config } from '#wagmi.config'

export function useAutoloadAbi(args: {
	address?: Address | null
	enabled?: boolean
}) {
	const { address, enabled } = args
	const client = getPublicClient(config)

	return useQuery(
		queryOptions({
			enabled: enabled && Boolean(address) && Boolean(client),
			gcTime: Number.POSITIVE_INFINITY,
			staleTime: Number.POSITIVE_INFINITY,
			queryKey: ['autoload-abi', address],
			async queryFn() {
				if (!address) throw new Error('address is required')
				if (!client) throw new Error('client is required')

				const result = await whatsabi.autoload(address, {
					provider: client,
					followProxies: true,
					abiLoader: new loaders.MultiABILoader([
						new loaders.SourcifyABILoader({
							chainId: client.chain?.id,
						}),
					]),
				})

				if (!result.abi.some((item) => (item as { name?: string }).name))
					return null

				return result.abi.map((abiItem) => ({
					...abiItem,
					outputs:
						'outputs' in abiItem && abiItem.outputs ? abiItem.outputs : [],
				}))
			},
		}),
	)
}

export function useLookupSignature(args: {
	enabled?: boolean
	selector?: Hex
}) {
	const { enabled = true, selector } = args

	return useQuery(
		queryOptions({
			enabled: enabled && Boolean(selector),
			gcTime: Number.POSITIVE_INFINITY,
			staleTime: Number.POSITIVE_INFINITY,
			queryKey: ['lookup-signature', selector],
			async queryFn() {
				if (!selector) throw new Error('selector is required')

				const signature =
					selector.length === 10
						? await loaders.defaultSignatureLookup.loadFunctions(selector)
						: await loaders.defaultSignatureLookup.loadEvents(selector)

				return signature[0] ?? null
			},
		}),
	)
}

export function getAbiItem({
	abi,
	selector,
}: {
	abi: Abi
	selector: Hex
}): AbiFunction | undefined {
	const abiItem =
		(getAbiItem_viem({
			abi: abi.map((x) => ({
				...x,
				inputs: (x as AbiFunction).inputs || [],
				outputs: (x as AbiFunction).outputs || [],
			})),
			name: selector,
		}) as AbiFunction) ||
		abi.find((x) => (x as AbiFunction).name === selector) ||
		abi.find((x) => (x as { selector?: string }).selector === selector)

	if (!abiItem) return

	return {
		...abiItem,
		outputs: abiItem.outputs || [],
		inputs: abiItem.inputs || [],
		name: abiItem.name || (abiItem as { selector?: string }).selector || '',
	} as AbiFunction
}

export function formatAbiValue(value: unknown): string {
	if (typeof value === 'bigint') {
		return value.toString()
	}
	if (Array.isArray(value)) {
		return `[${value.map(formatAbiValue).join(', ')}]`
	}
	if (typeof value === 'object' && value !== null) {
		return stringify(value)
	}
	return String(value ?? '')
}

// https://github.com/paradigmxyz/rivet/blob/fd94089ba4bec65bbf3fa288efbeab7306cb1537/src/utils/abi.ts#L13
export function decodeEventLog_guessed(args: {
	abiItem: AbiEvent
	data: Hex
	topics: readonly Hex[]
}) {
	const { abiItem, data, topics } = args
	const indexedValues = topics.slice(1)

	for (let i = 0; i < indexedValues.length; i++) {
		const offset = indexedValues.length - i
		for (
			let j = 0;
			j < abiItem.inputs.length - indexedValues.length + 1 - i;
			j++
		) {
			const inputs = abiItem.inputs.map((input, index) => ({
				...input,
				indexed:
					index < offset - 1 ||
					index === i + j + offset - 1 ||
					index >= abiItem.inputs.length - (indexedValues.length - offset),
			}))
			const abi = [{ ...abiItem, inputs }]
			try {
				return decodeEventLog({
					abi,
					topics: topics as [Hex, ...Hex[]],
					data,
				})
			} catch {}
		}
	}
}

```

## File: apps/explorer/src/lib/chars.ts
```
export const apostrophe = '\u2019'
export const ellipsis = '\u2026'
export const nbsp = '\u00A0'

```

## File: apps/explorer/src/lib/demo.ts
```
import type { Address, Hex } from 'ox'
import type {
	Log,
	RpcTransaction as Transaction,
	TransactionReceipt,
} from 'viem'
import { zeroAddress } from 'viem'

export const transactionHash = `0x${'1'.repeat(64)}` as const
export const blockHash = zeroAddress
export const blockNumber = 12345n
export const baseTimestamp = BigInt(Math.floor(Date.now() / 1000))

export const tokenAddress = `0x${'1234567890'.repeat(4)}` as const
export const registryAddress = `0x${'a'.repeat(40)}` as const
export const updaterAddress = `0x${'abcde'.repeat(8)}` as const
export const recipientAddress = `0x${'9'.repeat(40)}` as const
export const adminAddress = `0x${'b'.repeat(40)}` as const
export const spenderAddress = `0x${'c'.repeat(40)}` as const
export const userTokenAddress = `0x${'d'.repeat(40)}` as const
export const validatorTokenAddress = `0x${'e'.repeat(40)}` as const
export const accountAddress = `0x${'f'.repeat(40)}` as const
export const feeAmmAddress = `0x${'1'.repeat(40)}` as const
export const factoryAddress = `0x${'2'.repeat(40)}` as const
export const exchangeAddress = `0x${'3'.repeat(40)}` as const
export const makerAddress = `0x${'4'.repeat(40)}` as const
export const baseTokenAddress = `0x${'5'.repeat(40)}` as const
export const quoteTokenAddress = `0x${'6'.repeat(40)}` as const
export const validatorAddress = `0x${'7'.repeat(40)}` as const

export function mockLog(
	log: Partial<Log>,
	txHash: Hex.Hex = `0x${'1'.repeat(64)}`,
): Log {
	return {
		address: zeroAddress,
		topics: [],
		data: '0x',
		blockHash,
		blockNumber,
		transactionHash: txHash,
		transactionIndex: 0,
		logIndex: 0,
		removed: false,
		...log,
	} as Log
}

export function mockReceipt(
	logs: Log[],
	from: Address.Address,
	txHash: Hex.Hex = `0x${'1'.repeat(64)}`,
): TransactionReceipt {
	return {
		blockHash,
		blockNumber,
		contractAddress: null,
		cumulativeGasUsed: 100000n,
		effectiveGasPrice: 1000000000n,
		from,
		gasUsed: 50000n,
		logs,
		logsBloom: `0x${'0'.repeat(512)}`,
		status: 'success',
		to: logs[0]?.address ?? zeroAddress,
		transactionHash: txHash,
		transactionIndex: 0,
		type: 'eip1559',
	} as TransactionReceipt
}

export function mockTransaction(
	hash: Hex.Hex,
	from: Address.Address,
	to: Address.Address,
	blockNum: bigint,
): Transaction {
	return {
		hash,
		from,
		to,
		blockHash,
		blockNumber: `0x${blockNum.toString(16)}`,
		transactionIndex: '0x0',
		gas: '0x5208',
		gasPrice: '0x3b9aca00',
		maxFeePerGas: '0x77359400',
		maxPriorityFeePerGas: '0x3b9aca00',
		value: '0x0',
		input: '0x',
		nonce: '0x0',
		type: '0x2',
		accessList: [],
		chainId: '0x1',
		yParity: '0x0',
		r: '0x0',
		s: '0x0',
	} as unknown as Transaction
}

export const metadataMap = new Map([
	[
		tokenAddress.toLowerCase(),
		{
			currency: 'USD',
			decimals: 2,
			symbol: 'TEST2',
			name: 'Test Token 2',
			totalSupply: 1000000n,
		},
	],
	[
		userTokenAddress.toLowerCase(),
		{
			currency: 'USD',
			decimals: 6,
			symbol: 'USDC',
			name: 'USD Coin',
			totalSupply: 1000000000000n,
		},
	],
	[
		validatorTokenAddress.toLowerCase(),
		{
			currency: 'USD',
			decimals: 6,
			symbol: 'LINK',
			name: 'Chainlink',
			totalSupply: 1000000000000n,
		},
	],
	[
		baseTokenAddress.toLowerCase(),
		{
			currency: 'USD',
			decimals: 6,
			symbol: 'DAI',
			name: 'Dai Stablecoin',
			totalSupply: 1000000000000n,
		},
	],
	[
		quoteTokenAddress.toLowerCase(),
		{
			currency: 'USD',
			decimals: 6,
			symbol: 'USDT',
			name: 'Tether USD',
			totalSupply: 1000000000000n,
		},
	],
])

export const getTokenMetadata = (address: Address.Address) =>
	metadataMap.get(address.toLowerCase())

```

## File: apps/explorer/src/lib/domain/contracts.ts
```
import { whatsabi } from '@shazow/whatsabi'
import type { Address, Hex } from 'ox'
import { Abis, Addresses } from 'tempo.ts/viem'
import type { Abi, AbiFunction, AbiParameter } from 'viem'
import { toFunctionSelector } from 'viem'
import { getPublicClient } from 'wagmi/actions'
import { isTip20Address } from '#lib/domain/tip20.ts'
import { config } from '#wagmi.config.ts'

/**
 * Registry of known contract addresses to their ABIs and metadata.
 * This enables the explorer to render contract interfaces for any precompile.
 */

export type ContractInfo = {
	name: string
	description?: string
	code: Hex.Hex
	abi: Abi
	/** Category for grouping in UI */
	category: 'token' | 'system' | 'utility' | 'account'
	/** External documentation link */
	docsUrl?: string
	address: Address.Address
}

/**
 * Known TIP-20 Token contracts registry mapping addresses to their metadata and ABIs.
 */
export const tip20ContractRegistry = new Map<Address.Address, ContractInfo>(<
	const
>[
	// TIP-20 Tokens
	[
		'0x20c0000000000000000000000000000000000000',
		{
			name: 'pathUSD',
			description: 'Non-transferable DEX accounting unit',
			abi: Abis.tip20,
			code: '0xef',
			category: 'token',
			docsUrl: 'https://docs.tempo.xyz/documentation/protocol/exchange/pathUSD',
			address: '0x20c0000000000000000000000000000000000000',
		},
	],
	[
		'0x20c0000000000000000000000000000000000001',
		{
			name: 'AlphaUSD',
			code: '0xef',
			description: 'TIP-20 stablecoin (AUSD)',
			abi: Abis.tip20,
			category: 'token',
			address: '0x20c0000000000000000000000000000000000001',
		},
	],
	[
		'0x20c0000000000000000000000000000000000002',
		{
			name: 'BetaUSD',
			code: '0xef',
			description: 'TIP-20 stablecoin (BUSD)',
			abi: Abis.tip20,
			category: 'token',
			address: '0x20c0000000000000000000000000000000000002',
		},
	],
	[
		'0x20c0000000000000000000000000000000000003',
		{
			name: 'ThetaUSD',
			code: '0xef',
			description: 'TIP-20 stablecoin (TUSD)',
			abi: Abis.tip20,
			category: 'token',
			address: '0x20c0000000000000000000000000000000000003',
		},
	],
])

/**
 * Known System contracts registry mapping addresses to their metadata and ABIs.
 */
export const systemContractRegistry = new Map<Address.Address, ContractInfo>(<
	const
>[
	// System Contracts
	[
		Addresses.tip20Factory,
		{
			name: 'TIP-20 Factory',
			code: '0xef',
			description: 'Create new TIP-20 tokens',
			abi: Abis.tip20Factory,
			category: 'system',
			docsUrl: 'https://docs.tempo.xyz/documentation/protocol/tip20/overview',
			address: Addresses.tip20Factory,
		},
	],
	[
		// 0xfeec000000000000000000000000000000000000
		Addresses.feeManager,
		{
			name: 'Fee Manager',
			code: '0xef',
			description: 'Handle fee payments and conversions',
			abi: Abis.feeManager,
			category: 'system',
			docsUrl:
				'https://docs.tempo.xyz/documentation/protocol/fees/spec-fee-amm#2-feemanager-contract',
			address: Addresses.feeManager,
		},
	],
	[
		Addresses.stablecoinExchange,
		{
			name: 'Stablecoin Exchange',
			code: '0xef',
			description: 'Enshrined DEX for stablecoin swaps',
			abi: Abis.stablecoinExchange,
			category: 'system',
			docsUrl: 'https://docs.tempo.xyz/documentation/protocol/exchange',
			address: Addresses.stablecoinExchange,
		},
	],
	[
		Addresses.tip403Registry,
		{
			name: 'TIP-403 Registry',
			code: '0xef',
			description: 'Transfer policy registry',
			abi: Abis.tip403Registry,
			category: 'system',
			docsUrl: 'https://docs.tempo.xyz/documentation/protocol/tip403/spec',
			address: Addresses.tip403Registry,
		},
	],

	// Account Abstraction
	[
		Addresses.accountImplementation,
		{
			name: 'IthacaAccount',
			code: '0xef',
			description: 'Reference account implementation',
			abi: Abis.tipAccountRegistrar,
			category: 'account',
			address: Addresses.accountImplementation,
		},
	],
])

/**
 * Known contract registry mapping addresses to their metadata and ABIs.
 */
export const contractRegistry = new Map<Address.Address, ContractInfo>(<const>[
	...systemContractRegistry.entries(),
	...tip20ContractRegistry.entries(),
])

/**
 * detect if an address is a system address (i.e., not a token)
 */
export function systemAddress(address: Address.Address): boolean {
	return systemContractRegistry.has(address.toLowerCase() as Address.Address)
}

/**
 * Get contract info by address (case-insensitive)
 * Also handles TIP-20 tokens that aren't explicitly registered
 */
export function getContractInfo(
	address: Address.Address,
): ContractInfo | undefined {
	const registered = contractRegistry.get(
		address.toLowerCase() as Address.Address,
	)
	if (registered) return registered

	// Dynamic TIP-20 token detection
	if (isTip20Address(address))
		return {
			address,
			name: 'TIP-20 Token',
			code: '0xef',
			description: 'TIP-20 compatible token',
			abi: Abis.tip20,
			category: 'token',
		}

	return undefined
}

/**
 * Get the ABI for a contract address
 */
export function getContractAbi(address: Address.Address): Abi | undefined {
	return getContractInfo(address)?.abi
}

/**
 * Check if an address is a known contract (includes TIP-20 tokens)
 */
export function isKnownContract(address: Address.Address): boolean {
	return (
		contractRegistry.has(address.toLowerCase() as Address.Address) ||
		isTip20Address(address)
	)
}

// ============================================================================
// ABI Utilities
// ============================================================================

export type ReadFunction = AbiFunction & { stateMutability: 'view' | 'pure' }
export type WriteFunction = AbiFunction & {
	stateMutability: 'nonpayable' | 'payable'
}

/**
 * Whatsabi adds a `selector` property to ABI items with the actual selector from bytecode.
 * This is needed because whatsabi doesn't always recover the function name.
 */
type WhatsabiAbiFunction = AbiFunction & { selector?: string }

/**
 * Get the function selector, using whatsabi's extracted selector if available,
 * otherwise computing it from the function signature.
 */
export function getFunctionSelector(fn: AbiFunction): string {
	const whatsabiFn = fn as WhatsabiAbiFunction
	if (whatsabiFn.selector) return whatsabiFn.selector
	// Only compute if we have a name (otherwise toFunctionSelector gives wrong result)
	if (fn.name) return toFunctionSelector(fn)
	// Fallback - shouldn't happen for valid ABIs
	return '0x00000000'
}

/**
 * Common read function name patterns.
 * Used to include functions that are likely read-only even if marked as 'nonpayable'.
 */
const READ_FUNCTION_PATTERNS = [
	/^get[A-Z_]/i,
	/^is[A-Z_]/i,
	/^has[A-Z_]/i,
	/^can[A-Z_]/i,
	/^check[A-Z_]/i,
	/^query[A-Z_]/i,
	/^fetch[A-Z_]/i,
	/^read[A-Z_]/i,
	/^view[A-Z_]/i,
	/^calculate[A-Z_]/i,
	/^compute[A-Z_]/i,
	/^estimate[A-Z_]/i,
	/^predict[A-Z_]/i,
	/^current[A-Z_]/i,
	/^total[A-Z_]/i,
	/^balance/i,
	/^allowance/i,
	/^owner/i,
	/^name$/i,
	/^symbol$/i,
	/^decimals$/i,
	/^version$/i,
	/^nonce/i,
	/^supply/i,
	/^length$/i,
	/^count$/i,
	/^size$/i,
	/^index$/i,
]

/**
 * Common write function name patterns.
 * Used to filter out functions that whatsabi incorrectly marked as 'view'.
 */
const WRITE_FUNCTION_PATTERNS = [
	/^transfer/i,
	/^approve/i,
	/^set[A-Z_]/i,
	/^mint/i,
	/^burn/i,
	/^withdraw/i,
	/^deposit/i,
	/^send/i,
	/^swap/i,
	/^add[A-Z_]/i,
	/^remove[A-Z_]/i,
	/^update/i,
	/^execute/i,
	/^submit/i,
	/^claim/i,
	/^stake/i,
	/^unstake/i,
	/^lock/i,
	/^unlock/i,
	/^pause/i,
	/^unpause/i,
	/^revoke/i,
	/^grant/i,
	/^renounce/i,
	/^initialize/i,
	/^create/i,
	/^delete/i,
	/^cancel/i,
	/^close/i,
	/^open/i,
	/^enable/i,
	/^disable/i,
]

/**
 * Check if a function name looks like a read function.
 * Used for whatsabi-extracted functions where stateMutability might be incorrect.
 */
function looksLikeReadFunction(name: string | undefined): boolean {
	if (!name) return false
	return READ_FUNCTION_PATTERNS.some((pattern) => pattern.test(name))
}

/**
 * Check if a function name looks like a write function.
 * Used for whatsabi-extracted functions where stateMutability might be incorrect.
 */
function looksLikeWriteFunction(name: string | undefined): boolean {
	if (!name) return false
	return WRITE_FUNCTION_PATTERNS.some((pattern) => pattern.test(name))
}

/**
 * Extract read-only functions from an ABI, deduplicated by selector.
 * - For standard ABIs: returns view/pure functions with outputs
 * - For whatsabi ABIs: uses name heuristics since stateMutability is often incorrect
 */
export function getReadFunctions(abi: Abi): ReadFunction[] {
	const functions = abi.filter((item): item is ReadFunction => {
		if (item.type !== 'function') return false
		if (!Array.isArray(item.inputs)) return false

		const whatsabiItem = item as WhatsabiAbiFunction
		const isWhatsabi = Boolean(whatsabiItem.selector)

		// For standard ABIs, use stateMutability and require outputs
		if (!isWhatsabi) {
			if (!Array.isArray(item.outputs) || item.outputs.length === 0)
				return false
			return item.stateMutability === 'view' || item.stateMutability === 'pure'
		}

		// For whatsabi ABIs, stateMutability is often wrong (everything is nonpayable)
		// Use name-based heuristics instead
		if (looksLikeWriteFunction(item.name)) return false
		if (looksLikeReadFunction(item.name)) return true

		// Functions with no inputs that don't look like writes are likely getters
		// (e.g., typeAndVersion(), owner(), MAX_RET_BYTES(), etc.)
		if (item.inputs.length === 0) return true

		// Default: only include if explicitly view/pure
		return item.stateMutability === 'view' || item.stateMutability === 'pure'
	})

	// Deduplicate by selector (whatsabi can return duplicates)
	const seen = new Set<string>()
	return functions.filter((fn) => {
		const selector = getFunctionSelector(fn)
		if (seen.has(selector)) return false
		seen.add(selector)
		return true
	})
}

/**
 * Extract write functions (nonpayable/payable) from an ABI, deduplicated by selector.
 * Also filters out malformed entries (missing inputs array).
 */
export function getWriteFunctions(abi: Abi): WriteFunction[] {
	const functions = abi.filter(
		(item): item is WriteFunction =>
			item.type === 'function' &&
			(item.stateMutability === 'nonpayable' ||
				item.stateMutability === 'payable') &&
			Array.isArray(item.inputs),
	)

	// Deduplicate by selector
	const seen = new Set<string>()
	return functions.filter((fn) => {
		const selector = getFunctionSelector(fn)
		if (seen.has(selector)) return false
		seen.add(selector)
		return true
	})
}

/**
 * Get functions without inputs (can be displayed as static values)
 */
export function getNoInputFunctions(abi: Abi): ReadFunction[] {
	return getReadFunctions(abi).filter((fn) => fn?.inputs?.length === 0)
}

/**
 * Get functions with inputs (require user input)
 */
export function getInputFunctions(abi: Abi): ReadFunction[] {
	return getReadFunctions(abi).filter((fn) => fn?.inputs?.length > 0)
}

// ============================================================================
// Parameter Type Utilities
// ============================================================================

export type SolidityBaseType =
	| 'address'
	| 'bool'
	| 'string'
	| 'bytes'
	| 'uint'
	| 'int'
	| 'tuple'

/**
 * Get the base type from a Solidity type string
 * e.g., "uint256" -> "uint", "address[]" -> "address"
 */
export function getBaseType(type: string): SolidityBaseType {
	const cleaned = type.replace(/\[\d*\]$/, '') // Remove array suffix
	if (cleaned.startsWith('uint')) return 'uint'
	if (cleaned.startsWith('int')) return 'int'
	if (cleaned.startsWith('bytes') && cleaned !== 'bytes') return 'bytes'
	return cleaned as SolidityBaseType
}

/**
 * Check if a type is an array type
 */
export function isArrayType(type: string): boolean {
	return type.endsWith('[]') || /\[\d+\]$/.test(type)
}

/**
 * Get placeholder text for an input type
 */
export function getPlaceholder(param: AbiParameter): string {
	const { type, name } = param
	const baseType = getBaseType(type)

	switch (baseType) {
		case 'address':
			return '0x…'
		case 'bool':
			return 'true or false'
		case 'string':
			return name || 'Enter text…'
		case 'bytes':
			return '0x…'
		case 'uint':
		case 'int':
			return '0'
		case 'tuple':
			return 'JSON object'
		default:
			return name || type
	}
}

/**
 * Get input type for HTML input element
 */
export function getInputType(
	type: string,
): 'text' | 'number' | 'checkbox' | 'textarea' {
	const baseType = getBaseType(type)
	if (baseType === 'bool') return 'checkbox'
	if (baseType === 'uint' || baseType === 'int') return 'text' // Use text for big numbers
	if (baseType === 'tuple' || isArrayType(type)) return 'textarea'
	return 'text'
}

/**
 * Parse user input to the correct type for contract call
 */
export function parseInputValue(value: string, type: string): unknown {
	const trimmed = value.trim()
	const baseType = getBaseType(type)

	if (isArrayType(type)) {
		try {
			return JSON.parse(trimmed)
		} catch {
			return trimmed.split(',').map((v) => v.trim())
		}
	}

	switch (baseType) {
		case 'bool':
			return trimmed === 'true' || trimmed === '1'
		case 'uint':
		case 'int':
			return BigInt(trimmed)
		case 'tuple':
			return JSON.parse(trimmed)
		default:
			return trimmed
	}
}

/**
 * Format output value for display
 */
export function formatOutputValue(value: unknown, _type: string): string {
	if (value === undefined || value === null) return '—'

	if (typeof value === 'bigint') return value.toString()

	if (typeof value === 'boolean') return value ? 'true' : 'false'

	if (Array.isArray(value) || typeof value === 'object')
		return JSON.stringify(value, (_, v) =>
			typeof v === 'bigint' ? v.toString() : v,
		)

	return String(value)
}

/**
 * Get the bytecode for a contract address
 */
export async function getContractBytecode(
	address: Address.Address,
): Promise<Hex.Hex | undefined> {
	const client = getPublicClient(config)
	const code = await client.getCode({ address })
	if (!code || code === '0x') return undefined
	return code
}

// ============================================================================
// Whatsabi - ABI extraction from bytecode
// ============================================================================

/**
 * Attempts to extract an ABI from contract bytecode using whatsabi.autoload.
 * Returns undefined if the address has no code or extraction fails.
 */
export async function extractContractAbi(
	address: Address.Address,
): Promise<Abi | undefined> {
	try {
		const client = getPublicClient(config)

		const result = await whatsabi.autoload(address, {
			provider: client,
			followProxies: true,
			// Disable ABI loader (requires Etherscan API key)
			abiLoader: false,
			signatureLookup: new whatsabi.loaders.MultiSignatureLookup([
				new whatsabi.loaders.OpenChainSignatureLookup(),
				new whatsabi.loaders.SamczunSignatureLookup(),
			]),
		})

		if (!result.abi || result.abi.length === 0) return undefined

		return result.abi as Abi
	} catch (error) {
		console.error('Failed to extract ABI:', error)
		return undefined
	}
}

```

## File: apps/explorer/src/lib/domain/known-events.ts
```
import { Address, Hex } from 'ox'
import { Abis, Addresses } from 'tempo.ts/viem'
import {
	type AbiEvent,
	decodeFunctionData,
	type Log,
	parseEventLogs,
	type TransactionReceipt,
	zeroAddress,
} from 'viem'
import type * as Tip20 from './tip20'

const abi = Object.values(Abis).flat()
const ZERO_ADDRESS = zeroAddress
const FEE_MANAGER = Addresses.feeManager
const STABLECOIN_EXCHANGE = Addresses.stablecoinExchange

type FeeTransferEvent = {
	amount: bigint
	token: Address.Address
	type: 'fee transfer'
}

export function isFeeTransferEvent(
	event: KnownEvent | FeeTransferEvent,
): event is FeeTransferEvent {
	return event.type === 'fee transfer'
}

type ParsedEvent = ReturnType<typeof parseEventLogs<typeof abi>>[number]

function createDetectors(
	createAmount: (value: bigint, token: Address.Address) => Amount,
	getTokenMetadata?: Tip20.GetTip20MetadataFn,
	mintBurnMemos?: Map<string, string>,
) {
	return {
		tip20(event: ParsedEvent) {
			const { eventName, args, address } = event

			if (eventName === 'Transfer' || eventName === 'TransferWithMemo')
				return Address.isEqual(args.to, FEE_MANAGER) &&
					!Address.isEqual(args.from, ZERO_ADDRESS)
					? {
							type: 'fee transfer',
							amount: args.amount,
							token: address,
						}
					: {
							type: 'send',
							note:
								'memo' in args
									? Hex.toString(Hex.trimLeft(args.memo))
									: undefined,
							parts: [
								{ type: 'action', value: 'Send' },
								{
									type: 'amount',
									value: createAmount(args.amount, address),
								},
								{ type: 'text', value: 'to' },
								{ type: 'account', value: args.to },
							],
							meta: { from: args.from, to: args.to },
						}

			if (eventName === 'Mint') {
				// Only handle TIP20 token mint, not liquidity pool mint
				if (Address.isEqual(address, FEE_MANAGER) || !('amount' in args))
					return null

				const { amount, to } = args as { amount: bigint; to: Address.Address }
				const mintKey = `mint:${address}:${amount}:${to}`
				const memo = mintBurnMemos?.get(mintKey)

				return {
					type: 'mint',
					note: memo,
					parts: [
						{ type: 'action', value: 'Mint' },
						{
							type: 'amount',
							value: createAmount(amount, address),
						},
						{ type: 'text', value: 'to' },
						{ type: 'account', value: to },
					],
				}
			}

			if (eventName === 'Burn') {
				if (!('amount' in args)) return null

				const { amount, from } = args as {
					amount: bigint
					from: Address.Address
				}
				const burnKey = `burn:${address}:${amount}:${from}`
				const memo = mintBurnMemos?.get(burnKey)

				return {
					type: 'burn',
					note: memo,
					parts: [
						{ type: 'action', value: 'Burn' },
						{
							type: 'amount',
							value: createAmount(amount, address),
						},
						{ type: 'text', value: 'from' },
						{ type: 'account', value: from },
					],
				}
			}

			if (eventName === 'RoleMembershipUpdated')
				return {
					type: args.hasRole ? 'grant role' : 'revoke role',
					parts: [
						{
							type: 'action',
							value: args.hasRole ? 'Grant Role' : 'Revoke Role',
						},
						{ type: 'hex', value: args.role },
						{ type: 'text', value: 'to' },
						{ type: 'account', value: args.account },
					],
				}

			if (eventName === 'PauseStateUpdate')
				return {
					type: args.isPaused ? 'pause' : 'unpause',
					parts: [
						{
							type: 'action',
							value: args.isPaused ? 'Pause Transfers' : 'Resume Transfers',
						},
						{ type: 'text', value: 'for' },
						{ type: 'token', value: { address } },
					],
				}

			if (eventName === 'SupplyCapUpdate') {
				const metadata = getTokenMetadata?.(address)
				return {
					type: 'supply cap update',
					parts: [
						{ type: 'action', value: 'Supply Cap Update' },
						{ type: 'text', value: 'for' },
						{
							type: 'token',
							value: { address, symbol: metadata?.symbol },
						},
					],
					note: [
						[
							'New',
							{
								type: 'number',
								value:
									metadata?.decimals === undefined
										? args.newSupplyCap
										: [args.newSupplyCap, metadata.decimals],
							},
						],
					],
				}
			}

			if (eventName === 'RewardScheduled') {
				const metadata = getTokenMetadata?.(address)
				return {
					type: 'reward scheduled',
					parts: [
						{ type: 'action', value: 'Reward Stream' },
						{ type: 'text', value: 'created for' },
						{
							type: 'token',
							value: { address, symbol: metadata?.symbol },
						},
					],
					note: [
						['ID', { type: 'text', value: String(args.id) }],
						['Funder', { type: 'account', value: args.funder }],
						[
							'Amount',
							{
								type: 'number',
								value:
									metadata?.decimals === undefined
										? args.amount
										: [args.amount, metadata.decimals],
							},
						],
						['Duration', { type: 'duration', value: args.durationSeconds }],
					],
				}
			}

			if (eventName === 'RewardCanceled') {
				const metadata = getTokenMetadata?.(address)
				return {
					type: 'reward canceled',
					parts: [
						{ type: 'action', value: 'Cancel Reward Stream' },
						{ type: 'text', value: 'for' },
						{
							type: 'token',
							value: { address, symbol: metadata?.symbol },
						},
					],
					note: [
						['ID', { type: 'text', value: String(args.id) }],
						['Funder', { type: 'account', value: args.funder }],
						[
							'Refund',
							{
								type: 'number',
								value:
									metadata?.decimals === undefined
										? args.refund
										: [args.refund, metadata.decimals],
							},
						],
					],
				}
			}

			if (eventName === 'RewardRecipientSet')
				return {
					type: 'reward recipient set',
					parts: [
						{ type: 'action', value: 'Set Reward Recipient' },
						{ type: 'account', value: args.recipient },
						{ type: 'text', value: 'for holder' },
						{ type: 'account', value: args.holder },
					],
				}

			if (eventName === 'Approval')
				return {
					type: 'approval',
					parts: [
						{ type: 'action', value: 'Approve' },
						{
							type: 'amount',
							value: createAmount(args.amount, address),
						},
						{ type: 'text', value: 'for spender' },
						{ type: 'account', value: args.spender },
					],
				}

			if (eventName === 'BurnBlocked')
				return {
					type: 'burn blocked',
					parts: [
						{ type: 'action', value: 'Burn Blocked' },
						{
							type: 'amount',
							value: createAmount(args.amount, address),
						},
						{ type: 'text', value: 'from' },
						{ type: 'account', value: args.from },
					],
				}

			if (eventName === 'TransferPolicyUpdate')
				return {
					type: 'transfer policy update',
					parts: [
						{ type: 'action', value: 'Update Transfer Policy' },
						{ type: 'text', value: `#${args.newPolicyId}` },
						{ type: 'text', value: 'for' },
						{ type: 'token', value: { address } },
					],
					note: [['Updater', { type: 'account', value: args.updater }]],
				}

			if (eventName === 'NextQuoteTokenSet') {
				const metadata = getTokenMetadata?.(address)
				return {
					type: 'next quote token set',
					parts: [
						{ type: 'action', value: 'Set Next Quote Token' },
						{ type: 'token', value: { address: args.nextQuoteToken } },
						{ type: 'text', value: 'for' },
						{
							type: 'token',
							value: { address, symbol: metadata?.symbol },
						},
					],
					note: [['Updater', { type: 'account', value: args.updater }]],
				}
			}

			if (eventName === 'QuoteTokenUpdate') {
				const metadata = getTokenMetadata?.(address)
				return {
					type: 'quote token update',
					parts: [
						{ type: 'action', value: 'Update Quote Token' },
						{ type: 'token', value: { address: args.newQuoteToken } },
						{ type: 'text', value: 'for' },
						{
							type: 'token',
							value: { address, symbol: metadata?.symbol },
						},
					],
					note: [['Updater', { type: 'account', value: args.updater }]],
				}
			}

			if (eventName === 'RoleAdminUpdated')
				return {
					type: 'role admin updated',
					parts: [
						{ type: 'action', value: 'Update Role Admin' },
						{ type: 'hex', value: args.role },
						{ type: 'text', value: 'to' },
						{ type: 'hex', value: args.newAdminRole },
					],
					note: [['Sender', { type: 'account', value: args.sender }]],
				}

			return null
		},

		tip20Factory(event: ParsedEvent) {
			const { eventName, args, address } = event

			if (eventName === 'TokenCreated')
				return {
					type: 'create token',
					parts: [
						{ type: 'action', value: 'Create Token' },
						{ type: 'token', value: { address, symbol: args.symbol } },
					],
				}

			return null
		},

		stablecoinExchange(event: ParsedEvent) {
			const { eventName, args, address } = event

			if (eventName === 'Mint')
				return !Address.isEqual(address, FEE_MANAGER) &&
					'amountUserToken' in args &&
					'amountValidatorToken' in args &&
					args.amountUserToken > 0n &&
					args.amountValidatorToken > 0n
					? {
							type: 'mint',
							parts: [
								{ type: 'action', value: 'Add Liquidity' },
								{
									type: 'amount',
									value: createAmount(args.amountUserToken, args.userToken),
								},
								{ type: 'text', value: 'and' },
								{
									type: 'amount',
									value: createAmount(
										args.amountValidatorToken,
										args.validatorToken,
									),
								},
							],
						}
					: null

			if (eventName === 'OrderPlaced')
				return {
					type: 'order placed',
					parts: [
						{ type: 'action', value: `Limit ${args.isBid ? 'Buy' : 'Sell'}` },
						{
							type: 'amount',
							value: createAmount(args.amount, args.token),
						},
						{ type: 'text', value: 'at tick' },
						{ type: 'tick', value: args.tick },
					],
				}

			if (eventName === 'FlipOrderPlaced')
				return {
					type: 'flip order placed',
					parts: [
						{ type: 'action', value: `Flip ${args.isBid ? 'Buy' : 'Sell'}` },
						{
							type: 'amount',
							value: createAmount(args.amount, args.token),
						},
						{ type: 'text', value: 'at tick' },
						{ type: 'tick', value: args.tick },
					],
				}

			if (eventName === 'OrderFilled')
				return {
					type: 'order filled',
					parts: [
						{
							type: 'action',
							value: args.partialFill ? 'Partial Fill' : 'Complete Fill',
						},
						{ type: 'text', value: String(args.amountFilled) },
					],
				}

			if (eventName === 'OrderCancelled')
				return {
					type: 'order cancelled',
					parts: [{ type: 'action', value: 'Cancel Order' }],
				}

			if (eventName === 'PairCreated')
				return {
					type: 'create pair',
					parts: [
						{ type: 'action', value: 'Create Pair' },
						{ type: 'token', value: { address: args.base } },
						{ type: 'text', value: '/' },
						{ type: 'token', value: { address: args.quote } },
					],
				}

			return null
		},

		tip403Registry(event: ParsedEvent) {
			const { eventName, args } = event

			if (eventName === 'WhitelistUpdated')
				return {
					type: 'whitelist',
					parts: [
						{ type: 'action', value: 'Whitelist' },
						{ type: 'account', value: args.account },
						{ type: 'text', value: 'on Policy' },
						{ type: 'text', value: `#${args.policyId}` },
					],
				}

			if (eventName === 'BlacklistUpdated')
				return {
					type: 'blacklist',
					parts: [
						{ type: 'action', value: 'Blacklist' },
						{ type: 'account', value: args.account },
						{ type: 'text', value: 'on Policy' },
						{ type: 'text', value: `#${args.policyId}` },
					],
				}

			if (eventName === 'PolicyAdminUpdated')
				return {
					type: 'policy admin updated',
					parts: [
						{ type: 'action', value: 'New Admin' },
						{ type: 'account', value: args.admin },
						{ type: 'text', value: 'on Policy' },
						{ type: 'text', value: `#${args.policyId}` },
					],
					note: [
						// ['Registry', { type: 'account', value: TODO }],
						['Updater', { type: 'account', value: args.updater }],
					],
				}

			if (eventName === 'PolicyCreated')
				return {
					type: 'policy created',
					parts: [
						{ type: 'action', value: 'Create Policy' },
						{ type: 'text', value: `#${args.policyId}` },
					],
				}

			return null
		},

		feeManager(event: ParsedEvent) {
			const { eventName, args } = event

			if (eventName === 'UserTokenSet')
				return {
					type: 'user token set',
					parts: [
						{ type: 'action', value: 'Set Fee Token' },
						{ type: 'token', value: { address: args.token } },
						{ type: 'text', value: 'for' },
						{ type: 'account', value: args.user },
					],
				}

			if (eventName === 'ValidatorTokenSet')
				return {
					type: 'validator token set',
					parts: [
						{ type: 'action', value: 'Set Fee Token' },
						{ type: 'token', value: { address: args.token } },
						{ type: 'text', value: 'for' },
						{ type: 'account', value: args.validator },
					],
				}

			return null
		},

		nonce(event: ParsedEvent) {
			const { eventName, args } = event

			if (eventName === 'NonceIncremented')
				return {
					type: 'nonce incremented',
					parts: [
						{ type: 'action', value: 'Increment Nonce' },
						{ type: 'account', value: args.account },
					],
					note: [
						['Key', { type: 'text', value: String(args.nonceKey) }],
						['New Nonce', { type: 'text', value: String(args.newNonce) }],
					],
				}

			if (eventName === 'ActiveKeyCountChanged')
				return {
					type: 'active key count changed',
					parts: [
						{ type: 'action', value: 'Key Count Changed' },
						{ type: 'account', value: args.account },
					],
					note: [['New Count', { type: 'text', value: String(args.newCount) }]],
				}

			return null
		},

		feeAmm(event: ParsedEvent) {
			const { eventName, args, address } = event

			if (eventName === 'Mint')
				return !Address.isEqual(address, FEE_MANAGER) &&
					'amountUserToken' in args &&
					'amountValidatorToken' in args
					? {
							type: 'mint',
							parts: [
								{ type: 'action', value: 'Add Liquidity' },
								{
									type: 'amount',
									value: createAmount(args.amountUserToken, args.userToken),
								},
								{ type: 'text', value: 'and' },
								{
									type: 'amount',
									value: createAmount(
										args.amountValidatorToken,
										args.validatorToken,
									),
								},
							],
						}
					: null

			if (eventName === 'Burn')
				return 'amountUserToken' in args && 'amountValidatorToken' in args
					? {
							type: 'burn',
							parts: [
								{ type: 'action', value: 'Remove Liquidity' },
								{
									type: 'amount',
									value: createAmount(args.amountUserToken, args.userToken),
								},
								{ type: 'text', value: 'and' },
								{
									type: 'amount',
									value: createAmount(
										args.amountValidatorToken,
										args.validatorToken,
									),
								},
							],
						}
					: null

			if (eventName === 'RebalanceSwap')
				return {
					type: 'rebalance swap',
					parts: [
						{ type: 'action', value: 'Rebalance Swap' },
						{
							type: 'amount',
							value: createAmount(args.amountIn, args.userToken),
						},
						{ type: 'text', value: 'for' },
						{
							type: 'amount',
							value: createAmount(args.amountOut, args.validatorToken),
						},
					],
				}

			if (eventName === 'FeeSwap')
				return {
					type: 'fee swap',
					parts: [
						{ type: 'action', value: 'Fee Swap' },
						{
							type: 'amount',
							value: createAmount(args.amountIn, args.userToken),
						},
						{ type: 'text', value: 'for' },
						{
							type: 'amount',
							value: createAmount(args.amountOut, args.validatorToken),
						},
					],
				}

			return null
		},
	} as const satisfies Record<
		string,
		(event: ParsedEvent) => KnownEvent | FeeTransferEvent | null
	>
}

type TransferEventArgs = {
	from: Address.Address
	to: Address.Address
	amount: bigint
}

function isTransferEvent(
	event: Log<bigint, number, boolean, AbiEvent>,
): event is Log<bigint, number, boolean, AbiEvent> & {
	eventName: 'Transfer' | 'TransferWithMemo'
	args: TransferEventArgs
	address: Address.Address
} {
	return (
		(event.eventName === 'Transfer' ||
			event.eventName === 'TransferWithMemo') &&
		'args' in event &&
		typeof event.args === 'object' &&
		event.args !== null &&
		'from' in event.args &&
		'to' in event.args &&
		'amount' in event.args &&
		typeof event.args.amount === 'bigint' &&
		typeof event.address === 'string'
	)
}

type Amount = {
	decimals?: number
	symbol?: string
	token: Address.Address
	value: bigint
}

type Token = {
	address: Address.Address
	symbol?: string
}

export type KnownEventPart =
	| { type: 'account'; value: Address.Address }
	| { type: 'action'; value: string }
	| { type: 'amount'; value: Amount }
	| { type: 'duration'; value: number } // in seconds
	| { type: 'hex'; value: Hex.Hex }
	| {
			type: 'number'
			value: bigint | number | [value: bigint, decimals: number]
	  }
	| { type: 'text'; value: string }
	| { type: 'tick'; value: number }
	| { type: 'token'; value: Token }

export interface KnownEvent {
	type: Exclude<string, FeeTransferEvent['type']>
	parts: KnownEventPart[]
	note?: string | Array<[label: string, value: KnownEventPart]>
	meta?: {
		from?: Address.Address
		to?: Address.Address
	}
}

type TransactionLike = {
	to?: Address.Address | null
	input?: Hex.Hex | null | undefined
	data?: Hex.Hex | null | undefined
	calls?:
		| readonly {
				to?: Address.Address | null
				input?: Hex.Hex | null | undefined
				data?: Hex.Hex | null | undefined
		  }[]
		| null
}

type FeeManagerAddLiquidityCall =
	| {
			functionName: 'mint'
			args: readonly [
				Address.Address,
				Address.Address,
				bigint,
				bigint,
				Address.Address,
			]
	  }
	| {
			functionName: 'mintWithValidatorToken'
			args: readonly [Address.Address, Address.Address, bigint, Address.Address]
	  }

export function parseKnownEvent(
	log: Log,
	options?: { getTokenMetadata?: Tip20.GetTip20MetadataFn },
): KnownEvent | null {
	const [event] = parseEventLogs({ abi, logs: [log] })
	if (!event) return null

	const getTokenMetadata = options?.getTokenMetadata

	const createAmount = (value: bigint, token: Address.Address): Amount => {
		const metadata = getTokenMetadata?.(token)
		const amount: Amount = { token, value }
		if (metadata) {
			amount.decimals = metadata.decimals
			amount.symbol = metadata.symbol
		}
		return amount
	}

	const detectors = createDetectors(createAmount, getTokenMetadata)

	const detected =
		detectors.tip20(event) ||
		detectors.tip20Factory(event) ||
		detectors.stablecoinExchange(event) ||
		detectors.tip403Registry(event) ||
		detectors.feeManager(event) ||
		detectors.nonce(event) ||
		detectors.feeAmm(event)

	if (!detected || isFeeTransferEvent(detected)) return null
	return detected
}

// e.g. for TxEventDescription.ExpandGroup's limitFilter
export function preferredEventsFilter(event: KnownEvent): boolean {
	return (
		event.type !== 'active key count changed' &&
		event.type !== 'nonce incremented'
	)
}

export function parseKnownEvents(
	receipt: TransactionReceipt,
	options?: {
		transaction?: TransactionLike
		getTokenMetadata?: Tip20.GetTip20MetadataFn
	},
): KnownEvent[] {
	const { logs } = receipt
	const events = parseEventLogs({ abi, logs })
	const getTokenMetadata = options?.getTokenMetadata

	const createAmount = (value: bigint, token: Address.Address): Amount => {
		const metadata = getTokenMetadata?.(token)
		const amount: Amount = { token, value }
		if (metadata) {
			amount.decimals = metadata.decimals
			amount.symbol = metadata.symbol
		}
		return amount
	}

	const feeManagerCall: FeeManagerAddLiquidityCall | undefined = (() => {
		const transaction = options?.transaction
		if (!transaction) return

		const queue: TransactionLike[] = [transaction]

		while (queue.length > 0) {
			const call = queue.shift()
			if (!call) break

			const callTarget = call.to
			const callInput = call.input ?? call.data

			if (callTarget && callInput && Address.isEqual(callTarget, FEE_MANAGER))
				try {
					const decoded = decodeFunctionData({
						abi: Abis.feeAmm,
						data: callInput,
					})

					/**
					 * @note
					 * `Transfer` logs alone can't distinguish "Add Liquidity" from fee collection,
					 * since both send tokens to the `FeeManager`. Decoding `calldata` is the only way
					 * to catch explicit user mints. If the `FeeManager` starts emitting a dedicated event,
					 * we can revisit this and simplify the logic.
					 */
					if (
						decoded.functionName === 'mint' ||
						decoded.functionName === 'mintWithValidatorToken'
					)
						return decoded
				} catch {
					// fall through and continue searching other calls
				}

			if (call.calls) queue.push(...call.calls)
		}
	})()

	const preferenceMap = new Map<string, string>()
	const feeTransferEvents: Array<{
		amount: bigint
		token: Address.Address
	}> = []

	// Map to store memos from TransferWithMemo events that pair with Mint/Burn
	// Key format: `${token}:${amount}:${address}` where address is `to` for Mint, `from` for Burn
	const mintBurnMemos = new Map<string, string>()

	for (const event of events) {
		let key: string | undefined

		// `TransferWithMemo` and `Transfer` events are paired with each other,
		// we will need to take preference on `TransferWithMemo` for those instances.
		if (event.eventName === 'TransferWithMemo') {
			const [_, from, to] = event.topics
			key = `${from}${to}`
		}

		// `Mint` and `Transfer`/`TransferWithMemo` events are paired with each other,
		// we will need to take preference on `Mint` for those instances.
		if (event.eventName === 'Mint' && 'amount' in event.args) {
			const { amount, to } = event.args as {
				amount: bigint
				to: Address.Address
			}
			key = `mint:${event.address}:${amount}:${to}`
		}

		// `Burn` and `Transfer`/`TransferWithMemo` events are paired with each other,
		// we will need to take preference on `Burn` for those instances.
		if (event.eventName === 'Burn' && 'amount' in event.args) {
			const { amount, from } = event.args as {
				amount: bigint
				from: Address.Address
			}
			key = `burn:${event.address}:${amount}:${from}`
		}

		if (key) preferenceMap.set(key, event.eventName)
	}

	// Second pass: collect memos from TransferWithMemo events that pair with Mint/Burn
	for (const event of events) {
		if (event.eventName === 'TransferWithMemo' && 'memo' in event.args) {
			const { from, to, amount, memo } = event.args as {
				from: Address.Address
				to: Address.Address
				amount: bigint
				memo: Hex.Hex
			}
			const memoText = Hex.toString(Hex.trimLeft(memo))
			if (!memoText) continue

			// Check if this pairs with a Mint (transfer from zero address)
			if (Address.isEqual(from, ZERO_ADDRESS)) {
				const mintKey = `mint:${event.address}:${amount}:${to}`
				if (preferenceMap.get(mintKey) === 'Mint') {
					mintBurnMemos.set(mintKey, memoText)
				}
			}

			// Check if this pairs with a Burn (transfer to zero address)
			if (Address.isEqual(to, ZERO_ADDRESS)) {
				const burnKey = `burn:${event.address}:${amount}:${from}`
				if (preferenceMap.get(burnKey) === 'Burn') {
					mintBurnMemos.set(burnKey, memoText)
				}
			}
		}
	}

	// Create detectors after mintBurnMemos is populated so they can access the memos
	const detectors = createDetectors(
		createAmount,
		getTokenMetadata,
		mintBurnMemos,
	)

	const dedupedEvents = events.filter((event) => {
		let include = true

		if (event.eventName === 'Transfer') {
			{
				// Check TransferWithMemo dedup
				const [_, from, to] = event.topics
				const key = `${from}${to}`
				if (preferenceMap.get(key)?.includes('TransferWithMemo'))
					include = false
			}
			// Check Mint dedup (transfer from zero address)
			if (
				'args' in event &&
				typeof event.args === 'object' &&
				event.args !== null
			) {
				const { from, to, amount } = event.args as {
					from: Address.Address
					to: Address.Address
					amount: bigint
				}
				if (Address.isEqual(from, ZERO_ADDRESS)) {
					const mintKey = `mint:${event.address}:${amount}:${to}`
					if (preferenceMap.get(mintKey) === 'Mint') include = false
				}
			}
			// Check Burn dedup (transfer to zero address)
			if (
				'args' in event &&
				typeof event.args === 'object' &&
				event.args !== null
			) {
				const { from, to, amount } = event.args as {
					from: Address.Address
					to: Address.Address
					amount: bigint
				}
				if (Address.isEqual(to, ZERO_ADDRESS)) {
					const burnKey = `burn:${event.address}:${amount}:${from}`
					if (preferenceMap.get(burnKey) === 'Burn') include = false
				}
			}
		}

		// Also filter out TransferWithMemo events that pair with Mint/Burn
		if (event.eventName === 'TransferWithMemo') {
			if (
				'args' in event &&
				typeof event.args === 'object' &&
				event.args !== null
			) {
				const { from, to, amount } = event.args as {
					from: Address.Address
					to: Address.Address
					amount: bigint
				}

				// Check Mint dedup (transfer from zero address)
				if (Address.isEqual(from, ZERO_ADDRESS)) {
					const mintKey = `mint:${event.address}:${amount}:${to}`
					if (preferenceMap.get(mintKey) === 'Mint') include = false
				}

				// Check Burn dedup (transfer to zero address)
				if (Address.isEqual(to, ZERO_ADDRESS)) {
					const burnKey = `burn:${event.address}:${amount}:${from}`
					if (preferenceMap.get(burnKey) === 'Burn') include = false
				}
			}
		}

		return include
	})

	const knownEvents: KnownEvent[] = []

	if (
		feeManagerCall &&
		(feeManagerCall.functionName === 'mint' ||
			feeManagerCall.functionName === 'mintWithValidatorToken')
	) {
		const {
			userToken,
			validatorToken,
			amountUserToken,
			amountValidatorToken,
		}: {
			userToken: Address.Address
			validatorToken: Address.Address
			amountUserToken: bigint
			amountValidatorToken: bigint
		} =
			feeManagerCall.functionName === 'mint'
				? {
						userToken: feeManagerCall.args[0],
						validatorToken: feeManagerCall.args[1],
						amountUserToken: feeManagerCall.args[2],
						amountValidatorToken: feeManagerCall.args[3],
					}
				: {
						userToken: feeManagerCall.args[0],
						validatorToken: feeManagerCall.args[1],
						amountUserToken: 0n,
						amountValidatorToken: feeManagerCall.args[2],
					}

		const parts: KnownEventPart[] = [
			{ type: 'action', value: 'Add Liquidity' },
			{
				type: 'amount',
				value: createAmount(amountUserToken, userToken),
			},
			{ type: 'text', value: 'and' },
			{
				type: 'amount',
				value: createAmount(amountValidatorToken, validatorToken),
			},
		]

		knownEvents.push({
			type: 'mint',
			parts,
		})
	}

	// Detect and group swap events (two transfers involving the stablecoin exchange)
	const swapIndices = new Set<number>()

	// Find all transfers in the events
	const transferEvents = dedupedEvents
		.map((event, index) => ({ event, index }))
		.filter(({ event }) => isTransferEvent(event))
		.map(({ event, index }) => ({
			event: event as typeof event & {
				eventName: 'Transfer' | 'TransferWithMemo'
				args: TransferEventArgs
			},
			index,
		}))

	// Look for swap pairs (transfer TO exchange + transfer FROM exchange)
	for (let index = 0; index < transferEvents.length - 1; index++) {
		const { event: event1, index: idx1 } = transferEvents[index]
		// Type assertion is safe here because isTransferEvent has validated the structure
		const args1 = event1.args
		const to1 = args1.to

		// If this is a transfer TO the exchange, look for a matching transfer FROM the exchange
		if (Address.isEqual(to1, STABLECOIN_EXCHANGE)) {
			for (
				let innerIndex = index + 1;
				innerIndex < transferEvents.length;
				innerIndex++
			) {
				const { event: event2, index: idx2 } = transferEvents[innerIndex]
				const args2 = event2.args
				const from2 = args2.from

				if (Address.isEqual(from2, STABLECOIN_EXCHANGE)) {
					// This is a swap - create a single swap event
					knownEvents.push({
						type: 'swap',
						parts: [
							{ type: 'action', value: 'Swap' },
							{
								type: 'amount',
								value: createAmount(args1.amount, event1.address),
							},
							{ type: 'text', value: 'for' },
							{
								type: 'amount',
								value: createAmount(args2.amount, event2.address),
							},
						],
					})

					// Mark these events as processed
					swapIndices.add(idx1)
					swapIndices.add(idx2)
					break // Found the matching pair, move to next transfer
				}
			}
		}
	}

	// Map log events to known events.
	for (let index = 0; index < dedupedEvents.length; index++) {
		// Skip events that are part of a swap
		if (swapIndices.has(index)) continue

		const event = dedupedEvents[index]

		const detected =
			detectors.tip20(event) ||
			detectors.tip20Factory(event) ||
			detectors.stablecoinExchange(event) ||
			detectors.tip403Registry(event) ||
			detectors.feeManager(event) ||
			detectors.nonce(event) ||
			detectors.feeAmm(event)

		if (!detected) continue

		if (isFeeTransferEvent(detected)) {
			feeTransferEvents.push(detected)
			continue
		}

		knownEvents.push(detected)
	}

	// If no known events were parsed but there was a fee transfer,
	// show it as a fee payment event
	if (knownEvents.length === 0 && feeTransferEvents.length > 0) {
		const parts: KnownEventPart[] = [{ type: 'action', value: 'Pay Fee' }]

		for (const [index, fee] of feeTransferEvents.entries()) {
			if (index > 0) parts.push({ type: 'text', value: 'and' })
			parts.push({
				type: 'amount',
				value: createAmount(fee.amount, fee.token),
			})
		}

		knownEvents.push({
			type: 'fee',
			parts,
		})
	}

	return knownEvents
}

```

## File: apps/explorer/src/lib/domain/receipt.ts
```
import { Address, Hex } from 'ox'
import { TokenRole } from 'tempo.ts/ox'
import { Abis, Addresses } from 'tempo.ts/viem'
import {
	type AbiEvent,
	type Log,
	parseEventLogs,
	type TransactionReceipt,
	zeroAddress,
} from 'viem'
import type * as Tip20 from '#lib/domain/tip20'
import { HexFormatter, PriceFormatter } from '#lib/formatting'

const abi = Object.values(Abis).flat()

export type FeeBreakdownItem = {
	amount: bigint
	currency: string
	decimals: number
	symbol?: string
	token?: Address.Address
	payer?: Address.Address
}

export function getFeeBreakdown(
	receipt: TransactionReceipt,
	{ getTokenMetadata }: { getTokenMetadata: Tip20.GetTip20MetadataFn },
): FeeBreakdownItem[] {
	const { logs } = receipt

	const events = parseEventLogs({ abi, logs })
	const feeBreakdown: FeeBreakdownItem[] = []

	for (const event of events) {
		if (
			event.eventName !== 'Transfer' &&
			event.eventName !== 'TransferWithMemo'
		)
			continue

		const { amount, from, to } = event.args
		const token = event.address

		const isFee =
			Address.isEqual(to, Addresses.feeManager) &&
			!Address.isEqual(from, zeroAddress)

		if (!isFee) continue

		const metadata = getTokenMetadata(token)
		if (!metadata) continue

		const { currency, decimals, symbol } = metadata

		feeBreakdown.push({
			amount,
			currency,
			decimals,
			symbol,
			token,
			payer: Address.checksum(from),
		})
	}

	return feeBreakdown
}

export namespace LineItems {
	export type Result = {
		main: LineItem.LineItem[]
		feeTotals: LineItem.LineItem[]
		totals: LineItem.LineItem[]
		feeBreakdown: LineItem.FeeBreakdownItem[]
	}

	export function fromReceipt(
		receipt: TransactionReceipt,
		{ getTokenMetadata }: { getTokenMetadata: Tip20.GetTip20MetadataFn },
	) {
		const { from: sender, logs } = receipt
		const senderChecksum = Address.checksum(sender)

		// Extract all of the event logs we can from the receipt.
		const events = parseEventLogs({
			abi,
			logs,
		})

		////////////////////////////////////////////////////////////

		const preferenceMap = new Map<string, string>()

		for (const event of events) {
			let key: string | undefined

			// `TransferWithMemo` and `Transfer` events are paired with each other,
			// we will need to take preference on `TransferWithMemo` for those instances.
			if (event.eventName === 'TransferWithMemo') {
				const [_, from, to] = event.topics
				key = `${from}${to}`
			}

			// `Mint` and `Transfer` events are paired with each other,
			// we will need to take preference on `Mint` for those instances.
			if (event.eventName === 'Mint') {
				const [_, to] = event.topics
				key = `${event.address}${event.data}${to}`
			}

			// `Burn` and `Transfer` events are paired with each other,
			// we will need to take preference on `Burn` for those instances.
			if (event.eventName === 'Burn') {
				const [_, from] = event.topics
				key = `${event.address}${event.data}${from}`
			}

			if (key) preferenceMap.set(key, event.eventName)
		}

		const dedupedEvents = events.filter((event) => {
			let include = true

			if (event.eventName === 'Transfer') {
				{
					// Check TransferWithMemo dedup
					const [_, from, to] = event.topics
					const key = `${from}${to}`
					if (preferenceMap.get(key)?.includes('TransferWithMemo'))
						include = false
				}

				{
					// Check Mint dedup
					const [_, __, to] = event.topics
					const key = `${event.address}${event.data}${to}`
					if (preferenceMap.get(key)?.includes('Mint')) include = false
				}

				{
					// Check Burn dedup
					const [_, from] = event.topics
					const key = `${event.address}${event.data}${from}`
					if (preferenceMap.get(key)?.includes('Burn')) include = false
				}
			}

			return include
		})

		////////////////////////////////////////////////////////////

		const items: Result = {
			main: [],
			feeTotals: [],
			totals: [],
			feeBreakdown: [],
		}
		const feeEvents: LineItem.LineItem[] = []

		// Map log events to receipt line items.
		for (const event of dedupedEvents) {
			switch (event.eventName) {
				case 'Burn': {
					if ('amount' in event.args) {
						const { amount, from } = event.args

						const metadata = getTokenMetadata(event.address)
						if (!metadata) {
							items.main.push(LineItem.noop(event))
							break
						}

						const { currency, decimals, symbol } = metadata

						const isSelf = Address.isEqual(from, sender)

						items.main.push(
							LineItem.from({
								event,
								price: isSelf
									? {
											amount,
											currency,
											decimals,
											symbol,
											token: event.address,
										}
									: undefined,
								ui: {
									bottom: [
										{
											left: `From: ${HexFormatter.truncate(from)}`,
										},
									],
									left: `Burn ${symbol}`,
									right: decimals
										? PriceFormatter.format(amount, decimals)
										: '-',
								},
							}),
						)
						break
					}

					items.main.push(LineItem.noop(event))
					break
				}

				case 'RoleMembershipUpdated': {
					const { account, hasRole, role } = event.args

					const roleName =
						TokenRole.roles.find((r) => TokenRole.serialize(r) === role) ??
						undefined

					items.main.push(
						LineItem.from({
							event,
							position: 'main',
							ui: {
								bottom: [
									{
										left: `To: ${HexFormatter.truncate(account)}`,
									},
									{
										left: `Role: ${roleName}`,
									},
								],
								left: `${roleName ? `${roleName} ` : ' '}Role ${hasRole ? 'Granted' : 'Revoked'}`,
								right: '-',
							},
						}),
					)
					break
				}

				case 'Mint': {
					if ('amount' in event.args) {
						const metadata = getTokenMetadata(event.address)
						if (!metadata) {
							items.main.push(LineItem.noop(event))
							break
						}

						const { decimals } = metadata
						const { amount, to } = event.args

						items.main.push(
							LineItem.from({
								event,
								ui: {
									bottom: [
										{
											left: `To: ${HexFormatter.truncate(to)}`,
										},
									],
									left: `Mint ${metadata?.symbol ? ` ${metadata.symbol}` : ''}`,
									right: decimals
										? `(${PriceFormatter.format(amount, decimals)})`
										: '',
								},
							}),
						)
						break
					}

					items.main.push(LineItem.noop(event))
					break
				}

				case 'TokenCreated': {
					const { symbol } = event.args
					items.main.push(
						LineItem.from({
							event,
							ui: {
								left: `Create Token (${symbol})`,
								right: '-',
							},
						}),
					)
					break
				}

				case 'TransferWithMemo':
				case 'Transfer': {
					const { amount, from, to } = event.args
					const token = event.address

					const metadata = getTokenMetadata(token)
					if (!metadata) {
						items.main.push(LineItem.noop(event))
						break
					}

					const isCredit = Address.isEqual(to, sender)
					const memo =
						'memo' in event.args
							? Hex.toString(Hex.trimLeft(event.args.memo))
							: undefined

					const { currency, decimals, symbol } = metadata

					const isFee =
						Address.isEqual(to, Addresses.feeManager) &&
						!Address.isEqual(from, zeroAddress)

					if (isFee) {
						const feePayer = !Address.isEqual(from, senderChecksum) ? from : ''

						const feeLineItem = LineItem.from({
							event,
							isFee,
							price: {
								amount,
								currency,
								decimals,
								symbol,
								token,
							},
							ui: {
								left: `${symbol} ${feePayer ? `(PAID BY ${HexFormatter.truncate(feePayer)})` : ''}`,
								right: decimals ? PriceFormatter.format(amount, decimals) : '-',
							},
						})
						feeEvents.push(feeLineItem)
						items.feeBreakdown.push({
							amount,
							currency,
							decimals,
							symbol,
							token,
							payer: Address.checksum(from),
						})
						break
					}

					items.main.push(
						LineItem.from({
							event,
							price: {
								amount: isCredit ? -amount : amount,
								currency,
								decimals,
								symbol,
								token,
							},
							ui: {
								bottom: [...(memo ? [{ left: `Memo: ${memo}` }] : [])],
								left: `Send ${symbol} ${to ? `to ${HexFormatter.truncate(to)}` : ''}`,
								right: decimals
									? PriceFormatter.format(isCredit ? -amount : amount, decimals)
									: '-',
							},
						}),
					)
					break
				}

				default: {
					items.main.push(LineItem.noop(event))
				}
			}
		}

		////////////////////////////////////////////////////////////

		// Calculate fee totals grouped by currency -> symbol
		type Currency = string
		type Symbol = string
		const feeTotals = new Map<
			Currency,
			{
				amount: bigint
				decimals: number
				tokens: Map<Symbol, LineItem.LineItem['price']>
			}
		>()
		for (const item of feeEvents) {
			if (!item.isFee) continue

			const { price } = item
			if (!price) continue

			const { amount, currency, decimals, symbol, token } = price
			if (!currency) continue
			if (!decimals) continue
			if (!symbol) continue

			let currencyMap = feeTotals.get(currency)
			currencyMap ??= {
				amount: 0n,
				decimals,
				tokens: new Map(),
			}

			const existing = currencyMap.tokens.get(symbol)
			if (existing) existing.amount += amount
			else currencyMap.tokens.set(symbol, { amount, currency, decimals, token })

			currencyMap.amount += amount

			feeTotals.set(currency, currencyMap)
		}

		// Add fee totals to line items
		for (const [currency, { amount, decimals }] of feeTotals)
			items.feeTotals.push(
				LineItem.from({
					position: 'end',
					price: {
						amount,
						decimals,
						currency,
					},
					ui: {
						left: 'Fee',
						right: decimals
							? PriceFormatter.format(amount, { decimals, format: 'short' })
							: '-',
					},
				}),
			)

		// Calculate totals grouped by currency
		const totals = new Map<string, LineItem.LineItem['price']>()
		for (const item of [...items.main, ...items.feeTotals]) {
			if (!('price' in item)) continue

			const { price } = item
			if (!price) continue

			const existing = totals.get(price.currency)
			if (existing) existing.amount += price.amount
			else totals.set(price.currency, price)
		}

		// Add totals to line items
		for (const [_, price] of totals) {
			if (!price) continue
			const { amount, decimals } = price
			const formatted = decimals
				? PriceFormatter.format(amount, { decimals, format: 'short' })
				: '-'
			items.totals.push(
				LineItem.from({
					price,
					ui: {
						left: 'Total',
						right: formatted,
					},
				}),
			)
		}

		return items
	}
}

export namespace LineItem {
	export type LineItem = {
		/**
		 * Event log emitted.
		 */
		event?: Log<bigint, number, boolean, AbiEvent> | undefined
		/**
		 * Whether the line item is a fee item.
		 */
		isFee?: boolean | undefined
		/**
		 * Grouping key.
		 */
		key?: string | undefined
		/**
		 * Price of the line item.
		 */
		price?:
			| {
					/**
					 * Amount in units of the token.
					 */
					amount: bigint
					/**
					 * Currency of the token.
					 */
					currency: string
					/**
					 * Decimals of the token.
					 */
					decimals: number
					/**
					 * Symbol of the token.
					 */
					symbol?: string | undefined
					/**
					 * Address of the TIP20 token.
					 */
					token?: Address.Address | undefined
			  }
			| undefined
		/**
		 * UI data of the line item.
		 */
		ui: {
			/**
			 * Bottom data of the line item.
			 */
			bottom?:
				| {
						/**
						 * Left text of the line item.
						 */
						left: string
						/**
						 * Right text of the line item.
						 */
						right?: string | undefined
				  }[]
				| undefined
			/**
			 * Left text of the line item.
			 */
			left: string
			/**
			 * Right text of the line item.
			 */
			right: string
		}
	}

	export type FeeBreakdownItem = {
		amount: bigint
		currency: string
		decimals: number
		symbol?: string
		token?: Address.Address
		payer?: Address.Address
	}

	export function from<const item extends LineItem>(
		item: item,
	): item & {
		eventName: item['event'] extends { eventName: infer eventName }
			? eventName
			: undefined
	} {
		return {
			...item,
			eventName: item.event?.eventName,
		} as never
	}

	export function noop(event: Log<bigint, number, boolean, AbiEvent>) {
		return LineItem.from({
			event,
			position: 'main',
			ui: {
				left: event.eventName,
				right: '-',
			},
		})
	}
}

```

## File: apps/explorer/src/lib/domain/tip20.ts
```
import type { Address } from 'ox'
import { Abis } from 'tempo.ts/viem'
import { Actions } from 'tempo.ts/wagmi'
import { type Log, parseEventLogs } from 'viem'
import { config } from '#wagmi.config'

const abi = Object.values(Abis).flat()

const tip20Prefix = '0x20c000000'
export type Tip20Address = `${typeof tip20Prefix}${string}`
export function isTip20Address(address: string): address is Tip20Address {
	return address.toLowerCase().startsWith(tip20Prefix)
}

export type Metadata = Actions.token.getMetadata.ReturnValue

export type GetTip20MetadataFn = (
	address: Address.Address,
) => Metadata | undefined

export async function metadataFromLogs(
	logs: Log[],
): Promise<GetTip20MetadataFn> {
	const events = parseEventLogs({ abi, logs })

	const tip20Addresses = events
		.map(({ address }) => address)
		.filter(isTip20Address)

	const metadataResults = await Promise.all(
		tip20Addresses.map((token) => Actions.token.getMetadata(config, { token })),
	)
	const map = new Map<string, Metadata>()
	for (const [index, address] of tip20Addresses.entries())
		map.set(address.toLowerCase(), metadataResults[index])

	return (address: Address.Address) => map.get(address.toLowerCase())
}

```

## File: apps/explorer/src/lib/formatting.ts
```
import { type Hex, Value } from 'ox'

export namespace HexFormatter {
	export function truncate(value: Hex.Hex, chars = 4) {
		return value.length < chars * 2 + 2
			? value
			: `${value.slice(0, chars + 2)}…${value.slice(-chars)}`
	}

	// shorten a hex to look like 0x1234…5678
	export function shortenHex(hex: Hex.Hex, chars: number = 4) {
		return hex.length < chars * 2 + 2
			? hex
			: `${hex.slice(0, chars + 2)}…${hex.slice(-chars)}`
	}
}

export namespace DateFormatter {
	/**
	 * Formats a timestamp to a localized date-time string.
	 *
	 * @param timestamp - The timestamp in seconds.
	 * @returns The formatted date-time string.
	 */
	export function format(timestamp: bigint) {
		return new Date(Number(timestamp) * 1000).toLocaleString(undefined, {
			year: 'numeric',
			month: '2-digit',
			day: '2-digit',
			hour: '2-digit',
			minute: '2-digit',
		})
	}

	const dateFormatter = new Intl.DateTimeFormat('en-US', {
		year: 'numeric',
		month: '2-digit',
		day: '2-digit',
	})

	const timeFormatter = new Intl.DateTimeFormat('en-US', {
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit',
		hour12: false,
	})

	const timezoneFormatter = new Intl.DateTimeFormat('en-US', {
		timeZoneName: 'shortOffset',
	})

	/**
	 * Formats a timestamp to a UTC date-time string.
	 *
	 * @param timestamp - The timestamp in seconds.
	 * @returns The formatted UTC date-time string.
	 */
	const utcFormatter = new Intl.DateTimeFormat('en-US', {
		year: '2-digit',
		month: '2-digit',
		day: '2-digit',
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit',
		hour12: false,
		timeZone: 'UTC',
	})

	export function formatUtcTimestamp(timestamp: bigint) {
		return utcFormatter.format(new Date(Number(timestamp) * 1_000))
	}

	export function formatTimestampDate(timestamp: bigint): string {
		return dateFormatter.format(new Date(Number(timestamp) * 1000))
	}

	export function formatTimestampTime(timestamp: bigint): {
		time: string
		timezone: string
		offset: string
	} {
		const date = new Date(Number(timestamp) * 1000)

		const parts = timezoneFormatter.formatToParts(date)
		const timeZonePart =
			parts.find((p) => p.type === 'timeZoneName')?.value || 'GMT+0'

		const signIndex = Math.max(
			timeZonePart.indexOf('+'),
			timeZonePart.indexOf('-'),
		)
		const timezone = signIndex > 0 ? timeZonePart.slice(0, signIndex) : 'GMT'
		const offset = signIndex > 0 ? timeZonePart.slice(signIndex) : '+0'

		return { time: timeFormatter.format(date), timezone, offset }
	}

	const relativeTimeFormatter = new Intl.RelativeTimeFormat('en-US', {
		numeric: 'auto',
		style: 'narrow',
	})

	export function formatRelativeTime(timestamp: bigint): {
		text: string
		fullDate: string
	} {
		const date = new Date(Number(timestamp) * 1_000)
		const now = new Date()
		const diffMs = now.getTime() - date.getTime()
		const diffSec = Math.floor(diffMs / 1000)
		const diffMin = Math.floor(diffSec / 60)
		const diffHour = Math.floor(diffMin / 60)
		const diffDay = Math.floor(diffHour / 24)

		const fullDate = date.toLocaleString()
		const rtf = relativeTimeFormatter
		if (diffSec < 60) return { fullDate, text: rtf.format(-diffSec, 'second') }
		if (diffMin < 60) return { fullDate, text: rtf.format(-diffMin, 'minute') }
		if (diffHour < 24) return { fullDate, text: rtf.format(-diffHour, 'hour') }
		return { text: rtf.format(-diffDay, 'day'), fullDate }
	}

	export function formatDuration(seconds: number): string {
		const days = Math.floor(seconds / 86400)
		const hrs = Math.floor((seconds % 86400) / 3600)
		const mins = Math.floor((seconds % 3600) / 60)
		const secs = seconds % 60

		const parts = []
		if (days > 0) parts.push(`${days} day${days > 1 ? 's' : ''}`)
		if (hrs > 0) parts.push(`${hrs}h`)
		if (mins > 0) parts.push(`${mins}m`)
		if (secs > 0 || parts.length === 0) parts.push(`${secs}s`)

		return parts.join(' ')
	}
}

export namespace PriceFormatter {
	/**
	 * Formats a number or bigint to a currency-formatted string.
	 *
	 * @param value - The number or bigint to format.
	 * @returns The formatted string.
	 */
	export function format(
		value: number | bigint,
		decimalsOrOptions?:
			| number
			| {
					decimals?: number
					format?: 'short' | 'full'
			  },
	) {
		const options =
			typeof decimalsOrOptions === 'number'
				? { decimals: decimalsOrOptions }
				: (decimalsOrOptions ?? {})

		options.format ??= 'full'
		options.decimals ??= 0

		const normalizedValue =
			typeof value === 'number'
				? value
				: Number(Value.format(BigInt(value), options.decimals))

		if (normalizedValue > 0 && normalizedValue < 0.01) return '<$0.01'

		const formatter = options.format === 'short' ? numberIntlShort : numberIntl

		return formatter.format(normalizedValue)
	}

	/** @internal */
	const numberIntlShort = new Intl.NumberFormat('en-US', {
		notation: 'compact',
		minimumFractionDigits: 0,
		maximumFractionDigits: 2,
		currency: 'USD',
		style: 'currency',
	})

	/** @internal */
	const numberIntl = new Intl.NumberFormat('en-US', {
		notation: 'standard',
		minimumFractionDigits: 0,
		maximumFractionDigits: 2,
		currency: 'USD',
		style: 'currency',
	})

	const amountFormatter = new Intl.NumberFormat('en-US', {
		minimumFractionDigits: 0,
		maximumFractionDigits: 18,
	})

	const amountFormatterShort = new Intl.NumberFormat('en-US', {
		notation: 'compact',
		minimumFractionDigits: 0,
		maximumFractionDigits: 2,
	})

	export function formatAmount(value: string): string {
		const number = Number(value)
		if (number > 0 && number < 0.01) return '<0.01'
		return amountFormatter.format(number)
	}

	export function formatAmountShort(value: string): string {
		const number = Number(value)
		if (number > 0 && number < 0.01) return '<0.01'
		return amountFormatterShort.format(number)
	}

	export function formatNativeAmount(
		value: bigint | undefined,
		decimals: number,
		symbol: string,
	) {
		if (value === undefined) return '—'
		const decimalString = Value.format(value, decimals)
		const formatted = PriceFormatter.formatAmount(decimalString)
		return `${formatted} ${symbol}`
	}
	export function formatGasValue(value?: bigint, digits = 9) {
		if (value === undefined) return '—'
		const string = value.toString()
		return string.length >= digits ? string : string.padStart(digits, '0')
	}
}

export namespace NumberFormatter {
	export function formatBlockNumber(value?: bigint) {
		if (!value) return '—'
		const base = value.toString()
		return base.padStart(12, '0')
	}
}

```

## File: apps/explorer/src/lib/hooks.ts
```
import * as React from 'react'

export function useCopy(props: useCopy.Props = { timeout: 800 }) {
	const { timeout } = props

	const [notifying, setNotifying] = React.useState(false)
	const timer = React.useRef<ReturnType<typeof setTimeout> | null>(null)

	const copy: useCopy.Result['copy'] = React.useCallback(
		async (value: string) => {
			if (timer.current) clearTimeout(timer.current)
			try {
				if (!navigator.clipboard) throw new Error('Clipboard API not supported')
				await navigator.clipboard.writeText(value)
				setNotifying(true)
				timer.current = setTimeout(() => setNotifying(false), timeout)
			} catch (error) {
				console.error('Failed to copy text: ', error)
			}
		},
		[timeout],
	)

	return { copy, notifying }
}

export declare namespace useCopy {
	type Props = {
		timeout?: number | undefined
	}

	type Result = {
		copy: (value: string) => Promise<void>
		notifying: boolean
	}
}

export function useMediaQuery(query: string) {
	// Use null to indicate "unknown" state during SSR
	const [matches, setMatches] = React.useState<boolean | null>(null)

	React.useEffect(() => {
		const mediaQuery = window.matchMedia(query)
		setMatches(mediaQuery.matches)

		const handler = (e: MediaQueryListEvent) => setMatches(e.matches)
		mediaQuery.addEventListener('change', handler)
		return () => mediaQuery.removeEventListener('change', handler)
	}, [query])

	// Return false during SSR/initial render to ensure consistent hydration
	return matches ?? false
}

```

## File: apps/explorer/src/lib/queries/account.ts
```
import { keepPreviousData, queryOptions } from '@tanstack/react-query'
import type { Address } from 'ox'
import * as AccountServer from '#lib/server/account.server.ts'

export type TransactionQueryParams = {
	address: Address.Address
	page: number
	limit: number
	offset: number
	_key?: string | undefined
}

export function transactionsQueryOptions(params: TransactionQueryParams) {
	return queryOptions({
		queryKey: [
			'account-transactions',
			params.address,
			params.page,
			params.limit,
			params._key,
		],
		queryFn: () =>
			AccountServer.fetchTransactions({
				data: {
					address: params.address,
					offset: params.offset,
					limit: params.limit,
				},
			}),
		refetchInterval: false,
		refetchIntervalInBackground: false,
		refetchOnWindowFocus: false,
		placeholderData: keepPreviousData,
	})
}

export type TransactionsData = Awaited<
	ReturnType<
		NonNullable<ReturnType<typeof transactionsQueryOptions>['queryFn']>
	>
>

```

## File: apps/explorer/src/lib/queries/blocks.ts
```
import { keepPreviousData, queryOptions } from '@tanstack/react-query'
import type { Hex } from 'ox'
import type { Block } from 'viem'
import { getBlock, getTransactionReceipt } from 'wagmi/actions'
import { type KnownEvent, parseKnownEvents } from '#lib/domain/known-events'
import * as Tip20 from '#lib/domain/tip20.ts'
import { getConfig } from '#wagmi.config.ts'

export const BLOCKS_PER_PAGE = 12

export type BlockIdentifier =
	| { kind: 'hash'; blockHash: Hex.Hex }
	| { kind: 'number'; blockNumber: bigint }

export type BlockWithTransactions = Block<bigint, true>
export type BlockTransaction = BlockWithTransactions['transactions'][number]

export function blocksQueryOptions(page: number) {
	return queryOptions({
		queryKey: ['blocks-loader', page],
		queryFn: async () => {
			const wagmiConfig = getConfig()

			const latestBlock = await getBlock(wagmiConfig)
			const latestBlockNumber = latestBlock.number

			const startBlock =
				latestBlockNumber - BigInt((page - 1) * BLOCKS_PER_PAGE)

			const blockNumbers: bigint[] = []
			for (let i = 0n; i < BigInt(BLOCKS_PER_PAGE); i++) {
				const blockNum = startBlock - i
				if (blockNum >= 0n) blockNumbers.push(blockNum)
			}

			const blocks = await Promise.all(
				blockNumbers.map((blockNumber) =>
					getBlock(wagmiConfig, { blockNumber }).catch(() => null),
				),
			)

			return {
				latestBlockNumber,
				blocks: blocks.filter(Boolean) as Block[],
			}
		},
		placeholderData: keepPreviousData,
	})
}

export const TRANSACTIONS_PER_PAGE = 20

export function blockDetailQueryOptions(
	blockRef: BlockIdentifier,
	page: number = 1,
) {
	return queryOptions({
		queryKey: ['block-detail', blockRef, page],
		queryFn: async () => {
			const wagmiConfig = getConfig()
			const block = await getBlock(wagmiConfig, {
				includeTransactions: true,
				...(blockRef.kind === 'hash'
					? { blockHash: blockRef.blockHash }
					: { blockNumber: blockRef.blockNumber }),
			})

			const allTransactions = block.transactions as BlockTransaction[]
			const startIndex = (page - 1) * TRANSACTIONS_PER_PAGE
			const pageTransactions = allTransactions.slice(
				startIndex,
				startIndex + TRANSACTIONS_PER_PAGE,
			)

			const knownEventsByHash = await fetchKnownEventsForTransactions(
				pageTransactions,
				wagmiConfig,
			)

			return {
				blockRef,
				block: block as BlockWithTransactions,
				knownEventsByHash,
				page,
			}
		},
		placeholderData: keepPreviousData,
	})
}

async function fetchKnownEventsForTransactions(
	transactions: BlockTransaction[],
	wagmiConfig: ReturnType<typeof getConfig>,
): Promise<Record<Hex.Hex, KnownEvent[]>> {
	const entries = await Promise.all(
		transactions.map(async (transaction) => {
			if (!transaction?.hash)
				return [transaction.hash ?? 'unknown', []] as const

			try {
				const receipt = await getTransactionReceipt(wagmiConfig, {
					hash: transaction.hash,
				})
				const getTokenMetadata = await Tip20.metadataFromLogs(receipt.logs)
				const events = parseKnownEvents(receipt, {
					transaction,
					getTokenMetadata,
				})

				return [transaction.hash, events] as const
			} catch (error) {
				console.error('Failed to load transaction description', {
					hash: transaction.hash,
					error,
				})
				return [transaction.hash, []] as const
			}
		}),
	)

	return Object.fromEntries(
		entries.filter(([hash]) => Boolean(hash)),
	) as Record<Hex.Hex, KnownEvent[]>
}

```

## File: apps/explorer/src/lib/queries/index.ts
```
export * from './account'
export * from './blocks'
export * from './tokens'
export * from './tx'

```

## File: apps/explorer/src/lib/queries/tokens.ts
```
import { keepPreviousData, queryOptions } from '@tanstack/react-query'
import type { Address } from 'ox'
import { fetchHolders, fetchTransfers } from '#lib/server/token.server.ts'
import { fetchTokens } from '#lib/server/tokens.server.ts'

export const TOKENS_PER_PAGE = 12

export type TransfersQueryParams = {
	address: Address.Address
	page: number
	limit: number
	offset: number
	account?: Address.Address | undefined
	_key?: string | undefined
}

export type HoldersQueryParams = {
	address: Address.Address
	page: number
	limit: number
	offset: number
}

export function transfersQueryOptions(params: TransfersQueryParams) {
	return queryOptions({
		queryKey: [
			'token-transfers',
			params.address,
			params.page,
			params.limit,
			params.account,
			params._key,
		],
		queryFn: async () => {
			const data = await fetchTransfers({
				data: {
					address: params.address,
					offset: params.offset,
					limit: params.limit,
					account: params.account,
				},
			})
			return data
		},
		placeholderData: keepPreviousData,
	})
}

export function holdersQueryOptions(params: HoldersQueryParams) {
	return queryOptions({
		queryKey: ['token-holders', params.address, params.page, params.limit],
		queryFn: async () => {
			const data = await fetchHolders({
				data: {
					address: params.address,
					offset: params.offset,
					limit: params.limit,
				},
			})
			return data
		},
		placeholderData: keepPreviousData,
	})
}

export function tokensListQueryOptions(params: {
	page: number
	limit: number
}) {
	const offset = (params.page - 1) * params.limit
	return queryOptions({
		queryKey: ['tokens', params.page, params.limit],
		queryFn: () => fetchTokens({ data: { offset, limit: params.limit } }),
		placeholderData: keepPreviousData,
	})
}

```

## File: apps/explorer/src/lib/queries/tx.ts
```
import { queryOptions } from '@tanstack/react-query'
import type { Hex } from 'ox'
import { getBlock, getTransaction, getTransactionReceipt } from 'wagmi/actions'
import { parseKnownEvent, parseKnownEvents } from '#lib/domain/known-events'
import { getFeeBreakdown } from '#lib/domain/receipt'
import * as Tip20 from '#lib/domain/tip20'
import { getConfig } from '#wagmi.config'

export function txQueryOptions(params: { hash: Hex.Hex }) {
	return queryOptions({
		queryKey: ['tx-detail', params.hash],
		queryFn: () => fetchTxData(params),
	})
}

async function fetchTxData(params: { hash: Hex.Hex }) {
	const config = getConfig()
	const receipt = await getTransactionReceipt(config, { hash: params.hash })

	const [block, transaction, getTokenMetadata] = await Promise.all([
		getBlock(config, { blockHash: receipt.blockHash }),
		getTransaction(config, { hash: receipt.transactionHash }),
		Tip20.metadataFromLogs(receipt.logs),
	])

	const knownEvents = parseKnownEvents(receipt, {
		transaction,
		getTokenMetadata,
	})

	const feeBreakdown = getFeeBreakdown(receipt, { getTokenMetadata })

	const knownEventsByLog = receipt.logs.map((log) =>
		parseKnownEvent(log, { getTokenMetadata }),
	)

	return {
		block,
		feeBreakdown,
		knownEvents,
		knownEventsByLog,
		receipt,
		transaction,
	}
}

export type TxData = Awaited<ReturnType<typeof fetchTxData>>

```

## File: apps/explorer/src/lib/server/account.server.ts
```
import { createServerFn } from '@tanstack/react-start'
import * as IDX from 'idxs'
import { Address, Hex } from 'ox'
import { Abis } from 'tempo.ts/viem'
import { formatUnits, type RpcTransaction } from 'viem'
import { readContract } from 'wagmi/actions'
import * as z from 'zod/mini'
import { zAddress } from '#lib/zod'
import { config, getConfig } from '#wagmi.config.ts'

const IS = IDX.IndexSupply.create({
	apiKey: process.env.INDEXER_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

const [MAX_LIMIT, DEFAULT_LIMIT] = [1_000, 100]

const TRANSFER_SIGNATURE =
	'event Transfer(address indexed from, address indexed to, uint256 tokens)'

export const fetchTransactions = createServerFn()
	.inputValidator(
		z.object({
			address: zAddress(),
			offset: z.prefault(z.coerce.number(), 0),
			limit: z.prefault(z.coerce.number(), 100),
			include: z.prefault(z.enum(['all', 'sent', 'received']), 'all'),
			sort: z.prefault(z.enum(['asc', 'desc']), 'desc'),
		}),
	)
	.handler(async ({ data: params }) => {
		const chainId = config.getClient().chain.id
		const chainIdHex = Hex.fromNumber(chainId)

		const include =
			params.include === 'sent'
				? 'sent'
				: params.include === 'received'
					? 'received'
					: 'all'
		const sortDirection = params.sort === 'asc' ? 'asc' : 'desc'

		const offset = Math.max(
			0,
			Number.isFinite(params.offset) ? Math.floor(params.offset) : 0,
		)

		let limit = Number.isFinite(params.limit)
			? Math.floor(params.limit)
			: DEFAULT_LIMIT

		if (limit > MAX_LIMIT) throw new Error('Limit is too high')

		if (limit < 1) limit = 1

		const includeSent = include === 'all' || include === 'sent'
		const includeReceived = include === 'all' || include === 'received'

		const fetchSize = offset + limit + 1

		// Build direct transactions query
		let directTxsQuery = QB.selectFrom('txs')
			.select([
				'hash',
				'block_num',
				'from',
				'to',
				'value',
				'input',
				'nonce',
				'gas',
				'gas_price',
				'type',
			])
			.where('chain', '=', chainId)

		if (includeSent && includeReceived) {
			directTxsQuery = directTxsQuery.where((eb) =>
				eb.or([eb('from', '=', params.address), eb('to', '=', params.address)]),
			)
		} else if (includeSent) {
			directTxsQuery = directTxsQuery.where('from', '=', params.address)
		} else if (includeReceived) {
			directTxsQuery = directTxsQuery.where('to', '=', params.address)
		}

		directTxsQuery = directTxsQuery
			.orderBy('block_num', sortDirection)
			.orderBy('hash', sortDirection)
			.limit(fetchSize)

		// Build transfer hashes query
		let transferHashesQuery = QB.withSignatures([TRANSFER_SIGNATURE])
			.selectFrom('transfer')
			.select(['tx_hash', 'block_num'])
			.distinct()
			.where('chain', '=', chainId)

		if (includeSent && includeReceived) {
			transferHashesQuery = transferHashesQuery.where((eb) =>
				eb.or([eb('from', '=', params.address), eb('to', '=', params.address)]),
			)
		} else if (includeSent) {
			transferHashesQuery = transferHashesQuery.where(
				'from',
				'=',
				params.address,
			)
		} else if (includeReceived) {
			transferHashesQuery = transferHashesQuery.where('to', '=', params.address)
		}

		transferHashesQuery = transferHashesQuery
			.orderBy('block_num', sortDirection)
			.orderBy('tx_hash', sortDirection)
			.limit(fetchSize)

		const [directTxsResult, transferHashesResult] = await Promise.all([
			directTxsQuery.execute(),
			transferHashesQuery.execute(),
		])

		const txsByHash = new Map<Hex.Hex, (typeof directTxsResult)[number]>()
		for (const row of directTxsResult) txsByHash.set(row.hash, row)

		const transferHashes: Hex.Hex[] = []
		for (const row of transferHashesResult) {
			const hash = row.tx_hash
			if (!txsByHash.has(hash)) transferHashes.push(hash)
		}

		if (transferHashes.length > 0) {
			const BATCH_SIZE = 500
			for (let index = 0; index < transferHashes.length; index += BATCH_SIZE) {
				const batch = transferHashes.slice(index, index + BATCH_SIZE)

				const transferTxsResult = await QB.selectFrom('txs')
					.select([
						'hash',
						'block_num',
						'from',
						'to',
						'value',
						'input',
						'nonce',
						'gas',
						'gas_price',
						'type',
					])
					.where('chain', '=', chainId)
					.where('hash', 'in', batch)
					.execute()

				for (const row of transferTxsResult) txsByHash.set(row.hash, row)
			}
		}

		const sortedTxs = [...txsByHash.values()].sort((a, b) =>
			sortDirection === 'desc'
				? Number(b.block_num) - Number(a.block_num)
				: Number(a.block_num) - Number(b.block_num),
		)

		const hasMore = sortedTxs.length > offset + limit
		const paginatedTxs = sortedTxs.slice(offset, offset + limit)

		const transactions: RpcTransaction[] = paginatedTxs.map((row) => {
			const from = Address.checksum(row.from)
			if (!from) throw new Error('Transaction is missing a "from" address')

			const to = row.to ? Address.checksum(row.to) : null

			return {
				blockHash: null,
				blockNumber: Hex.fromNumber(row.block_num),
				chainId: chainIdHex,
				from,
				gas: Hex.fromNumber(row.gas),
				gasPrice: Hex.fromNumber(row.gas_price),
				hash: row.hash,
				input: row.input,
				nonce: Hex.fromNumber(row.nonce),
				to,
				transactionIndex: null,
				value: Hex.fromNumber(row.value),
				type: Hex.fromNumber(row.type) as RpcTransaction['type'],
				v: '0x0',
				r: '0x0',
				s: '0x0',
			} as RpcTransaction
		})

		const nextOffset = offset + transactions.length

		return {
			transactions,
			total: hasMore ? nextOffset + 1 : nextOffset,
			offset: nextOffset,
			limit: transactions.length,
			hasMore,
			error: null,
		}
	})

export const getTotalValue = createServerFn()
	.inputValidator(
		z.object({
			address: zAddress(),
		}),
	)
	.handler(async ({ data: params }) => {
		const { address } = params
		const chainId = config.getClient().chain.id

		const result = await QB.withSignatures([TRANSFER_SIGNATURE])
			.selectFrom('transfer')
			.select(['address', 'from', 'to', 'tokens'])
			.where('chain', '=', chainId)
			.where((eb) => eb.or([eb('from', '=', address), eb('to', '=', address)]))
			.execute()

		// Calculate balance per token
		const balances = new Map<string, bigint>()
		for (const row of result) {
			const tokenAddress = String(row.address)
			const from = String(row.from).toLowerCase()
			const to = String(row.to).toLowerCase()
			const tokens = BigInt(row.tokens)
			const addressLower = address.toLowerCase()

			const currentBalance = balances.get(tokenAddress) ?? 0n
			let newBalance = currentBalance
			if (to === addressLower) {
				newBalance += tokens
			}
			if (from === addressLower) {
				newBalance -= tokens
			}
			balances.set(tokenAddress, newBalance)
		}

		// Filter for positive balances
		const rowsWithBalance = [...balances.entries()]
			.filter(([_, balance]) => balance > 0n)
			.map(([token_address, balance]) => ({ token_address, balance }))

		const decimals =
			(await Promise.all(
				rowsWithBalance.map((row) =>
					// TODO: use readContracts when multicall is not broken
					readContract(getConfig(), {
						address: row.token_address as Address.Address,
						abi: Abis.tip20,
						functionName: 'decimals',
					}),
				),
			)) ?? []

		const decimalsMap = new Map<Address.Address, number>(
			decimals.map((decimal, index) => [
				rowsWithBalance[index].token_address as Address.Address,
				decimal,
			]),
		)

		const PRICE_PER_TOKEN = 1 // TODO: fetch actual price per token

		const totalValue = rowsWithBalance
			.map((row) => {
				const tokenDecimals =
					decimalsMap.get(row.token_address as Address.Address) ?? 0
				return Number(formatUnits(row.balance, tokenDecimals))
			})
			.reduce((acc, balance) => acc + balance * PRICE_PER_TOKEN, 0)

		return totalValue
	})

export const FetchAddressTransactionsCountSchema = z.object({
	address: zAddress({ lowercase: true }),
	chainId: z.coerce.number(),
})

export const fetchAddressTransactionsCount = createServerFn({ method: 'GET' })
	.inputValidator((input) => FetchAddressTransactionsCountSchema.parse(input))
	.handler(async ({ data: { address, chainId } }) => {
		const [txSentResult, txReceivedResult] = await Promise.all([
			QB.selectFrom('txs')
				.select((eb) => eb.fn.count('hash').as('cnt'))
				.where('from', '=', address)
				.where('chain', '=', chainId)
				.executeTakeFirstOrThrow(),
			QB.selectFrom('txs')
				.select((eb) => eb.fn.count('hash').as('cnt'))
				.where('to', '=', address)
				.where('chain', '=', chainId)
				.executeTakeFirstOrThrow(),
		])

		const txSent = BigInt(txSentResult.cnt ?? 0)
		const txReceived = BigInt(txReceivedResult.cnt ?? 0)

		return txSent + txReceived
	})

```

## File: apps/explorer/src/lib/server/latest-block.server.ts
```
import { createServerFn } from '@tanstack/react-start'
import * as IDX from 'idxs'
import { config } from '#wagmi.config.ts'

const IS = IDX.IndexSupply.create({
	apiKey: process.env.INDEXER_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

export const fetchLatestBlock = createServerFn({ method: 'GET' }).handler(
	async () => {
		const chainId = config.getClient().chain.id

		const result = await QB.selectFrom('blocks')
			.select('num')
			.where('chain', '=', chainId)
			.orderBy('num', 'desc')
			.limit(1)
			.executeTakeFirstOrThrow()

		return BigInt(result.num)
	},
)

```

## File: apps/explorer/src/lib/server/token.server.ts
```
import { createServerFn } from '@tanstack/react-start'
import * as IDX from 'idxs'
import type { Address, Hex } from 'ox'
import { zeroAddress } from 'viem'
import * as z from 'zod/mini'
import { zAddress } from '#lib/zod'
import { config } from '#wagmi.config.ts'

const IS = IDX.IndexSupply.create({
	apiKey: process.env.INDEXER_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

const [MAX_LIMIT, DEFAULT_LIMIT] = [1_000, 100]
const HOLDERS_CACHING = 60_000

const holdersCache = new Map<
	string,
	{
		data: {
			allHolders: Array<{ address: string; balance: bigint }>
			totalSupply: bigint
		}
		timestamp: number
	}
>()

const TRANSFER_SIGNATURE =
	'event Transfer(address indexed from, address indexed to, uint256 tokens)'

const FetchTokenHoldersInputSchema = z.object({
	address: zAddress({ lowercase: true }),
	offset: z.coerce.number().check(z.gte(0)),
	limit: z.coerce.number().check(z.gte(1), z.lte(MAX_LIMIT)),
})

export type FetchTokenHoldersInput = z.infer<
	typeof FetchTokenHoldersInputSchema
>

export type TokenHoldersApiResponse = {
	holders: Array<{
		address: Address.Address
		balance: string
		percentage: number
	}>
	total: number
	totalSupply: string
	offset: number
	limit: number
}

export const fetchHolders = createServerFn({ method: 'POST' })
	.inputValidator((input) => FetchTokenHoldersInputSchema.parse(input))
	.handler(async ({ data }) => {
		const chainId = config.getClient().chain.id
		const cacheKey = `${chainId}-${data.address}`

		const cached = holdersCache.get(cacheKey)
		const now = Date.now()

		let allHolders: Array<{ address: string; balance: bigint }>
		let totalSupply: bigint

		if (cached && now - cached.timestamp < HOLDERS_CACHING) {
			allHolders = cached.data.allHolders
			totalSupply = cached.data.totalSupply
		} else {
			const result = await fetchHoldersData(data.address, chainId)
			allHolders = result.allHolders
			totalSupply = result.totalSupply

			holdersCache.set(cacheKey, {
				data: { allHolders, totalSupply },
				timestamp: now,
			})
		}

		const paginatedHolders = allHolders.slice(
			data.offset,
			data.offset + data.limit,
		)

		const holders = paginatedHolders.map((holder) => ({
			address: holder.address as Address.Address,
			balance: holder.balance.toString(),
			percentage:
				totalSupply > 0n
					? Number((holder.balance * 10000n) / totalSupply) / 100
					: 0,
		}))

		const total = allHolders.length
		const nextOffset = data.offset + holders.length

		return {
			holders,
			total,
			totalSupply: totalSupply.toString(),
			offset: nextOffset,
			limit: holders.length,
		}
	})

async function fetchHoldersData(address: Address.Address, chainId: number) {
	// Aggregate balances directly in the indexer instead of streaming every transfer.
	const qb = QB.withSignatures([TRANSFER_SIGNATURE])

	// Sum outgoing per holder (exclude mints from zero)
	const outgoing = await qb
		.selectFrom('transfer')
		.select((eb) => [
			eb.ref('from').as('holder'),
			eb.fn.sum('tokens').as('sent'),
		])
		.where('chain', '=', chainId)
		.where('address', '=', address)
		.where('from', '<>', zeroAddress)
		.groupBy('from')
		.execute()

	// Sum incoming per holder
	const incoming = await qb
		.selectFrom('transfer')
		.select((eb) => [
			eb.ref('to').as('holder'),
			eb.fn.sum('tokens').as('received'),
		])
		.where('chain', '=', chainId)
		.where('address', '=', address)
		.groupBy('to')
		.execute()

	const balances = new Map<string, bigint>()

	for (const row of incoming) {
		const holder = row.holder
		const received = BigInt(row.received)
		balances.set(holder, (balances.get(holder) ?? 0n) + received)
	}

	for (const row of outgoing) {
		const holder = row.holder
		const sent = BigInt(row.sent)
		balances.set(holder, (balances.get(holder) ?? 0n) - sent)
	}

	const allHolders = Array.from(balances.entries())
		.filter(([, balance]) => balance > 0n)
		.map(([holder, balance]) => ({ address: holder, balance }))
		.sort((a, b) => (b.balance > a.balance ? 1 : -1))

	const totalSupply = allHolders.reduce(
		(sum, holder) => sum + holder.balance,
		0n,
	)

	return { allHolders, totalSupply }
}

const FetchTokenTransfersInputSchema = z.object({
	address: zAddress({ lowercase: true }),
	offset: z.coerce.number().check(z.gte(0)),
	limit: z.coerce.number().check(z.gte(1), z.lte(MAX_LIMIT)),
	account: z.optional(zAddress({ lowercase: true })),
})

export type FetchTokenTransfersInput = z.infer<
	typeof FetchTokenTransfersInputSchema
>

export type TokenTransfersApiResponse = {
	transfers: Array<{
		from: Address.Address
		to: Address.Address
		value: string
		transactionHash: Hex.Hex
		blockNumber: string
		logIndex: number
		timestamp: string | null
	}>
	total: number
	offset: number
	limit: number
}

export const fetchTransfers = createServerFn({ method: 'POST' })
	.inputValidator((input) => FetchTokenTransfersInputSchema.parse(input))
	.handler(async ({ data }) => {
		const chainId = config.getClient().chain.id
		const [transfers, total] = await Promise.all([
			fetchTransfersData(
				data.address,
				data.limit,
				data.offset,
				chainId,
				data.account,
			),
			fetchTotalCount(data.address, chainId, data.account),
		])

		const nextOffset = data.offset + (transfers?.length ?? 0)

		return {
			transfers,
			total,
			offset: nextOffset,
			limit: transfers?.length,
		}
	})

async function fetchTransfersData(
	address: Address.Address,
	limit: number,
	offset: number,
	chainId: number,
	account?: Address.Address,
) {
	let query = QB.withSignatures([TRANSFER_SIGNATURE])
		.selectFrom('transfer')
		.select([
			'from',
			'to',
			'tokens',
			'tx_hash',
			'block_num',
			'log_idx',
			'block_timestamp',
		])
		.where('chain', '=', chainId)
		.where('address', '=', address)

	if (account) {
		query = query.where((eb) =>
			eb.or([eb('from', '=', account), eb('to', '=', account)]),
		)
	}

	const result = await query
		.orderBy('block_num', 'desc')
		.orderBy('log_idx', 'desc')
		.limit(limit)
		.offset(offset)
		.execute()

	return result.map((row) => ({
		from: row.from,
		to: row.to,
		value: String(row.tokens),
		transactionHash: row.tx_hash,
		blockNumber: String(row.block_num),
		logIndex: Number(row.log_idx),
		timestamp: row.block_timestamp ? String(row.block_timestamp) : null,
	}))
}

async function fetchTotalCount(
	address: Address.Address,
	chainId: number,
	account?: Address.Address,
) {
	let query = QB.withSignatures([TRANSFER_SIGNATURE])
		.selectFrom('transfer')
		.select((eb) => eb.fn.count('tx_hash').as('count'))
		.where('chain', '=', chainId)
		.where('address', '=', address)

	if (account) {
		query = query.where((eb) =>
			eb.or([eb('from', '=', account), eb('to', '=', account)]),
		)
	}

	const result = await query.executeTakeFirstOrThrow()

	return Number(result.count)
}

export { MAX_LIMIT, DEFAULT_LIMIT }

```

## File: apps/explorer/src/lib/server/tokens.server.ts
```
import { createServerFn } from '@tanstack/react-start'
import * as IDX from 'idxs'
import type { Address } from 'ox'
import * as z from 'zod/mini'
import { config } from '#wagmi.config.ts'

const IS = IDX.IndexSupply.create({
	apiKey: process.env.INDEXER_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

export type Token = {
	address: Address.Address
	symbol: string
	name: string
	currency: string
	createdAt: number
}

const FetchTokensInputSchema = z.object({
	offset: z.coerce.number().check(z.gte(0)),
	limit: z.coerce.number().check(z.gte(1), z.lte(100)),
})

export type TokensApiResponse = {
	tokens: Token[]
	total: number
	offset: number
	limit: number
}

const EVENT_SIGNATURE =
	'event TokenCreated(address indexed token, uint256 indexed tokenId, string name, string symbol, string currency, address quoteToken, address admin)'

export const fetchTokens = createServerFn({ method: 'POST' })
	.inputValidator((input) => FetchTokensInputSchema.parse(input))
	.handler(async ({ data }): Promise<TokensApiResponse> => {
		const { offset, limit } = data

		const chainId = config.getClient().chain.id

		const tokensResult = await QB.withSignatures([EVENT_SIGNATURE])
			.selectFrom('tokencreated')
			.select(['token', 'symbol', 'name', 'currency', 'block_timestamp'])
			.where('chain', '=', chainId)
			.orderBy('block_timestamp', 'desc')
			.limit(limit)
			.offset(offset)
			.execute()

		const { count } = await QB.withSignatures([EVENT_SIGNATURE])
			.selectFrom('tokencreated')
			.select((eb) => eb.fn.count('token').as('count'))
			.where('chain', '=', chainId)
			.executeTakeFirstOrThrow()

		return {
			offset,
			limit,
			total: Number(count),
			tokens: tokensResult.map(
				({ token: address, block_timestamp, ...rest }) => ({
					...rest,
					address,
					createdAt: Number(block_timestamp),
				}),
			),
		}
	})

```

## File: apps/explorer/src/lib/zod.ts
```
import { Address, Hex } from 'ox'
import { z } from 'zod/mini'

export const zAddress = (opts?: { lowercase?: boolean }) =>
	z.pipe(
		z.string(),
		z.transform((x) => {
			if (opts?.lowercase) x = x.toLowerCase()
			Address.assert(x)
			return x
		}),
	)

export const zHash = () =>
	z.pipe(
		z.string(),
		z.transform((x) => {
			Hex.assert(x)
			if (Hex.size(x) !== 32) throw new Error('Invalid hash length')
			return x
		}),
	)

```

## File: apps/explorer/src/routeTree.gen.ts
```
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from './routes/__root'
import { Route as LayoutRouteImport } from './routes/_layout'
import { Route as LayoutIndexRouteImport } from './routes/_layout/index'
import { Route as ApiSearchRouteImport } from './routes/api/search'
import { Route as LayoutTokensRouteImport } from './routes/_layout/tokens'
import { Route as LayoutBlocksRouteImport } from './routes/_layout/blocks'
import { Route as LayoutDemoIndexRouteImport } from './routes/_layout/demo/index'
import { Route as LayoutTxHashRouteImport } from './routes/_layout/tx/$hash'
import { Route as LayoutTokenAddressRouteImport } from './routes/_layout/token/$address'
import { Route as LayoutReceiptHashRouteImport } from './routes/_layout/receipt/$hash'
import { Route as LayoutDemoTxRouteImport } from './routes/_layout/demo/tx'
import { Route as LayoutDemoPaginationRouteImport } from './routes/_layout/demo/pagination'
import { Route as LayoutDemoEmptyStateRouteImport } from './routes/_layout/demo/empty-state'
import { Route as LayoutDemoAddressRouteImport } from './routes/_layout/demo/address'
import { Route as LayoutBlockIdRouteImport } from './routes/_layout/block/$id'
import { Route as LayoutAddressAddressRouteImport } from './routes/_layout/address/$address'

const LayoutRoute = LayoutRouteImport.update({
  id: '/_layout',
  getParentRoute: () => rootRouteImport,
} as any)
const LayoutIndexRoute = LayoutIndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => LayoutRoute,
} as any)
const ApiSearchRoute = ApiSearchRouteImport.update({
  id: '/api/search',
  path: '/api/search',
  getParentRoute: () => rootRouteImport,
} as any)
const LayoutTokensRoute = LayoutTokensRouteImport.update({
  id: '/tokens',
  path: '/tokens',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutBlocksRoute = LayoutBlocksRouteImport.update({
  id: '/blocks',
  path: '/blocks',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutDemoIndexRoute = LayoutDemoIndexRouteImport.update({
  id: '/demo/',
  path: '/demo/',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutTxHashRoute = LayoutTxHashRouteImport.update({
  id: '/tx/$hash',
  path: '/tx/$hash',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutTokenAddressRoute = LayoutTokenAddressRouteImport.update({
  id: '/token/$address',
  path: '/token/$address',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutReceiptHashRoute = LayoutReceiptHashRouteImport.update({
  id: '/receipt/$hash',
  path: '/receipt/$hash',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutDemoTxRoute = LayoutDemoTxRouteImport.update({
  id: '/demo/tx',
  path: '/demo/tx',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutDemoPaginationRoute = LayoutDemoPaginationRouteImport.update({
  id: '/demo/pagination',
  path: '/demo/pagination',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutDemoEmptyStateRoute = LayoutDemoEmptyStateRouteImport.update({
  id: '/demo/empty-state',
  path: '/demo/empty-state',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutDemoAddressRoute = LayoutDemoAddressRouteImport.update({
  id: '/demo/address',
  path: '/demo/address',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutBlockIdRoute = LayoutBlockIdRouteImport.update({
  id: '/block/$id',
  path: '/block/$id',
  getParentRoute: () => LayoutRoute,
} as any)
const LayoutAddressAddressRoute = LayoutAddressAddressRouteImport.update({
  id: '/address/$address',
  path: '/address/$address',
  getParentRoute: () => LayoutRoute,
} as any)

export interface FileRoutesByFullPath {
  '/blocks': typeof LayoutBlocksRoute
  '/tokens': typeof LayoutTokensRoute
  '/api/search': typeof ApiSearchRoute
  '/': typeof LayoutIndexRoute
  '/address/$address': typeof LayoutAddressAddressRoute
  '/block/$id': typeof LayoutBlockIdRoute
  '/demo/address': typeof LayoutDemoAddressRoute
  '/demo/empty-state': typeof LayoutDemoEmptyStateRoute
  '/demo/pagination': typeof LayoutDemoPaginationRoute
  '/demo/tx': typeof LayoutDemoTxRoute
  '/receipt/$hash': typeof LayoutReceiptHashRoute
  '/token/$address': typeof LayoutTokenAddressRoute
  '/tx/$hash': typeof LayoutTxHashRoute
  '/demo': typeof LayoutDemoIndexRoute
}
export interface FileRoutesByTo {
  '/blocks': typeof LayoutBlocksRoute
  '/tokens': typeof LayoutTokensRoute
  '/api/search': typeof ApiSearchRoute
  '/': typeof LayoutIndexRoute
  '/address/$address': typeof LayoutAddressAddressRoute
  '/block/$id': typeof LayoutBlockIdRoute
  '/demo/address': typeof LayoutDemoAddressRoute
  '/demo/empty-state': typeof LayoutDemoEmptyStateRoute
  '/demo/pagination': typeof LayoutDemoPaginationRoute
  '/demo/tx': typeof LayoutDemoTxRoute
  '/receipt/$hash': typeof LayoutReceiptHashRoute
  '/token/$address': typeof LayoutTokenAddressRoute
  '/tx/$hash': typeof LayoutTxHashRoute
  '/demo': typeof LayoutDemoIndexRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/_layout': typeof LayoutRouteWithChildren
  '/_layout/blocks': typeof LayoutBlocksRoute
  '/_layout/tokens': typeof LayoutTokensRoute
  '/api/search': typeof ApiSearchRoute
  '/_layout/': typeof LayoutIndexRoute
  '/_layout/address/$address': typeof LayoutAddressAddressRoute
  '/_layout/block/$id': typeof LayoutBlockIdRoute
  '/_layout/demo/address': typeof LayoutDemoAddressRoute
  '/_layout/demo/empty-state': typeof LayoutDemoEmptyStateRoute
  '/_layout/demo/pagination': typeof LayoutDemoPaginationRoute
  '/_layout/demo/tx': typeof LayoutDemoTxRoute
  '/_layout/receipt/$hash': typeof LayoutReceiptHashRoute
  '/_layout/token/$address': typeof LayoutTokenAddressRoute
  '/_layout/tx/$hash': typeof LayoutTxHashRoute
  '/_layout/demo/': typeof LayoutDemoIndexRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/blocks'
    | '/tokens'
    | '/api/search'
    | '/'
    | '/address/$address'
    | '/block/$id'
    | '/demo/address'
    | '/demo/empty-state'
    | '/demo/pagination'
    | '/demo/tx'
    | '/receipt/$hash'
    | '/token/$address'
    | '/tx/$hash'
    | '/demo'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/blocks'
    | '/tokens'
    | '/api/search'
    | '/'
    | '/address/$address'
    | '/block/$id'
    | '/demo/address'
    | '/demo/empty-state'
    | '/demo/pagination'
    | '/demo/tx'
    | '/receipt/$hash'
    | '/token/$address'
    | '/tx/$hash'
    | '/demo'
  id:
    | '__root__'
    | '/_layout'
    | '/_layout/blocks'
    | '/_layout/tokens'
    | '/api/search'
    | '/_layout/'
    | '/_layout/address/$address'
    | '/_layout/block/$id'
    | '/_layout/demo/address'
    | '/_layout/demo/empty-state'
    | '/_layout/demo/pagination'
    | '/_layout/demo/tx'
    | '/_layout/receipt/$hash'
    | '/_layout/token/$address'
    | '/_layout/tx/$hash'
    | '/_layout/demo/'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  LayoutRoute: typeof LayoutRouteWithChildren
  ApiSearchRoute: typeof ApiSearchRoute
}

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/_layout': {
      id: '/_layout'
      path: ''
      fullPath: ''
      preLoaderRoute: typeof LayoutRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/_layout/': {
      id: '/_layout/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof LayoutIndexRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/api/search': {
      id: '/api/search'
      path: '/api/search'
      fullPath: '/api/search'
      preLoaderRoute: typeof ApiSearchRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/_layout/tokens': {
      id: '/_layout/tokens'
      path: '/tokens'
      fullPath: '/tokens'
      preLoaderRoute: typeof LayoutTokensRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/blocks': {
      id: '/_layout/blocks'
      path: '/blocks'
      fullPath: '/blocks'
      preLoaderRoute: typeof LayoutBlocksRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/demo/': {
      id: '/_layout/demo/'
      path: '/demo'
      fullPath: '/demo'
      preLoaderRoute: typeof LayoutDemoIndexRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/tx/$hash': {
      id: '/_layout/tx/$hash'
      path: '/tx/$hash'
      fullPath: '/tx/$hash'
      preLoaderRoute: typeof LayoutTxHashRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/token/$address': {
      id: '/_layout/token/$address'
      path: '/token/$address'
      fullPath: '/token/$address'
      preLoaderRoute: typeof LayoutTokenAddressRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/receipt/$hash': {
      id: '/_layout/receipt/$hash'
      path: '/receipt/$hash'
      fullPath: '/receipt/$hash'
      preLoaderRoute: typeof LayoutReceiptHashRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/demo/tx': {
      id: '/_layout/demo/tx'
      path: '/demo/tx'
      fullPath: '/demo/tx'
      preLoaderRoute: typeof LayoutDemoTxRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/demo/pagination': {
      id: '/_layout/demo/pagination'
      path: '/demo/pagination'
      fullPath: '/demo/pagination'
      preLoaderRoute: typeof LayoutDemoPaginationRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/demo/empty-state': {
      id: '/_layout/demo/empty-state'
      path: '/demo/empty-state'
      fullPath: '/demo/empty-state'
      preLoaderRoute: typeof LayoutDemoEmptyStateRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/demo/address': {
      id: '/_layout/demo/address'
      path: '/demo/address'
      fullPath: '/demo/address'
      preLoaderRoute: typeof LayoutDemoAddressRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/block/$id': {
      id: '/_layout/block/$id'
      path: '/block/$id'
      fullPath: '/block/$id'
      preLoaderRoute: typeof LayoutBlockIdRouteImport
      parentRoute: typeof LayoutRoute
    }
    '/_layout/address/$address': {
      id: '/_layout/address/$address'
      path: '/address/$address'
      fullPath: '/address/$address'
      preLoaderRoute: typeof LayoutAddressAddressRouteImport
      parentRoute: typeof LayoutRoute
    }
  }
}

interface LayoutRouteChildren {
  LayoutBlocksRoute: typeof LayoutBlocksRoute
  LayoutTokensRoute: typeof LayoutTokensRoute
  LayoutIndexRoute: typeof LayoutIndexRoute
  LayoutAddressAddressRoute: typeof LayoutAddressAddressRoute
  LayoutBlockIdRoute: typeof LayoutBlockIdRoute
  LayoutDemoAddressRoute: typeof LayoutDemoAddressRoute
  LayoutDemoEmptyStateRoute: typeof LayoutDemoEmptyStateRoute
  LayoutDemoPaginationRoute: typeof LayoutDemoPaginationRoute
  LayoutDemoTxRoute: typeof LayoutDemoTxRoute
  LayoutReceiptHashRoute: typeof LayoutReceiptHashRoute
  LayoutTokenAddressRoute: typeof LayoutTokenAddressRoute
  LayoutTxHashRoute: typeof LayoutTxHashRoute
  LayoutDemoIndexRoute: typeof LayoutDemoIndexRoute
}

const LayoutRouteChildren: LayoutRouteChildren = {
  LayoutBlocksRoute: LayoutBlocksRoute,
  LayoutTokensRoute: LayoutTokensRoute,
  LayoutIndexRoute: LayoutIndexRoute,
  LayoutAddressAddressRoute: LayoutAddressAddressRoute,
  LayoutBlockIdRoute: LayoutBlockIdRoute,
  LayoutDemoAddressRoute: LayoutDemoAddressRoute,
  LayoutDemoEmptyStateRoute: LayoutDemoEmptyStateRoute,
  LayoutDemoPaginationRoute: LayoutDemoPaginationRoute,
  LayoutDemoTxRoute: LayoutDemoTxRoute,
  LayoutReceiptHashRoute: LayoutReceiptHashRoute,
  LayoutTokenAddressRoute: LayoutTokenAddressRoute,
  LayoutTxHashRoute: LayoutTxHashRoute,
  LayoutDemoIndexRoute: LayoutDemoIndexRoute,
}

const LayoutRouteWithChildren =
  LayoutRoute._addFileChildren(LayoutRouteChildren)

const rootRouteChildren: RootRouteChildren = {
  LayoutRoute: LayoutRouteWithChildren,
  ApiSearchRoute: ApiSearchRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

import type { getRouter } from './router.tsx'
import type { createStart } from '@tanstack/react-start'
declare module '@tanstack/react-start' {
  interface Register {
    ssr: true
    router: Awaited<ReturnType<typeof getRouter>>
  }
}

```

## File: apps/explorer/src/router.tsx
```
import { QueryClient } from '@tanstack/react-query'
import { createRouter } from '@tanstack/react-router'
import { setupRouterSsrQueryIntegration } from '@tanstack/react-router-ssr-query'
import { hashFn } from 'wagmi/query'
import { NotFound } from '#comps/NotFound'
import { Layout } from '#routes/_layout'
import { routeTree } from '#routeTree.gen.ts'

export const getRouter = () => {
	const queryClient = new QueryClient({
		defaultOptions: {
			queries: {
				refetchOnWindowFocus: false,
				queryKeyHashFn: hashFn,
				gcTime: 1_000 * 60 * 60 * 24, // 24 hours
			},
		},
	})

	const router = createRouter({
		routeTree,
		notFoundMode: 'fuzzy',
		scrollRestoration: true,
		context: { queryClient },
		defaultPreload: 'intent',
		defaultPreloadDelay: 150,
		defaultNotFoundComponent: () => (
			<Layout>
				<NotFound />
			</Layout>
		),
	})

	// @see https://tanstack.com/router/latest/docs/integrations/query
	setupRouterSsrQueryIntegration({
		router,
		queryClient,
		wrapQueryClient: false,
	})

	return router
}

declare module '@tanstack/react-router' {
	interface Register {
		router: ReturnType<typeof getRouter>
	}
}

```

## File: apps/explorer/src/routes/__root.tsx
```
import { TanStackDevtools } from '@tanstack/react-devtools'
import type { QueryClient } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import {
	createRootRouteWithContext,
	HeadContent,
	Scripts,
	useRouterState,
} from '@tanstack/react-router'
import { TanStackRouterDevtoolsPanel } from '@tanstack/react-router-devtools'
import { useEffect } from 'react'
import { WagmiProvider } from 'wagmi'
import { ErrorBoundary } from '#comps/ErrorBoundary'
import { ProgressLine } from '#comps/ProgressLine'
import { config, persister, queryClient } from '#wagmi.config'
import css from './styles.css?url'

export const Route = createRootRouteWithContext<{
	queryClient: QueryClient
}>()({
	head: () => ({
		meta: [
			{
				charSet: 'utf-8',
			},
			{
				name: 'viewport',
				content: 'width=device-width, initial-scale=1',
			},
			{
				title: 'Explorer ⋅ Tempo',
			},
			{
				name: 'og:title',
				content: 'Explorer ⋅ Tempo',
			},
			{
				name: 'viewport',
				content: 'width=device-width, initial-scale=1, maximum-scale=1',
			},
			{
				name: 'description',
				content:
					'Explore and analyze blocks, transactions, contracts and more on Tempo.',
			},
			{
				name: 'og:description',
				content:
					'Explore and analyze blocks, transactions, contracts and more on Tempo.',
			},
			{
				name: 'og:image',
				content: '/og-explorer.png',
			},
			{
				name: 'og:image:type',
				content: 'image/png',
			},
			{
				name: 'og:image:width',
				content: '1200',
			},
			{
				name: 'og:image:height',
				content: '630',
			},
		],
		links: [
			{
				rel: 'stylesheet',
				href: css,
			},
			{
				rel: 'icon',
				type: 'image/svg+xml',
				href: '/favicon-light.svg',
				media: '(prefers-color-scheme: light)',
			},
			{
				rel: 'icon',
				type: 'image/svg+xml',
				href: '/favicon-dark.svg',
				media: '(prefers-color-scheme: dark)',
			},
			{
				rel: 'icon',
				type: 'image/png',
				sizes: '32x32',
				href: '/favicon-32x32-light.png',
				media: '(prefers-color-scheme: dark)',
			},
			{
				rel: 'icon',
				type: 'image/png',
				sizes: '32x32',
				href: '/favicon-32x32-dark.png',
				media: '(prefers-color-scheme: light)',
			},
			{
				rel: 'icon',
				type: 'image/png',
				sizes: '16x16',
				href: '/favicon-16x16-light.png',
				media: '(prefers-color-scheme: dark)',
			},
			{
				rel: 'icon',
				type: 'image/png',
				sizes: '16x16',
				href: '/favicon-16x16-dark.png',
				media: '(prefers-color-scheme: light)',
			},
			{
				rel: 'apple-touch-icon',
				sizes: '180x180',
				href: '/apple-touch-icon-light.png',
				media: '(prefers-color-scheme: light)',
			},
			{
				rel: 'apple-touch-icon',
				sizes: '180x180',
				href: '/apple-touch-icon-dark.png',
				media: '(prefers-color-scheme: dark)',
			},
		],
	}),
	errorComponent: (props) => (
		<RootDocument>
			<ErrorBoundary {...props} />
		</RootDocument>
	),
	shellComponent: RootDocument,
})

function RootDocument({ children }: { children: React.ReactNode }) {
	useDevTools()

	const isLoading = useRouterState({
		select: (state) => state.status === 'pending',
	})

	return (
		<html lang="en" className="scheme-light-dark">
			<head>
				<HeadContent />
			</head>
			<body className="antialiased">
				<ProgressLine
					loading={isLoading}
					start={800}
					className="fixed top-0 left-0 right-0 z-1"
				/>
				<WagmiProvider config={config}>
					<PersistQueryClientProvider
						client={queryClient}
						persistOptions={{ persister }}
					>
						{children}
						{import.meta.env.DEV && (
							<TanStackDevtools
								config={{
									position: 'bottom-right',
								}}
								plugins={[
									{
										name: 'Tanstack Query',
										render: <ReactQueryDevtools />,
									},
									{
										name: 'Tanstack Router',
										render: <TanStackRouterDevtoolsPanel />,
									},
								]}
							/>
						)}
					</PersistQueryClientProvider>
				</WagmiProvider>
				<Scripts />
			</body>
		</html>
	)
}

let theme: 'light' | 'dark' | undefined

function useDevTools() {
	useEffect(() => {
		if (import.meta.env.VITE_ENABLE_COLOR_SCHEME_TOGGLE !== 'true') return
		const handleKeyPress = (e: KeyboardEvent) => {
			if (
				// ⌘ + 1 = color scheme toggle
				((e.metaKey || e.ctrlKey) && e.key === '1') ||
				// ⌥ + 1 = color scheme toggle  (Safari)
				(e.altKey && e.code === 'Digit1')
			) {
				e.preventDefault()
				theme ??= window.matchMedia('(prefers-color-scheme: dark)').matches
					? 'dark'
					: 'light'
				document.documentElement.classList.toggle(
					'scheme-light!',
					theme === 'dark',
				)
				document.documentElement.classList.toggle(
					'scheme-dark!',
					theme === 'light',
				)
				theme = theme === 'dark' ? 'light' : 'dark'
			}
		}

		window.addEventListener('keydown', handleKeyPress)
		return () => window.removeEventListener('keydown', handleKeyPress)
	}, [])

	useEffect(() => {
		if (
			import.meta.env.MODE === 'development' &&
			import.meta.env.VITE_ENABLE_DEVTOOLS !== 'false'
		) {
			void import('eruda').then(({ default: eruda }) => eruda.init())
		}
	}, [])
}

```

## File: apps/explorer/src/routes/_layout/address/$address.tsx
```
import { useQueries, useQuery } from '@tanstack/react-query'
import {
	createFileRoute,
	Link,
	notFound,
	rootRouteId,
	stripSearchParams,
	useLocation,
	useNavigate,
	useRouter,
} from '@tanstack/react-router'
import { Address, Hex } from 'ox'
import * as React from 'react'
import { Hooks } from 'tempo.ts/wagmi'
import { formatUnits, isHash, type RpcTransaction as Transaction } from 'viem'
import { useBlock } from 'wagmi'
import { getBlock, getChainId, getTransactionReceipt } from 'wagmi/actions'
import * as z from 'zod/mini'
import { AccountCard } from '#comps/AccountCard'
import { ContractReader } from '#comps/ContractReader'
import { DataGrid } from '#comps/DataGrid'
import { NotFound } from '#comps/NotFound'
import { Sections } from '#comps/Sections'
import {
	TimeColumnHeader,
	type TimeFormat,
	useTimeFormat,
} from '#comps/TimeFormat'
import { TruncatedHash } from '#comps/TruncatedHash'
import {
	BatchTransactionDataContext,
	type TransactionData,
	TransactionDescription,
	TransactionTimestamp,
	TransactionTotal,
	useTransactionDataFromBatch,
} from '#comps/TxTransactionRow'
import { cx } from '#cva.config.ts'
import {
	type ContractInfo,
	extractContractAbi,
	getContractBytecode,
	getContractInfo,
} from '#lib/domain/contracts'
import { parseKnownEvents } from '#lib/domain/known-events'
import * as Tip20 from '#lib/domain/tip20'
import { HexFormatter, PriceFormatter } from '#lib/formatting'
import { useMediaQuery } from '#lib/hooks'
import {
	type TransactionsData,
	transactionsQueryOptions,
} from '#lib/queries/account.ts'
import * as AccountServer from '#lib/server/account.server.ts'
import { config, getConfig } from '#wagmi.config.ts'

const defaultSearchValues = {
	page: 1,
	limit: 10,
	tab: 'history',
} as const

type TabValue = 'history' | 'assets' | 'contract'

function useBatchTransactionData(transactions: Transaction[]) {
	const hashes = React.useMemo(
		() => transactions.map((tx) => tx.hash).filter(isHash),
		[transactions],
	)

	const queries = useQueries({
		queries: hashes.map((hash) => ({
			queryKey: ['tx-data-batch', hash],
			queryFn: async (): Promise<TransactionData | null> => {
				const cfg = getConfig()
				const receipt = await getTransactionReceipt(cfg, { hash })
				const [block, getTokenMetadata] = await Promise.all([
					getBlock(cfg, { blockHash: receipt.blockHash }),
					Tip20.metadataFromLogs(receipt.logs),
				])
				const transaction = transactions.find((tx) => tx.hash === hash)
				const knownEvents = parseKnownEvents(receipt, {
					transaction,
					getTokenMetadata,
				})
				return { receipt, block, knownEvents }
			},
			staleTime: 60_000,
		})),
	})

	const transactionDataMap = React.useMemo(() => {
		const map = new Map<Hex.Hex, TransactionData>()
		for (let index = 0; index < hashes.length; index++) {
			const data = queries[index]?.data
			if (data) map.set(hashes[index], data)
		}
		return map
	}, [hashes, queries])

	const isLoading = queries.some((q) => q.isLoading)

	return { transactionDataMap, isLoading }
}

const assets = [
	'0x20c0000000000000000000000000000000000000',
	'0x20c0000000000000000000000000000000000001',
	'0x20c0000000000000000000000000000000000002',
	'0x20c0000000000000000000000000000000000003',
] as const

type AssetData = {
	address: Address.Address
	metadata: { name?: string; symbol?: string; decimals?: number } | undefined
	balance: bigint | undefined
}

function useAssetsData(accountAddress: Address.Address): AssetData[] {
	const meta0 = Hooks.token.useGetMetadata({ token: assets[0] })
	const meta1 = Hooks.token.useGetMetadata({ token: assets[1] })
	const meta2 = Hooks.token.useGetMetadata({ token: assets[2] })
	const meta3 = Hooks.token.useGetMetadata({ token: assets[3] })

	const bal0 = Hooks.token.useGetBalance({
		token: assets[0],
		account: accountAddress,
	})
	const bal1 = Hooks.token.useGetBalance({
		token: assets[1],
		account: accountAddress,
	})
	const bal2 = Hooks.token.useGetBalance({
		token: assets[2],
		account: accountAddress,
	})
	const bal3 = Hooks.token.useGetBalance({
		token: assets[3],
		account: accountAddress,
	})

	return React.useMemo(
		() => [
			{ address: assets[0], metadata: meta0.data, balance: bal0.data },
			{ address: assets[1], metadata: meta1.data, balance: bal1.data },
			{ address: assets[2], metadata: meta2.data, balance: bal2.data },
			{ address: assets[3], metadata: meta3.data, balance: bal3.data },
		],
		[
			meta0.data,
			meta1.data,
			meta2.data,
			meta3.data,
			bal0.data,
			bal1.data,
			bal2.data,
			bal3.data,
		],
	)
}

function calculateTotalHoldings(assetsData: AssetData[]): number | undefined {
	const PRICE_PER_TOKEN = 1
	let total: number | undefined
	for (const asset of assetsData) {
		const decimals = asset.metadata?.decimals
		const balance = asset.balance
		if (decimals === undefined || balance === undefined) continue
		total =
			(total ?? 0) + Number(formatUnits(balance, decimals)) * PRICE_PER_TOKEN
	}
	return total
}

export const Route = createFileRoute('/_layout/address/$address')({
	component: RouteComponent,
	notFoundComponent: NotFound,
	validateSearch: z.object({
		page: z.prefault(z.number(), defaultSearchValues.page),
		limit: z.prefault(
			z.pipe(
				z.number(),
				z.transform((val) => Math.min(100, val)),
			),
			defaultSearchValues.limit,
		),
		tab: z.prefault(
			z.enum(['history', 'assets', 'contract']),
			defaultSearchValues.tab,
		),
	}),
	search: {
		middlewares: [stripSearchParams(defaultSearchValues)],
	},
	loaderDeps: ({ search: { page, limit } }) => ({ page, limit }),
	loader: async ({ deps: { page, limit }, params, context }) => {
		const { address } = params
		// Only throw notFound for truly invalid addresses
		if (!Address.validate(address))
			throw notFound({
				routeId: rootRouteId,
				data: { error: 'Invalid address format' },
			})

		const offset = (page - 1) * limit

		// check if it's a known contract from our registry
		let contractInfo: ContractInfo | undefined = getContractInfo(address)

		// if not in registry, try to extract ABI from bytecode using whatsabi
		if (!contractInfo) {
			const contractBytecode = await getContractBytecode(address).catch(
				() => undefined,
			)

			if (contractBytecode) {
				const contractAbi = await extractContractAbi(address).catch(
					() => undefined,
				)

				if (contractAbi) {
					contractInfo = {
						name: 'Unknown Contract',
						description: 'ABI extracted from bytecode',
						code: contractBytecode,
						abi: contractAbi,
						category: 'utility',
						address,
					}
				}
			}
		}

		const hasContract = Boolean(contractInfo)

		const transactionsData = await context.queryClient
			.ensureQueryData(
				transactionsQueryOptions({
					address,
					page,
					limit,
					offset,
				}),
			)
			.catch((error) => {
				console.error('Fetch error (non-blocking):', error)
				return undefined
			})

		const addressTransactionCount = await context.queryClient.ensureQueryData({
			queryKey: ['address-transaction-count', address],
			queryFn: () =>
				AccountServer.fetchAddressTransactionsCount({
					data: { address, chainId: getChainId(config) },
				}),
			staleTime: 30_000,
		})

		return {
			address,
			page,
			limit,
			offset,
			hasContract,
			contractInfo,
			transactionsData,
			addressTransactionCount,
		}
	},
})

function RouteComponent() {
	const navigate = useNavigate()
	const router = useRouter()
	const location = useLocation()
	const { address } = Route.useParams()
	const { page, tab, limit } = Route.useSearch()
	const {
		hasContract,
		contractInfo,
		transactionsData,
		addressTransactionCount,
	} = Route.useLoaderData()

	Address.assert(address)

	const hash = location.hash

	// Track which hash we've already redirected for (prevents re-redirect when
	// user manually switches tabs, but allows redirect for new hash values)
	const redirectedForHashRef = React.useRef<string | null>(null)

	// When URL has a hash fragment (e.g., #functionName), switch to contract tab
	React.useEffect(() => {
		// Only redirect if:
		// 1. We have a hash
		// 2. Address has a known contract
		// 3. Not already on contract tab
		// 4. Haven't already redirected for this specific hash
		if (
			hash &&
			hasContract &&
			tab !== 'contract' &&
			redirectedForHashRef.current !== hash
		) {
			redirectedForHashRef.current = hash
			navigate({
				to: '.',
				search: { page: 1, tab: 'contract', limit },
				hash,
				replace: true,
				resetScroll: false,
			})
		}
	}, [hash, hasContract, tab, navigate, limit])

	React.useEffect(() => {
		// Only preload for history tab (transaction pagination)
		if (tab !== 'history') return
		// preload next page only to reduce initial load overhead
		async function preload() {
			try {
				const nextPage = page + 1
				router.preloadRoute({
					to: '.',
					search: { page: nextPage, tab, limit },
				})
			} catch (error) {
				console.error('Preload error (non-blocking):', error)
			}
		}

		preload()
	}, [page, router, tab, limit])

	const setActiveSection = React.useCallback(
		(newIndex: number) => {
			const tabs: TabValue[] = hasContract
				? ['history', 'assets', 'contract']
				: ['history', 'assets']
			const newTab = tabs[newIndex] ?? 'history'
			navigate({
				to: '.',
				search: { page, tab: newTab, limit },
				resetScroll: false,
			})
		},
		[navigate, page, limit, hasContract],
	)

	const activeSection =
		tab === 'history' ? 0 : tab === 'assets' ? 1 : hasContract ? 2 : 0

	const assetsData = useAssetsData(address)

	return (
		<div
			className={cx(
				'max-[800px]:flex max-[800px]:flex-col max-w-[800px]:pt-10 max-w-[800px]:pb-8 w-full',
				'grid w-full pt-20 pb-16 px-4 gap-[14px] min-w-0 grid-cols-[auto_1fr] min-[1240px]:max-w-[1280px]',
			)}
		>
			<AccountCardWithTimestamps address={address} assetsData={assetsData} />
			<SectionsWrapper
				address={address}
				page={page}
				limit={limit}
				activeSection={activeSection}
				onSectionChange={setActiveSection}
				contractInfo={contractInfo}
				initialData={transactionsData}
				addressTransactionCount={addressTransactionCount}
				assetsData={assetsData}
			/>
		</div>
	)
}

function AccountCardWithTimestamps(props: {
	address: Address.Address
	assetsData: AssetData[]
}) {
	const { address, assetsData } = props

	// fetch the most recent transactions (pg.1)
	const { data: recentData } = useQuery(
		transactionsQueryOptions({
			address,
			page: 1,
			limit: 1,
			offset: 0,
			_key: 'account-creation',
		}),
	)

	// get the 1st (most recent) transaction's block timestamp for "last activity"
	const recentTransaction = recentData?.transactions?.at(0)
	const { data: lastActivityTimestamp } = useBlock({
		blockNumber: Hex.toBigInt(recentTransaction?.blockNumber ?? '0x0'),
		query: {
			enabled: Boolean(recentTransaction?.blockNumber),
			select: (block) => block.timestamp,
		},
	})

	// Use the real transaction count (not the approximate total from pagination)
	const { data: exactTotal } = useTransactionCount(address)
	const totalTransactions = Number(exactTotal ?? 0n)
	const lastPageOffset = Math.max(0, totalTransactions - 1)

	const { data: oldestData } = useQuery({
		...transactionsQueryOptions({
			address,
			page: Math.ceil(totalTransactions / 1),
			limit: 1,
			offset: lastPageOffset,
			_key: 'account-creation',
		}),
		enabled: totalTransactions > 0,
	})

	const [oldestTransaction] = oldestData?.transactions ?? []
	const { data: createdTimestamp } = useBlock({
		blockNumber: Hex.toBigInt(oldestTransaction?.blockNumber ?? '0x0'),
		query: {
			enabled: Boolean(oldestTransaction?.blockNumber),
			select: (block) => block.timestamp,
		},
	})

	const totalValue = calculateTotalHoldings(assetsData)

	return (
		<AccountCard
			address={address}
			className="self-start"
			createdTimestamp={createdTimestamp}
			lastActivityTimestamp={lastActivityTimestamp}
			totalValue={totalValue}
		/>
	)
}

function SectionsSkeleton({ totalItems }: { totalItems: number }) {
	const isMobile = useMediaQuery('(max-width: 799px)')
	return (
		<Sections
			mode={isMobile ? 'stacked' : 'tabs'}
			sections={[
				{
					title: 'History',
					totalItems,
					itemsLabel: 'transactions',
					content: (
						<DataGrid
							columns={{
								stacked: [
									{ label: 'Time', align: 'start', width: '0.5fr' },
									{ label: 'Hash', align: 'start', width: '1fr' },
									{ label: 'Total', align: 'end', width: '0.5fr' },
								],
								tabs: [
									{ label: 'Time', align: 'start', width: '0.5fr' },
									{ label: 'Description', align: 'start', width: '2fr' },
									{ label: 'Hash', align: 'end', width: '1fr' },
									{ label: 'Fee', align: 'end', width: '0.5fr' },
									{ label: 'Total', align: 'end', width: '0.5fr' },
								],
							}}
							items={(mode) =>
								Array.from(
									{ length: defaultSearchValues.limit },
									(_, index) => {
										const key = `skeleton-${index}`
										return {
											cells:
												mode === 'stacked'
													? [
															<div key={`${key}-time`} className="h-[20px]" />,
															<div key={`${key}-hash`} className="h-[20px]" />,
															<div key={`${key}-total`} className="h-[20px]" />,
														]
													: [
															<div key={`${key}-time`} className="h-[20px]" />,
															<div key={`${key}-desc`} className="h-[20px]" />,
															<div key={`${key}-hash`} className="h-[20px]" />,
															<div key={`${key}-fee`} className="h-[20px]" />,
															<div key={`${key}-total`} className="h-[20px]" />,
														],
										}
									},
								)
							}
							totalItems={totalItems}
							page={1}
							isPending={false}
							itemsLabel="transactions"
							itemsPerPage={defaultSearchValues.limit}
						/>
					),
				},
				{
					title: 'Assets',
					totalItems: 0,
					itemsLabel: 'assets',
					content: (
						<DataGrid
							columns={{
								stacked: [
									{ label: 'Name', align: 'start', width: '1fr' },
									{ label: 'Balance', align: 'end', width: '0.5fr' },
								],
								tabs: [
									{ label: 'Name', align: 'start', width: '1fr' },
									{ label: 'Ticker', align: 'start', width: '0.5fr' },
									{ label: 'Balance', align: 'end', width: '0.5fr' },
									{ label: 'Value', align: 'end', width: '0.5fr' },
								],
							}}
							items={() => []}
							totalItems={0}
							page={1}
							isPending={false}
							itemsLabel="assets"
						/>
					),
				},
			]}
			activeSection={0}
			onSectionChange={() => {}}
		/>
	)
}

function useTransactionCount(address: Address.Address) {
	return useQuery({
		queryKey: ['account-transaction-count', address],
		queryFn: () =>
			AccountServer.fetchAddressTransactionsCount({
				data: { address, chainId: getChainId(config) },
			}),
		staleTime: 30_000,
	})
}

function SectionsWrapper(props: {
	address: Address.Address
	page: number
	limit: number
	activeSection: number
	onSectionChange: (index: number) => void
	contractInfo: ContractInfo | undefined
	initialData: TransactionsData | undefined
	addressTransactionCount: bigint
	assetsData: AssetData[]
}) {
	const {
		address,
		page,
		limit,
		activeSection,
		onSectionChange,
		contractInfo,
		initialData,
		addressTransactionCount,
		assetsData,
	} = props
	const { timeFormat, cycleTimeFormat, formatLabel } = useTimeFormat()

	const isHistoryTabActive = activeSection === 0
	// Only auto-refresh on page 1 when history tab is active
	const shouldAutoRefresh = page === 1 && isHistoryTabActive

	const { data, isPending, error } = useQuery({
		...transactionsQueryOptions({
			address,
			page,
			limit,
			offset: (page - 1) * limit,
		}),
		initialData,
		// Override refetch settings reactively based on tab state
		refetchInterval: shouldAutoRefresh ? 4_000 : false,
		refetchOnWindowFocus: shouldAutoRefresh,
	})
	const { transactions, total: approximateTotal } = data ?? {
		transactions: [],
		total: 0,
	}

	const batchTransactionDataContextValue = useBatchTransactionData(transactions)

	const { data: exactTotal } = useTransactionCount(address)
	const total = exactTotal ?? approximateTotal

	// Use isPending for SSR-consistent loading state
	const isLoadingPage = isPending

	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	// Only show skeleton if we have no data AND we're loading
	// Use data presence check to avoid hydration mismatch
	if (!data && isPending)
		return <SectionsSkeleton totalItems={Number(addressTransactionCount)} />

	// Show error state for API failures (instead of crashing the whole page)
	const historyError = error ? (
		<div className="rounded-[10px] bg-card-header p-[18px]">
			<p className="text-sm font-medium text-red-400">
				Failed to load transaction history
			</p>
			<p className="text-xs text-tertiary mt-1">
				{error instanceof Error ? error.message : 'Unknown error'}
			</p>
		</div>
	) : null

	const historyColumns: DataGrid.Column[] = [
		{
			label: (
				<TimeColumnHeader
					label="Time"
					formatLabel={formatLabel}
					onCycle={cycleTimeFormat}
					className="text-secondary hover:text-accent cursor-pointer transition-colors"
				/>
			),
			align: 'start',
			width: '0.5fr',
		},
		{ label: 'Description', align: 'start', width: '2fr' },
		{ label: 'Hash', align: 'end', width: '1fr' },
		{ label: 'Fee', align: 'end', width: '0.5fr' },
		{ label: 'Total', align: 'end', width: '0.5fr' },
	]

	return (
		<BatchTransactionDataContext.Provider
			value={batchTransactionDataContextValue}
		>
			<Sections
				mode={mode}
				sections={[
					{
						title: 'History',
						totalItems: Number(total),
						itemsLabel: 'transactions',
						content: historyError ?? (
							<DataGrid
								columns={{
									stacked: historyColumns,
									tabs: historyColumns,
								}}
								items={() =>
									transactions.map((transaction) => ({
										cells: [
											<TransactionTimeCell
												key="time"
												hash={transaction.hash}
												format={timeFormat}
											/>,
											<TransactionDescCell
												key="desc"
												transaction={transaction}
												accountAddress={address}
											/>,
											<TruncatedHash
												key="hash"
												minChars={8}
												hash={transaction.hash}
											/>,
											<TransactionFeeCell key="fee" hash={transaction.hash} />,
											<TransactionTotal
												key="total"
												transaction={transaction}
											/>,
										],
										link: {
											href: `/receipt/${transaction.hash}`,
											title: `View receipt ${transaction.hash}`,
										},
									}))
								}
								totalItems={Number(total)}
								page={page}
								isPending={isLoadingPage}
								itemsLabel="transactions"
								itemsPerPage={limit}
								emptyState="No transactions found."
							/>
						),
					},
					{
						title: 'Assets',
						totalItems: assets.length,
						itemsLabel: 'assets',
						content: (
							<DataGrid
								columns={{
									stacked: [
										{ label: 'Name', align: 'start', width: '1fr' },
										{ label: 'Contract', align: 'start', width: '1fr' },
										{ label: 'Amount', align: 'end', width: '0.5fr' },
									],
									tabs: [
										{ label: 'Name', align: 'start', width: '1fr' },
										{ label: 'Ticker', align: 'start', width: '0.5fr' },
										{ label: 'Currency', align: 'start', width: '0.5fr' },
										{ label: 'Amount', align: 'end', width: '0.5fr' },
										{ label: 'Value', align: 'end', width: '0.5fr' },
									],
								}}
								items={(mode) =>
									assetsData.map((asset) => ({
										className: 'text-[13px]',
										cells:
											mode === 'stacked'
												? [
														<AssetName key="name" asset={asset} />,
														<AssetContract key="contract" asset={asset} />,
														<AssetAmount key="amount" asset={asset} />,
													]
												: [
														<AssetName key="name" asset={asset} />,
														<AssetSymbol key="symbol" asset={asset} />,
														<span key="currency">USD</span>,
														<AssetAmount key="amount" asset={asset} />,
														<AssetValue key="value" asset={asset} />,
													],
										link: {
											href: `/token/${asset.address}?a=${address}`,
											title: `View token ${asset.address}`,
										},
									}))
								}
								totalItems={assets.length}
								page={1}
								isPending={false}
								itemsLabel="assets"
								itemsPerPage={assets.length}
								emptyState="No assets found."
							/>
						),
					},
					// Contract tab - only shown for known contracts
					...(contractInfo
						? [
								{
									title: 'Contract',
									totalItems: 0,
									itemsLabel: 'functions',
									content: (
										<ContractReader
											address={address}
											abi={contractInfo.abi}
											docsUrl={contractInfo.docsUrl}
										/>
									),
								},
							]
						: []),
				]}
				activeSection={activeSection}
				onSectionChange={onSectionChange}
			/>
		</BatchTransactionDataContext.Provider>
	)
}

function TransactionTimeCell(props: { hash: Hex.Hex; format: TimeFormat }) {
	const { hash, format } = props
	const batchData = useTransactionDataFromBatch(hash)
	if (!batchData?.block) return <span className="text-tertiary">—</span>
	return (
		<TransactionTimestamp
			timestamp={batchData.block.timestamp}
			link={`/receipt/${hash}`}
			format={format}
		/>
	)
}

function TransactionDescCell(props: {
	transaction: Transaction
	accountAddress: Address.Address
}) {
	const { transaction, accountAddress } = props
	const batchData = useTransactionDataFromBatch(transaction.hash)
	if (!batchData) return <span className="text-tertiary">—</span>
	if (!batchData.knownEvents.length) {
		const count = batchData.receipt?.logs.length ?? 0
		return (
			<span className="text-secondary">
				{count === 0 ? 'No events' : `${count} events`}
			</span>
		)
	}
	return (
		<TransactionDescription
			transaction={transaction}
			knownEvents={batchData.knownEvents}
			transactionReceipt={batchData.receipt}
			accountAddress={accountAddress}
		/>
	)
}

function TransactionFeeCell(props: { hash: Hex.Hex }) {
	const batchData = useTransactionDataFromBatch(props.hash)
	if (!batchData?.receipt) return <span className="text-tertiary">—</span>
	return (
		<span className="text-tertiary">
			{PriceFormatter.format(
				batchData.receipt.effectiveGasPrice *
					batchData.receipt.cumulativeGasUsed,
				{ decimals: 18, format: 'short' },
			)}
		</span>
	)
}

function AssetName(props: { asset: AssetData }) {
	const { asset } = props
	if (!asset.metadata?.name) return <span className="text-tertiary">…</span>
	return <span>{asset.metadata.name}</span>
}

function AssetSymbol(props: { asset: AssetData }) {
	const { asset } = props
	if (!asset.metadata?.symbol) return <span className="text-tertiary">…</span>
	return (
		<Link
			to="/token/$address"
			params={{ address: asset.address }}
			className="text-accent hover:underline press-down"
		>
			{asset.metadata.symbol}
		</Link>
	)
}

function AssetContract(props: { asset: AssetData }) {
	return (
		<span className="text-accent">
			{HexFormatter.truncate(props.asset.address, 10)}
		</span>
	)
}

function AssetAmount(props: { asset: AssetData }) {
	const { asset } = props
	if (asset.metadata?.decimals === undefined || asset.balance === undefined)
		return <span className="text-tertiary">…</span>
	const formatted = formatUnits(asset.balance, asset.metadata.decimals)
	return <span>{PriceFormatter.formatAmountShort(formatted)}</span>
}

function AssetValue(props: { asset: AssetData }) {
	const { asset } = props
	if (asset.metadata?.decimals === undefined || asset.balance === undefined)
		return <span className="text-tertiary">…</span>
	return (
		<span>
			{PriceFormatter.format(asset.balance, {
				decimals: asset.metadata.decimals,
				format: 'short',
			})}
		</span>
	)
}

```

## File: apps/explorer/src/routes/_layout/block/$id.tsx
```
import { useQuery } from '@tanstack/react-query'
import {
	createFileRoute,
	Link,
	notFound,
	redirect,
	rootRouteId,
	stripSearchParams,
} from '@tanstack/react-router'
import { Hex, Value } from 'ox'
import * as React from 'react'
import { Abis } from 'tempo.ts/viem'
import { decodeFunctionData, isHex, zeroAddress } from 'viem'
import { useChains } from 'wagmi'
import * as z from 'zod/mini'
import { Address as AddressLink } from '#comps/Address'
import { BlockCard } from '#comps/BlockCard'
import { DataGrid } from '#comps/DataGrid'
import { NotFound } from '#comps/NotFound'
import { Sections } from '#comps/Sections'
import { TruncatedHash } from '#comps/TruncatedHash'
import { TxEventDescription } from '#comps/TxEventDescription'
import { cx } from '#cva.config.ts'
import type { KnownEvent } from '#lib/domain/known-events'
import { preferredEventsFilter } from '#lib/domain/known-events'
import { DateFormatter, PriceFormatter } from '#lib/formatting.ts'
import { useMediaQuery } from '#lib/hooks'
import {
	type BlockIdentifier,
	type BlockTransaction,
	blockDetailQueryOptions,
	TRANSACTIONS_PER_PAGE,
} from '#lib/queries'
import { fetchLatestBlock } from '#lib/server/latest-block.server.ts'

const defaultSearchValues = { page: 1 } as const

const combinedAbi = Object.values(Abis).flat()

interface TransactionTypeResult {
	type: 'system' | 'sub-block' | 'fee-token' | 'regular'
	label: string
}

export const Route = createFileRoute('/_layout/block/$id')({
	component: RouteComponent,
	notFoundComponent: NotFound,
	validateSearch: z.object({
		page: z.prefault(z.coerce.number(), defaultSearchValues.page),
	}),
	search: {
		middlewares: [stripSearchParams(defaultSearchValues)],
	},
	loaderDeps: ({ search: { page } }) => ({ page }),
	loader: async ({ params, deps: { page }, context }) => {
		const { id } = params

		if (id === 'latest') {
			const blockNumber = await fetchLatestBlock()
			throw redirect({ to: '/block/$id', params: { id: String(blockNumber) } })
		}

		try {
			let blockRef: BlockIdentifier
			if (isHex(id)) {
				Hex.assert(id)
				blockRef = { kind: 'hash', blockHash: id }
			} else {
				const parsedNumber = Number(id)
				if (!Number.isSafeInteger(parsedNumber)) throw notFound()
				blockRef = { kind: 'number', blockNumber: BigInt(parsedNumber) }
			}

			return await context.queryClient.ensureQueryData(
				blockDetailQueryOptions(blockRef, page),
			)
		} catch (error) {
			console.error(error)
			throw notFound({
				routeId: rootRouteId,
				data: {
					error: error instanceof Error ? error.message : 'Invalid block ID',
				},
			})
		}
	},
})

function RouteComponent() {
	const { page } = Route.useSearch()
	const loaderData = Route.useLoaderData()

	const { data } = useQuery({
		...blockDetailQueryOptions(loaderData.blockRef, page),
		initialData: loaderData.page === page ? loaderData : undefined,
	})

	const { block, knownEventsByHash } = data ?? loaderData

	const [chain] = useChains()
	const decimals = chain?.nativeCurrency.decimals ?? 18
	const symbol = chain?.nativeCurrency.symbol ?? 'UNIT'

	const allTransactions = block?.transactions ?? []
	const startIndex = (page - 1) * TRANSACTIONS_PER_PAGE
	const transactions = allTransactions.slice(
		startIndex,
		startIndex + TRANSACTIONS_PER_PAGE,
	)

	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	return (
		<div
			className={cx(
				'max-[800px]:flex max-[800px]:flex-col max-[800px]:pt-10 max-[800px]:pb-8 w-full',
				'grid w-full pt-20 pb-16 px-4 gap-[14px] min-w-0 grid-cols-[auto_1fr] min-[1240px]:max-w-[1280px]',
			)}
		>
			<div className="self-start max-[800px]:self-stretch">
				<BlockCard block={block} />
			</div>
			<Sections
				mode={mode}
				sections={[
					{
						title: 'Transactions',
						totalItems: allTransactions.length,
						itemsLabel: 'txns',
						autoCollapse: false,
						content: (
							<TransactionsSection
								transactions={transactions}
								knownEventsByHash={knownEventsByHash}
								decimals={decimals}
								symbol={symbol}
								page={page}
								totalItems={allTransactions.length}
								startIndex={startIndex}
							/>
						),
					},
				]}
			/>
		</div>
	)
}

function getTransactionType(
	transaction: BlockTransaction,
): TransactionTypeResult {
	// System transactions have from address as 0x0000...0000
	if (transaction.from === zeroAddress) {
		const systemTxNames: Record<string, string> = {
			'0x3000000000000000000000000000000000000000': 'Rewards Registry',
			'0xfeec000000000000000000000000000000000000': 'Fee Manager',
			'0xdec0000000000000000000000000000000000000': 'Stablecoin Exchange',
			'0x0000000000000000000000000000000000000000': 'Subblock Metadata',
		}
		const to = transaction.to || ''
		const name = systemTxNames[to] || 'System'
		return { type: 'system', label: name }
	}

	// Check for sub-block transactions (nonce starts with 0x5b)
	const nonceHex = transaction.nonce?.toString(16).padStart(8, '0') || ''
	if (nonceHex.startsWith('5b'))
		return { type: 'sub-block', label: 'Sub-block' }

	// Check for fee token transactions (type 0x76)
	// @ts-expect-error - check transaction type field
	if (transaction.type === '0x76' || transaction.type === 118) {
		return { type: 'fee-token', label: 'Fee Token' }
	}

	return { type: 'regular', label: 'Regular' }
}

const GAS_DECIMALS = 18

function TransactionsSection(props: TransactionsSectionProps) {
	const {
		transactions,
		knownEventsByHash,
		decimals,
		symbol,
		page,
		totalItems,
		startIndex,
	} = props

	const cols = [
		{ label: 'Index', align: 'start', width: '0.5fr' },
		{ label: 'Description', align: 'start', width: '3fr' },
		{ label: 'From', align: 'end', width: '1.5fr' },
		{ label: 'Hash', align: 'end', width: '1.5fr' },
		{ label: 'Fee', align: 'end', width: '1fr' },
		{ label: 'Total', align: 'end', width: '1fr' },
	] satisfies DataGrid.Props['columns']['stacked']

	return (
		<DataGrid
			columns={{ stacked: cols, tabs: cols }}
			items={() =>
				transactions.map((transaction, index) => {
					const transactionIndex =
						(transaction.transactionIndex ?? null) !== null
							? Number(transaction.transactionIndex) + 1
							: startIndex + index + 1

					const txType = getTransactionType(transaction)
					const knownEvents = transaction.hash
						? knownEventsByHash[transaction.hash]
						: undefined

					const fee = getEstimatedFee(transaction)
					const feeValue = fee ? Number(Value.format(fee, GAS_DECIMALS)) : 0
					const feeDisplay =
						feeValue > 0 ? PriceFormatter.format(feeValue) : '—'

					const txValue = transaction.value ?? 0n
					const totalValue = Number(Value.format(txValue, decimals))
					const totalDisplay =
						totalValue > 0 ? PriceFormatter.format(totalValue) : '—'

					const amountDisplay = PriceFormatter.formatNativeAmount(
						txValue,
						decimals,
						symbol,
					)

					return {
						cells: [
							<span key="index" className="text-tertiary tabular-nums">
								[{transactionIndex}]
							</span>,
							<TransactionDescription
								key="desc"
								transaction={transaction}
								amountDisplay={amountDisplay}
								knownEvents={knownEvents}
							/>,
							txType.type === 'system' ? (
								<span key="from" className="text-tertiary whitespace-nowrap">
									{txType.label}
								</span>
							) : (
								<AddressLink
									key="from"
									address={transaction.from}
									chars={4}
									className="text-accent press-down"
								/>
							),
							transaction.hash ? (
								<Link
									key="hash"
									to="/receipt/$hash"
									params={{ hash: transaction.hash }}
									className="text-accent hover:underline press-down"
									title={transaction.hash}
								>
									<TruncatedHash hash={transaction.hash} minChars={6} />
								</Link>
							) : (
								<span key="hash" className="text-tertiary">
									—
								</span>
							),
							<span key="fee" className="text-tertiary">
								{feeDisplay}
							</span>,
							<span
								key="total"
								className={totalValue > 0 ? 'text-primary' : 'text-tertiary'}
							>
								{totalDisplay}
							</span>,
						],
						link: transaction.hash
							? {
									href: `/tx/${transaction.hash}`,
									title: `View transaction ${transaction.hash}`,
								}
							: undefined,
					}
				})
			}
			totalItems={totalItems}
			page={page}
			isPending={false}
			itemsLabel="transactions"
			itemsPerPage={TRANSACTIONS_PER_PAGE}
			emptyState="No transactions were included in this block."
		/>
	)
}

interface TransactionsSectionProps {
	transactions: BlockTransaction[]
	knownEventsByHash: Record<Hex.Hex, KnownEvent[]>
	decimals: number
	symbol: string
	page: number
	totalItems: number
	startIndex: number
}

function TransactionDescription(props: TransactionDescriptionProps) {
	const { transaction, amountDisplay, knownEvents } = props

	const decodedCall = React.useMemo(() => {
		const data = transaction.input
		if (!data || data === '0x') return undefined
		try {
			return decodeFunctionData({ abi: combinedAbi, data })
		} catch {
			return undefined
		}
	}, [transaction.input])

	const selector = transaction.input?.slice(0, 10)

	const { title, subtitle } = React.useMemo(() => {
		if (!decodedCall)
			return {
				title: selector ?? 'Call',
				subtitle: undefined,
			}

		if (decodedCall.functionName === 'finalizeStreams') {
			const ts = decodedCall.args?.[0]
			const asBigInt = typeof ts === 'bigint' ? ts : undefined
			return {
				title: 'Finalize reward streams',
				subtitle:
					asBigInt !== undefined
						? `at ${DateFormatter.format(asBigInt)} (unix ${asBigInt})`
						: undefined,
			}
		}

		if (decodedCall.functionName === 'executeBlock') {
			return {
				title: 'Execute orderbook block',
				subtitle: 'Settle stablecoin exchange batch',
			}
		}

		return {
			title: decodedCall.functionName
				? `${decodedCall.functionName}()`
				: (selector ?? 'Call'),
			subtitle: undefined,
		}
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [decodedCall?.functionName, decodedCall?.args, selector, decodedCall])

	// Contract creation takes priority - check before known events
	// (contract constructors often emit Transfer events that would otherwise show)
	if (!transaction.to) {
		if (knownEvents && knownEvents.length > 0) {
			// Prioritize "create token" events for contract deployments as they're more descriptive
			const tokenCreationEvent = knownEvents.find(
				(e) => e.type === 'create token',
			)
			const primaryEvent = tokenCreationEvent ?? knownEvents[0]
			const otherEvents = knownEvents.filter((e) => e !== primaryEvent)
			const reorderedEvents = [primaryEvent, ...otherEvents]

			return (
				<TxEventDescription.ExpandGroup
					events={reorderedEvents}
					limitFilter={preferredEventsFilter}
				/>
			)
		}
		return <span className="text-primary">Deploy contract</span>
	}

	if (knownEvents && knownEvents.length > 0) {
		return (
			<TxEventDescription.ExpandGroup
				events={knownEvents}
				limitFilter={preferredEventsFilter}
			/>
		)
	}

	if (transaction.value === 0n)
		return (
			<div className="flex flex-col gap-[2px]">
				<span className="text-primary whitespace-nowrap">
					{title}{' '}
					<AddressLink
						address={transaction.to}
						chars={4}
						className="text-accent press-down"
					/>
				</span>
				{subtitle && (
					<span className="text-base-content-secondary text-[12px]">
						{subtitle}
					</span>
				)}
			</div>
		)

	return (
		<span className="text-primary whitespace-nowrap">
			Send <span className="text-base-content-positive">{amountDisplay}</span>{' '}
			to{' '}
			<AddressLink
				address={transaction.to}
				chars={4}
				className="text-accent press-down"
			/>
		</span>
	)
}

interface TransactionDescriptionProps {
	transaction: BlockTransaction
	amountDisplay: string
	knownEvents?: KnownEvent[]
}

function getEstimatedFee(transaction: BlockTransaction) {
	const gasPrice =
		transaction.gasPrice ??
		('maxFeePerGas' in transaction && transaction.maxFeePerGas
			? transaction.maxFeePerGas
			: 0n)
	return gasPrice * (transaction.gas ?? 0n)
}

```

## File: apps/explorer/src/routes/_layout/blocks.tsx
```
import { keepPreviousData, useQuery } from '@tanstack/react-query'
import { createFileRoute, Link } from '@tanstack/react-router'
import * as React from 'react'
import type { Block } from 'viem'
import { useBlock, useWatchBlockNumber } from 'wagmi'
import { getBlock } from 'wagmi/actions'
import * as z from 'zod/mini'
import { Pagination } from '#comps/Pagination'
import { FormattedTimestamp, useTimeFormat } from '#comps/TimeFormat'
import { TruncatedHash } from '#comps/TruncatedHash'
import { cx } from '#cva.config.ts'
import { BLOCKS_PER_PAGE, blocksQueryOptions } from '#lib/queries'
import { config } from '#wagmi.config.ts'
import Play from '~icons/lucide/play'

// Track which block numbers are "new" for animation purposes
const recentlyAddedBlocks = new Set<string>()

export const Route = createFileRoute('/_layout/blocks')({
	component: RouteComponent,
	validateSearch: z.object({
		page: z.prefault(z.coerce.number(), 1),
		live: z.prefault(z.coerce.boolean(), true),
	}),
	loaderDeps: ({ search: { page, live } }) => ({ page, live }),
	loader: async ({ deps, context }) =>
		context.queryClient.ensureQueryData(blocksQueryOptions(deps.page)),
})

function RouteComponent() {
	const { page = 1, live = true } = Route.useSearch()
	const loaderData = Route.useLoaderData()

	const { data: queryData } = useQuery({
		...blocksQueryOptions(page),
		initialData: loaderData,
	})

	const [latestBlockNumber, setLatestBlockNumber] = React.useState<
		bigint | undefined
	>()
	// Initialize with loader data to prevent layout shift
	const [liveBlocks, setLiveBlocks] = React.useState<Block[]>(() =>
		queryData.blocks.slice(0, BLOCKS_PER_PAGE),
	)
	const { timeFormat, cycleTimeFormat, formatLabel } = useTimeFormat()

	// Use loader data for initial render, then live updates
	const currentLatest = latestBlockNumber ?? queryData.latestBlockNumber

	// Watch for new blocks (only on page 1 when live)
	useWatchBlockNumber({
		pollingInterval: 500, // Fast polling for snappy updates
		enabled: live && page === 1,
		onBlockNumber: (blockNumber) => {
			// Only update if this is actually a new block
			if (latestBlockNumber === undefined || blockNumber > latestBlockNumber) {
				setLatestBlockNumber(blockNumber)
				// Only mark as recently added for animation on page 1
				if (page === 1) {
					recentlyAddedBlocks.add(blockNumber.toString())
					// Clear the animation flag after animation completes
					setTimeout(() => {
						recentlyAddedBlocks.delete(blockNumber.toString())
					}, 400)
				}
			}
		},
	})

	// Fetch the latest block when block number changes (for live updates on page 1)
	const { data: latestBlock } = useBlock({
		blockNumber: latestBlockNumber,
		query: {
			enabled: live && page === 1 && latestBlockNumber !== undefined,
			staleTime: Number.POSITIVE_INFINITY, // Block data never changes
		},
	})

	// Add new blocks as they arrive
	React.useEffect(() => {
		if (!live || page !== 1 || !latestBlock) return

		setLiveBlocks((prev) => {
			// Don't add if already exists
			if (prev.some((b) => b.number === latestBlock.number)) return prev
			// Prepend new block and keep only BLOCKS_PER_PAGE
			return [latestBlock, ...prev].slice(0, BLOCKS_PER_PAGE)
		})
	}, [latestBlock, live, page])

	// Re-initialize when navigating back to page 1 with live mode
	React.useEffect(() => {
		if (page === 1 && live && queryData.blocks) {
			setLiveBlocks((prev) => {
				// Only reinitialize if we have no blocks or stale data
				if (prev.length === 0) {
					return queryData.blocks.slice(0, BLOCKS_PER_PAGE)
				}
				return prev
			})
		}
	}, [page, live, queryData.blocks])

	// Calculate which blocks to show for this page
	const startBlock = currentLatest
		? currentLatest - BigInt((page - 1) * BLOCKS_PER_PAGE)
		: undefined

	// Fetch blocks for non-page-1 or when live is off
	const { data: fetchedBlocks, isLoading: isFetching } = useQuery({
		queryKey: ['blocks', page, startBlock?.toString()],
		queryFn: async () => {
			if (!startBlock || !currentLatest) return []

			const blockNumbers: bigint[] = []
			for (let i = 0n; i < BigInt(BLOCKS_PER_PAGE); i++) {
				const blockNum = startBlock - i
				if (blockNum >= 0n) blockNumbers.push(blockNum)
			}

			const results = await Promise.all(
				blockNumbers.map((blockNumber) =>
					getBlock(config, { blockNumber }).catch(() => null),
				),
			)

			return results.filter(Boolean) as Block[]
		},
		enabled:
			!!startBlock &&
			!!currentLatest &&
			(page !== 1 || !live || liveBlocks.length === 0),
		staleTime: page === 1 && live ? 0 : 60_000,
		placeholderData: keepPreviousData,
	})

	// Use live blocks on page 1 when live, otherwise use fetched/loader data
	const blocks = React.useMemo(() => {
		if (page === 1 && live && liveBlocks.length > 0) {
			return liveBlocks
		}
		return fetchedBlocks ?? (page === 1 ? queryData.blocks : undefined)
	}, [page, live, liveBlocks, fetchedBlocks, queryData.blocks])

	const isLoading = !blocks && isFetching

	const totalBlocks = currentLatest ? Number(currentLatest) + 1 : 0
	const totalPages = Math.ceil(totalBlocks / BLOCKS_PER_PAGE)

	return (
		<div className="flex flex-col gap-6 px-6 py-8 max-w-[1200px] mx-auto w-full">
			<section
				className={cx(
					'flex flex-col font-mono w-full overflow-hidden',
					'rounded-[10px] border border-card-border bg-card',
					'shadow-[0px_4px_44px_rgba(0,0,0,0.05)]',
				)}
			>
				<div className="overflow-x-auto">
					{/* Header */}
					<div className="grid grid-cols-[100px_minmax(150px,1fr)_auto_50px] gap-4 px-4 py-3 border-b border-card-border bg-card-header text-[12px] text-tertiary uppercase min-w-[500px]">
						<div>Block</div>
						<div>Hash</div>
						<div className="text-right min-w-[120px]">
							<button
								type="button"
								onClick={cycleTimeFormat}
								className="text-secondary hover:text-accent cursor-pointer transition-colors"
								title={`Showing ${formatLabel} time - click to change`}
							>
								Time
							</button>
						</div>
						<div className="text-right">Txns</div>
					</div>

					{/* Blocks list */}
					<div className="flex flex-col min-w-[500px]">
						{isLoading ? (
							<div className="px-4 py-8 text-center text-tertiary">
								Loading blocks…
							</div>
						) : blocks && blocks.length > 0 ? (
							blocks.map((block, index) => (
								<BlockRow
									key={block.number?.toString()}
									block={block}
									isNew={recentlyAddedBlocks.has(
										block.number?.toString() ?? '',
									)}
									isLatest={live && page === 1 && index === 0}
									timeFormat={timeFormat}
								/>
							))
						) : (
							<div className="px-4 py-8 text-center text-tertiary">
								No blocks found
							</div>
						)}
					</div>
				</div>

				<div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-[12px] border-t border-dashed border-card-border px-[16px] py-[12px] text-[12px] text-tertiary">
					<Pagination.Simple
						page={page}
						totalPages={totalPages}
						isPending={isLoading}
					/>
					<div className="flex items-center justify-center sm:justify-end gap-[12px]">
						<Link
							to="."
							resetScroll={false}
							search={(prev) => ({ ...prev, live: !live })}
							className={cx(
								'flex items-center gap-[6px] px-[10px] py-[5px] rounded-[6px] text-[12px] font-medium transition-colors',
								live
									? 'bg-positive/10 text-positive hover:bg-positive/20'
									: 'bg-base-alt text-tertiary hover:bg-base-alt/80',
							)}
							title={live ? 'Pause live updates' : 'Resume live updates'}
						>
							{live ? (
								<>
									<span className="relative flex size-[8px]">
										<span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-positive opacity-75" />
										<span className="relative inline-flex rounded-full size-[8px] bg-positive" />
									</span>
									<span>Live</span>
								</>
							) : (
								<>
									<Play className="size-[12px]" />
									<span>Paused</span>
								</>
							)}
						</Link>
						<Pagination.Count totalItems={totalBlocks} itemsLabel="blocks" />
					</div>
				</div>
			</section>
		</div>
	)
}

function BlockRow({
	block,
	isNew,
	isLatest,
	timeFormat,
}: {
	block: Block
	isNew?: boolean
	isLatest?: boolean
	timeFormat: 'relative' | 'local' | 'utc' | 'unix'
}) {
	const txCount = block.transactions?.length ?? 0
	const blockNumber = block.number?.toString() ?? '0'
	const blockHash = block.hash ?? '0x'

	return (
		<div
			className={cx(
				'grid grid-cols-[100px_minmax(150px,1fr)_auto_50px] gap-4 px-4 py-3 text-[13px] hover:bg-base-alt/50 border-b border-dashed border-card-border last:border-b-0',
				isNew && 'bg-positive/5',
			)}
		>
			<div className="tabular-nums">
				<Link
					to="/block/$id"
					params={{ id: blockNumber }}
					className="text-accent press-down font-medium"
				>
					#{blockNumber}
				</Link>
			</div>
			<div className="min-w-0">
				<Link
					to="/block/$id"
					params={{ id: blockHash }}
					className="text-secondary hover:text-accent transition-colors"
					title={blockHash}
				>
					<TruncatedHash hash={blockHash} minChars={8} />
				</Link>
			</div>
			<div className="text-right text-secondary tabular-nums min-w-[120px]">
				{isLatest ? (
					'now'
				) : (
					<FormattedTimestamp timestamp={block.timestamp} format={timeFormat} />
				)}
			</div>
			<div className="text-right text-secondary tabular-nums">{txCount}</div>
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/demo/address.tsx
```
import { ClientOnly, createFileRoute, notFound } from '@tanstack/react-router'
import { Hex } from 'ox'
import * as React from 'react'
import { Abis } from 'tempo.ts/viem'
import type { RpcTransaction as Transaction, TransactionReceipt } from 'viem'
import { encodeAbiParameters, encodeEventTopics } from 'viem'
import { DataGrid } from '#comps/DataGrid'
import { InfoCard } from '#comps/InfoCard'
import { RelativeTime } from '#comps/RelativeTime'
import { Sections } from '#comps/Sections'
import { TruncatedHash } from '#comps/TruncatedHash'
import { TxEventDescription } from '#comps/TxEventDescription'
import {
	getPerspectiveEvent,
	TransactionFee,
	TransactionTimestamp,
	TransactionTotal,
} from '#comps/TxTransactionRow'
import { cx } from '#cva.config.ts'
import {
	accountAddress,
	adminAddress,
	baseTimestamp,
	baseTokenAddress,
	blockNumber,
	exchangeAddress,
	factoryAddress,
	feeAmmAddress,
	getTokenMetadata,
	makerAddress,
	mockLog,
	mockReceipt,
	mockTransaction,
	quoteTokenAddress,
	recipientAddress,
	registryAddress,
	spenderAddress,
	tokenAddress,
	userTokenAddress,
	validatorTokenAddress,
} from '#lib/demo'
import { type KnownEvent, parseKnownEvents } from '#lib/domain/known-events'
import { useCopy, useMediaQuery } from '#lib/hooks'
import CopyIcon from '~icons/lucide/copy'

type MockTransactionData = {
	hash: Hex.Hex
	transaction: Transaction
	receipt: TransactionReceipt
	block: { timestamp: bigint }
	knownEvents: KnownEvent[]
}

function createMockTransactions(): MockTransactionData[] {
	const transactions: MockTransactionData[] = []

	// Tx 1: Transfer with memo
	{
		const hash = `0x${'a'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'TransferWithMemo',
						args: {
							from: accountAddress,
							to: recipientAddress,
							memo: Hex.padLeft(Hex.fromString('Thanks for the coffee.'), 32),
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [150000n]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 60n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 2: Mint event
	{
		const hash = `0x${'b'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Mint',
						args: {
							to: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [500000n]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, adminAddress, hash)
		const transaction = mockTransaction(
			hash,
			adminAddress,
			tokenAddress,
			blockNumber - 10n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 300n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 3: Burn event
	{
		const hash = `0x${'c'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Burn',
						args: {
							from: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [100000n]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 20n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 600n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 4: Approval
	{
		const hash = `0x${'d'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Approval',
						args: {
							owner: accountAddress,
							spender: spenderAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [1000000n]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 30n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 1200n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 5: FeeAmm Mint
	{
		const hash = `0x${'e'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: feeAmmAddress,
					topics: encodeEventTopics({
						abi: Abis.feeAmm,
						eventName: 'Mint',
						args: {
							sender: accountAddress,
							userToken: userTokenAddress,
							validatorToken: validatorTokenAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint256' }, { type: 'uint256' }, { type: 'uint256' }],
						[1000000000n, 500000000n, 707106781n],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			feeAmmAddress,
			blockNumber - 40n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 3600n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 6: FeeAmm Burn
	{
		const hash = `0x${'f'.repeat(64)}` as const
		const logs = [
			mockLog(
				{
					address: feeAmmAddress,
					topics: encodeEventTopics({
						abi: Abis.feeAmm,
						eventName: 'Burn',
						args: {
							sender: accountAddress,
							userToken: userTokenAddress,
							validatorToken: validatorTokenAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[
							{ type: 'uint256' },
							{ type: 'uint256' },
							{ type: 'uint256' },
							{ type: 'address' },
						],
						[250000000n, 125000000n, 176776695n, recipientAddress],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			feeAmmAddress,
			blockNumber - 50n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 7200n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 7: Rebalance Swap
	{
		const hash = `0x${'1'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: feeAmmAddress,
					topics: encodeEventTopics({
						abi: Abis.feeAmm,
						eventName: 'RebalanceSwap',
						args: {
							userToken: userTokenAddress,
							validatorToken: validatorTokenAddress,
							swapper: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint256' }, { type: 'uint256' }],
						[100000000n, 95000000n],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			feeAmmAddress,
			blockNumber - 60n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 14400n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 8: Order Placed
	{
		const hash = `0x${'2'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: exchangeAddress,
					topics: encodeEventTopics({
						abi: Abis.stablecoinExchange,
						eventName: 'OrderPlaced',
						args: {
							orderId: 123n,
							maker: accountAddress,
							token: baseTokenAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint128' }, { type: 'bool' }, { type: 'int16' }],
						[1000000n, true, 100],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			exchangeAddress,
			blockNumber - 70n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 28800n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 9: Order Filled
	{
		const hash = `0x${'3'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: exchangeAddress,
					topics: encodeEventTopics({
						abi: Abis.stablecoinExchange,
						eventName: 'OrderFilled',
						args: {
							orderId: 123n,
							maker: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint128' }, { type: 'bool' }],
						[500000n, false],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			makerAddress,
			exchangeAddress,
			blockNumber - 80n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 43200n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 10: Whitelist Updated
	{
		const hash = `0x${'4'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: registryAddress,
					topics: encodeEventTopics({
						abi: Abis.tip403Registry,
						eventName: 'WhitelistUpdated',
						args: {
							policyId: 10n,
							updater: adminAddress,
							account: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'bool' }], [true]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, adminAddress, hash)
		const transaction = mockTransaction(
			hash,
			adminAddress,
			registryAddress,
			blockNumber - 90n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 86400n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 11: Role Membership Updated
	{
		const hash = `0x${'5'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'RoleMembershipUpdated',
						args: {
							role: Hex.padLeft('0x03', 32),
							account: accountAddress,
							sender: adminAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'bool' }], [true]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, adminAddress, hash)
		const transaction = mockTransaction(
			hash,
			adminAddress,
			tokenAddress,
			blockNumber - 100n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 172800n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 12: Token Created
	{
		const hash = `0x${'6'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: factoryAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20Factory,
						eventName: 'TokenCreated',
						args: {
							token: tokenAddress,
							tokenId: 1n,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[
							{ type: 'string' },
							{ type: 'string' },
							{ type: 'string' },
							{ type: 'address' },
							{ type: 'address' },
						],
						['Test Token 2', 'TEST2', 'USD', userTokenAddress, accountAddress],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			factoryAddress,
			blockNumber - 110n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 259200n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 13: Pause State Update
	{
		const hash = `0x${'7'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'PauseStateUpdate',
						args: {
							updater: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'bool' }], [true]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 120n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 345600n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 14: Transfer Policy Update
	{
		const hash = `0x${'8'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'TransferPolicyUpdate',
						args: {
							updater: accountAddress,
							newPolicyId: 5n,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 130n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 432000n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 15: Supply Cap Update
	{
		const hash = `0x${'9'.repeat(63)}0` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'SupplyCapUpdate',
						args: {
							updater: accountAddress,
							newSupplyCap: 1000000000000000n,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 140n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 518400n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 16: Multi-event - Transfer + Approval + Role update
	{
		const hash = `0x${'ab'.repeat(32)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Transfer',
						args: {
							from: accountAddress,
							to: recipientAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [250000n]),
				},
				hash,
			),
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Approval',
						args: {
							owner: accountAddress,
							spender: spenderAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [500000n]),
				},
				hash,
			),
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'RoleMembershipUpdated',
						args: {
							role: Hex.padLeft('0x01', 32),
							account: recipientAddress,
							sender: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'bool' }], [true]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			tokenAddress,
			blockNumber - 5n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 30n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 17: Multi-event - Mint + Transfer + Burn (complex token flow)
	{
		const hash = `0x${'cd'.repeat(32)}` as const
		const logs = [
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Mint',
						args: {
							to: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [1000000n]),
				},
				hash,
			),
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Transfer',
						args: {
							from: accountAddress,
							to: recipientAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [300000n]),
				},
				hash,
			),
			mockLog(
				{
					address: tokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Burn',
						args: {
							from: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [200000n]),
				},
				hash,
			),
			mockLog(
				{
					address: userTokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Transfer',
						args: {
							from: recipientAddress,
							to: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [50000000n]),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, adminAddress, hash)
		const transaction = mockTransaction(
			hash,
			adminAddress,
			tokenAddress,
			blockNumber - 3n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 15n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	// Tx 18: Multi-event - Exchange order flow (5 events)
	{
		const hash = `0x${'ef'.repeat(32)}` as const
		const logs = [
			mockLog(
				{
					address: exchangeAddress,
					topics: encodeEventTopics({
						abi: Abis.stablecoinExchange,
						eventName: 'OrderPlaced',
						args: {
							orderId: 456n,
							maker: accountAddress,
							token: baseTokenAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint128' }, { type: 'bool' }, { type: 'int16' }],
						[5000000n, true, 101],
					),
				},
				hash,
			),
			mockLog(
				{
					address: exchangeAddress,
					topics: encodeEventTopics({
						abi: Abis.stablecoinExchange,
						eventName: 'OrderFilled',
						args: {
							orderId: 456n,
							maker: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint128' }, { type: 'bool' }],
						[2500000n, false],
					),
				},
				hash,
			),
			mockLog(
				{
					address: baseTokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Transfer',
						args: {
							from: accountAddress,
							to: makerAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [2500000n]),
				},
				hash,
			),
			mockLog(
				{
					address: quoteTokenAddress,
					topics: encodeEventTopics({
						abi: Abis.tip20,
						eventName: 'Transfer',
						args: {
							from: makerAddress,
							to: accountAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters([{ type: 'uint256' }], [2525000n]),
				},
				hash,
			),
			mockLog(
				{
					address: feeAmmAddress,
					topics: encodeEventTopics({
						abi: Abis.feeAmm,
						eventName: 'FeeSwap',
						args: {
							userToken: userTokenAddress,
							validatorToken: validatorTokenAddress,
						},
					}) as [Hex.Hex, ...Hex.Hex[]],
					data: encodeAbiParameters(
						[{ type: 'uint256' }, { type: 'uint256' }],
						[25000n, 24500n],
					),
				},
				hash,
			),
		]
		const receipt = mockReceipt(logs, accountAddress, hash)
		const transaction = mockTransaction(
			hash,
			accountAddress,
			exchangeAddress,
			blockNumber - 2n,
		)
		transactions.push({
			hash,
			transaction,
			receipt,
			block: { timestamp: baseTimestamp - 5n },
			knownEvents: parseKnownEvents(receipt, { transaction, getTokenMetadata }),
		})
	}

	return transactions
}

function loader() {
	if (import.meta.env.VITE_ENABLE_DEMO !== 'true') throw notFound()

	const transactions = createMockTransactions()
	const knownEvents: Record<Hex.Hex, KnownEvent[]> = {}
	for (const tx of transactions) {
		knownEvents[tx.hash] = tx.knownEvents
	}

	return {
		transactions,
		total: transactions.length,
		knownEvents,
	}
}

export const Route = createFileRoute('/_layout/demo/address')({
	component: Component,
	loader,
})

function Component() {
	const { transactions, total, knownEvents } = Route.useLoaderData()
	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'
	const { copy, notifying } = useCopy()
	const [expandedTxs, setExpandedTxs] = React.useState<Set<Hex.Hex>>(new Set())

	const historyColumns: DataGrid.Column[] = [
		{ label: 'Time', align: 'start', minWidth: 100 },
		{ label: 'Description', align: 'start' },
		{ label: 'Hash', align: 'end' },
		{ label: 'Fee', align: 'end' },
		{ label: 'Total', align: 'end' },
	]

	return (
		<div
			className={cx(
				'max-[800px]:flex max-[800px]:flex-col max-w-[800px]:pt-10 max-w-[800px]:pb-8 w-full',
				'grid w-full pt-20 pb-16 px-4 gap-[14px] min-w-0 grid-cols-[auto_1fr] min-[1240px]:max-w-[1080px]',
			)}
		>
			<InfoCard
				title="Account"
				className="self-start"
				sections={[
					<button
						key="address"
						type="button"
						onClick={() => copy(accountAddress)}
						className="w-full text-left cursor-pointer press-down text-tertiary"
						title={accountAddress}
					>
						<div className="flex items-center gap-[8px] mb-[8px]">
							<span className="text-[13px] font-normal capitalize">
								Address
							</span>
							<div className="relative flex items-center">
								<CopyIcon className="w-[12px] h-[12px]" />
								{notifying && (
									<span className="absolute left-[calc(100%+8px)] text-[13px] leading-[16px]">
										copied
									</span>
								)}
							</div>
						</div>
						<p className="text-[14px] font-normal leading-[17px] tracking-[0.02em] text-primary break-all max-w-[22ch]">
							{accountAddress}
						</p>
					</button>,
					{
						label: 'Active',
						value: (
							<ClientOnly
								fallback={<span className="text-tertiary text-[13px]">…</span>}
							>
								<RelativeTime
									timestamp={baseTimestamp - 60n}
									className="text-[13px] text-primary"
								/>
							</ClientOnly>
						),
					},
					{
						label: 'Holdings',
						value: (
							<ClientOnly
								fallback={<span className="text-tertiary text-[13px]">…</span>}
							>
								<span className="text-[13px] text-primary">$1,234,567.00</span>
							</ClientOnly>
						),
					},
					{
						label: 'Created',
						value: (
							<ClientOnly
								fallback={<span className="text-tertiary text-[13px]">…</span>}
							>
								<RelativeTime
									timestamp={baseTimestamp - 518400n}
									className="text-[13px] text-primary"
								/>
							</ClientOnly>
						),
					},
				]}
			/>
			<Sections
				mode={mode}
				sections={[
					{
						title: 'History',
						totalItems: total,
						itemsLabel: 'transactions',
						content: (
							<DataGrid
								columns={{
									stacked: historyColumns,
									tabs: historyColumns,
								}}
								items={() =>
									transactions.map((tx) => {
										const events = knownEvents[tx.hash] ?? []
										const isExpanded = expandedTxs.has(tx.hash)
										const perspectiveEvents = events.map((event) =>
											getPerspectiveEvent(event, accountAddress),
										)

										const descriptionCell = isExpanded ? (
											perspectiveEvents.map((event, i) => {
												const key = `${event.type}-${i}`
												return (
													<TxEventDescription
														key={key}
														event={event}
														seenAs={accountAddress}
														className="flex flex-row items-center gap-[6px] leading-[18px] w-auto flex-wrap"
													/>
												)
											})
										) : (
											<div
												key="collapsed"
												className="text-primary h-[20px] flex items-center whitespace-nowrap"
											>
												{perspectiveEvents[0] && (
													<TxEventDescription
														event={perspectiveEvents[0]}
														seenAs={accountAddress}
														className="flex flex-row items-center gap-[6px] leading-[18px] w-auto justify-center flex-nowrap"
													/>
												)}
												{events.length > 1 && (
													<button
														type="button"
														onClick={(e) => {
															e.preventDefault()
															e.stopPropagation()
															setExpandedTxs((prev) =>
																new Set(prev).add(tx.hash),
															)
														}}
														className="ml-1 text-base-content-secondary cursor-pointer press-down shrink-0"
													>
														and {events.length - 1} more
													</button>
												)}
											</div>
										)

										return {
											cells: [
												<TransactionTimestamp
													key="time"
													timestamp={tx.block.timestamp}
													link={`/receipt/${tx.hash}`}
												/>,
												descriptionCell,
												<TruncatedHash
													key="hash"
													hash={tx.hash}
													minChars={8}
												/>,
												<TransactionFee key="fee" receipt={tx.receipt} />,
												<TransactionTotal
													key="total"
													transaction={tx.transaction}
												/>,
											],
											link: {
												href: `/receipt/${tx.hash}`,
												title: `View receipt ${tx.hash}`,
											},
											expanded: isExpanded,
										}
									})
								}
								totalItems={total}
								page={1}
								isPending={false}
								itemsLabel="transactions"
								itemsPerPage={total}
							/>
						),
					},
				]}
				activeSection={0}
				onSectionChange={() => {}}
			/>
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/demo/empty-state.tsx
```
import { createFileRoute, notFound } from '@tanstack/react-router'
import { DataGrid } from '#comps/DataGrid'
import { Sections } from '#comps/Sections'
import { useMediaQuery } from '#lib/hooks'

function loader() {
	if (import.meta.env.VITE_ENABLE_DEMO !== 'true') throw notFound()
	return {}
}

export const Route = createFileRoute('/_layout/demo/empty-state')({
	component: Component,
	loader,
})

function Component() {
	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	const columns: DataGrid.Column[] = [
		{ label: 'Name', align: 'start' },
		{ label: 'Status', align: 'start' },
		{ label: 'Amount', align: 'end' },
	]

	return (
		<div className="flex flex-col gap-6 px-4 pt-20 pb-16 max-w-[1200px] mx-auto w-full">
			<Sections
				mode={mode}
				sections={[
					{
						title: 'Empty State Demo',
						totalItems: 0,
						itemsLabel: 'transactions',
						content: (
							<DataGrid
								columns={{ stacked: columns, tabs: columns }}
								items={() => []}
								totalItems={0}
								page={1}
								isPending={false}
								itemsLabel="transactions"
								emptyState="No transactions found."
							/>
						),
					},
				]}
				activeSection={0}
			/>
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/demo/index.tsx
```
import { createFileRoute, Link, notFound } from '@tanstack/react-router'

const demoPages = [
	{ path: '/demo/tx', label: 'Transaction' },
	{ path: '/demo/address', label: 'Address' },
	{ path: '/demo/pagination', label: 'Pagination' },
	{ path: '/demo/empty-state', label: 'Empty State' },
]

function loader() {
	if (import.meta.env.VITE_ENABLE_DEMO !== 'true') throw notFound()
	return {}
}

export const Route = createFileRoute('/_layout/demo/')({
	component: Component,
	loader,
})

function Component() {
	return (
		<div className="font-mono text-[13px] flex flex-col items-center justify-center gap-4 pt-16 pb-8 grow">
			<h1 className="text-tertiary uppercase">Demo</h1>
			{demoPages.map((page) => (
				<Link
					key={page.path}
					to={page.path}
					className="text-primary press-down"
				>
					{page.label}
				</Link>
			))}
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/demo/pagination.tsx
```
import { createFileRoute, notFound } from '@tanstack/react-router'
import { Pagination } from '#comps/Pagination'

function loader() {
	if (import.meta.env.VITE_ENABLE_DEMO !== 'true') throw notFound()
	return {}
}

export const Route = createFileRoute('/_layout/demo/pagination')({
	component: Component,
	loader,
})

const examples = [
	{
		totalPages: 1,
		page: 1,
		totalItems: 0,
		label: '0 items, hideOnSinglePage',
		hideOnSinglePage: true,
	},
	{
		totalPages: 1,
		page: 1,
		totalItems: 1,
		label: '1 item, hideOnSinglePage',
		hideOnSinglePage: true,
	},
	{ totalPages: 1, page: 1, label: '1 page', hideOnSinglePage: false },
	{ totalPages: 2, page: 1, label: '2 pages' },
	{ totalPages: 7, page: 4, label: '7 pages' },
	{ totalPages: 999, page: 500, label: '999 pages (max before compact)' },
	{ totalPages: 1000, page: 1, label: '1,000 pages (compact: start)' },
	{ totalPages: 1000000, page: 500000, label: '1,000,000 pages (compact)' },
]

function Component() {
	return (
		<div className="font-mono text-[13px] flex flex-col items-center gap-8 pt-16 pb-8 grow">
			<h1 className="text-tertiary uppercase">Pagination</h1>
			<div className="flex flex-col gap-6 w-full max-w-[800px]">
				{examples.map((example) => (
					<div
						key={example.label}
						className="border border-card-border rounded-[10px] overflow-hidden"
					>
						<div className="px-[16px] py-[8px] bg-card-header text-tertiary text-[12px]">
							{example.label}
						</div>
						<div className="bg-card">
							<Pagination
								page={example.page}
								totalPages={example.totalPages}
								totalItems={example.totalItems ?? example.totalPages * 10}
								itemsLabel="items"
								isPending={false}
								hideOnSinglePage={example.hideOnSinglePage}
							/>
						</div>
					</div>
				))}
			</div>
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/demo/tx.tsx
```
import { createFileRoute, notFound } from '@tanstack/react-router'
import { Hex } from 'ox'
import { Abis } from 'tempo.ts/viem'
import { encodeAbiParameters, encodeEventTopics, zeroAddress } from 'viem'
import { Receipt } from '#comps/Receipt'
import {
	accountAddress,
	adminAddress,
	baseTokenAddress,
	blockNumber,
	exchangeAddress,
	factoryAddress,
	feeAmmAddress,
	getTokenMetadata,
	makerAddress,
	mockLog,
	mockReceipt,
	quoteTokenAddress,
	recipientAddress,
	registryAddress,
	spenderAddress,
	tokenAddress,
	transactionHash,
	updaterAddress,
	userTokenAddress,
	validatorAddress,
	validatorTokenAddress,
} from '#lib/demo'
import { parseKnownEvents } from '#lib/domain/known-events'

function loader() {
	if (import.meta.env.VITE_ENABLE_DEMO !== 'true') throw notFound()

	const receipt = mockReceipt(
		[
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'TransferWithMemo',
					args: {
						from: updaterAddress,
						to: recipientAddress,
						memo: Hex.padLeft(Hex.fromString('Thanks for the coffee.'), 32),
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [150000n]),
			}),
			mockLog({
				address: registryAddress,
				topics: encodeEventTopics({
					abi: Abis.tip403Registry,
					eventName: 'PolicyAdminUpdated',
					args: {
						policyId: 20n,
						updater: updaterAddress,
						admin: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'SupplyCapUpdate',
					args: {
						updater: updaterAddress,
						newSupplyCap: 1000000000000000n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'RewardScheduled',
					args: {
						funder: updaterAddress,
						id: 123n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint256' }, { type: 'uint32' }],
					[5000000n, 604800],
				),
			}),
			mockLog({
				address: zeroAddress,
				topics: encodeEventTopics({
					abi: Abis.nonce,
					eventName: 'NonceIncremented',
					args: {
						account: accountAddress,
						nonceKey: 42n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint64' }], [7n]),
			}),
			mockLog({
				address: zeroAddress,
				topics: encodeEventTopics({
					abi: Abis.nonce,
					eventName: 'ActiveKeyCountChanged',
					args: {
						account: accountAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [3n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Approval',
					args: {
						owner: updaterAddress,
						spender: spenderAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [1000000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'BurnBlocked',
					args: {
						from: accountAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [50000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'TransferPolicyUpdate',
					args: {
						updater: updaterAddress,
						newPolicyId: 5n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'NextQuoteTokenSet',
					args: {
						updater: updaterAddress,
						nextQuoteToken: userTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'QuoteTokenUpdate',
					args: {
						updater: updaterAddress,
						newQuoteToken: userTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'RewardCanceled',
					args: {
						funder: updaterAddress,
						id: 99n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [2500000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'RewardRecipientSet',
					args: {
						holder: updaterAddress,
						recipient: recipientAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'RoleAdminUpdated',
					args: {
						role: Hex.padLeft('0x01', 32),
						newAdminRole: Hex.padLeft('0x02', 32),
						sender: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: feeAmmAddress,
				topics: encodeEventTopics({
					abi: Abis.feeAmm,
					eventName: 'Mint',
					args: {
						sender: updaterAddress,
						userToken: userTokenAddress,
						validatorToken: validatorTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint256' }, { type: 'uint256' }, { type: 'uint256' }],
					[1000000000n, 500000000n, 707106781n],
				),
			}),
			mockLog({
				address: feeAmmAddress,
				topics: encodeEventTopics({
					abi: Abis.feeAmm,
					eventName: 'Burn',
					args: {
						sender: updaterAddress,
						userToken: userTokenAddress,
						validatorToken: validatorTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[
						{ type: 'uint256' },
						{ type: 'uint256' },
						{ type: 'uint256' },
						{ type: 'address' },
					],
					[250000000n, 125000000n, 176776695n, recipientAddress],
				),
			}),
			mockLog({
				address: feeAmmAddress,
				topics: encodeEventTopics({
					abi: Abis.feeAmm,
					eventName: 'RebalanceSwap',
					args: {
						userToken: userTokenAddress,
						validatorToken: validatorTokenAddress,
						swapper: updaterAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint256' }, { type: 'uint256' }],
					[100000000n, 95000000n],
				),
			}),
			mockLog({
				address: feeAmmAddress,
				topics: encodeEventTopics({
					abi: Abis.feeAmm,
					eventName: 'FeeSwap',
					args: {
						userToken: userTokenAddress,
						validatorToken: validatorTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint256' }, { type: 'uint256' }],
					[50000000n, 48500000n],
				),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Transfer',
					args: {
						from: updaterAddress,
						to: recipientAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [250000n]),
			}),
			// Test case: Mint without memo (just Mint event)
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Mint',
					args: {
						to: recipientAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [500000n]),
			}),
			// Test case: Burn without memo (just Burn event)
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Burn',
					args: {
						from: updaterAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [100000n]),
			}),
			// Test case: Mint WITH memo (Mint + TransferWithMemo pair - should dedupe to just Mint with memo)
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Mint',
					args: {
						to: accountAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [200000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'TransferWithMemo',
					args: {
						from: zeroAddress,
						to: accountAddress,
						memo: Hex.padLeft(Hex.fromString('Minted for you!'), 32),
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [200000n]),
			}),
			// Test case: Burn WITH memo (Burn + TransferWithMemo pair - should dedupe to just Burn with memo)
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'Burn',
					args: {
						from: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [75000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'TransferWithMemo',
					args: {
						from: adminAddress,
						to: zeroAddress,
						memo: Hex.padLeft(Hex.fromString('Burned by admin'), 32),
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint256' }], [75000n]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'RoleMembershipUpdated',
					args: {
						role: Hex.padLeft('0x03', 32),
						account: accountAddress,
						sender: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'bool' }], [true]),
			}),
			mockLog({
				address: tokenAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20,
					eventName: 'PauseStateUpdate',
					args: {
						updater: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'bool' }], [true]),
			}),
			mockLog({
				address: factoryAddress,
				topics: encodeEventTopics({
					abi: Abis.tip20Factory,
					eventName: 'TokenCreated',
					args: {
						token: tokenAddress,
						tokenId: 1n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[
						{ type: 'string' },
						{ type: 'string' },
						{ type: 'string' },
						{ type: 'address' },
						{ type: 'address' },
					],
					['Test Token 2', 'TEST2', 'USD', userTokenAddress, adminAddress],
				),
			}),
			mockLog({
				address: exchangeAddress,
				topics: encodeEventTopics({
					abi: Abis.stablecoinExchange,
					eventName: 'PairCreated',
					args: {
						key: Hex.padLeft('0xabc', 32),
						base: baseTokenAddress,
						quote: quoteTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: exchangeAddress,
				topics: encodeEventTopics({
					abi: Abis.stablecoinExchange,
					eventName: 'OrderPlaced',
					args: {
						orderId: 123n,
						maker: makerAddress,
						token: baseTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint128' }, { type: 'bool' }, { type: 'int16' }],
					[1000000n, true, 100],
				),
			}),
			mockLog({
				address: exchangeAddress,
				topics: encodeEventTopics({
					abi: Abis.stablecoinExchange,
					eventName: 'FlipOrderPlaced',
					args: {
						orderId: 124n,
						maker: makerAddress,
						token: baseTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[
						{ type: 'uint128' },
						{ type: 'bool' },
						{ type: 'int16' },
						{ type: 'int16' },
					],
					[2000000n, false, 105, 95],
				),
			}),
			mockLog({
				address: exchangeAddress,
				topics: encodeEventTopics({
					abi: Abis.stablecoinExchange,
					eventName: 'OrderFilled',
					args: {
						orderId: 123n,
						maker: makerAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters(
					[{ type: 'uint128' }, { type: 'bool' }],
					[500000n, false],
				),
			}),
			mockLog({
				address: exchangeAddress,
				topics: encodeEventTopics({
					abi: Abis.stablecoinExchange,
					eventName: 'OrderCancelled',
					args: {
						orderId: 124n,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: registryAddress,
				topics: encodeEventTopics({
					abi: Abis.tip403Registry,
					eventName: 'WhitelistUpdated',
					args: {
						policyId: 10n,
						updater: adminAddress,
						account: accountAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'bool' }], [true]),
			}),
			mockLog({
				address: registryAddress,
				topics: encodeEventTopics({
					abi: Abis.tip403Registry,
					eventName: 'BlacklistUpdated',
					args: {
						policyId: 10n,
						updater: adminAddress,
						account: spenderAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'bool' }], [true]),
			}),
			mockLog({
				address: registryAddress,
				topics: encodeEventTopics({
					abi: Abis.tip403Registry,
					eventName: 'PolicyCreated',
					args: {
						policyId: 15n,
						updater: adminAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
				data: encodeAbiParameters([{ type: 'uint8' }], [1]),
			}),
			mockLog({
				address: zeroAddress,
				topics: encodeEventTopics({
					abi: Abis.feeManager,
					eventName: 'UserTokenSet',
					args: {
						user: updaterAddress,
						token: userTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
			mockLog({
				address: zeroAddress,
				topics: encodeEventTopics({
					abi: Abis.feeManager,
					eventName: 'ValidatorTokenSet',
					args: {
						validator: validatorAddress,
						token: validatorTokenAddress,
					},
				}) as [Hex.Hex, ...Hex.Hex[]],
			}),
		],
		updaterAddress,
	)

	const knownEvents = parseKnownEvents(receipt, { getTokenMetadata })

	return {
		blockNumber,
		sender: updaterAddress,
		hash: transactionHash,
		timestamp: BigInt(Math.floor(Date.now() / 1000)),
		events: knownEvents,
		fee: 0.05,
		feeDisplay: '$0.05',
		total: 0.05,
		totalDisplay: '$0.05',
		rawData: JSON.stringify({ demo: true }, null, 2),
	}
}

export const Route = createFileRoute('/_layout/demo/tx')({
	component: Component,
	loader,
})

function Component() {
	const data = Route.useLoaderData()

	return (
		<div className="font-mono text-[13px] flex flex-col items-center justify-center gap-8 pt-16 pb-8 grow">
			<Receipt {...data} />
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/index.tsx
```
import {
	createFileRoute,
	Link,
	useNavigate,
	useRouter,
	useRouterState,
} from '@tanstack/react-router'
import { useEffect, useState } from 'react'
import { ExploreInput } from '#comps/ExploreInput'
import { Intro } from '#comps/Intro'

export const Route = createFileRoute('/_layout/')({
	component: Component,
})

function Component() {
	const router = useRouter()
	const navigate = useNavigate()
	const [inputValue, setInputValue] = useState('')
	const [isMounted, setIsMounted] = useState(false)
	const isNavigating = useRouterState({
		select: (state) => state.status === 'pending',
	})

	useEffect(() => setIsMounted(true), [])

	useEffect(() => {
		return router.subscribe('onResolved', ({ hrefChanged }) => {
			if (hrefChanged) setInputValue('')
		})
	}, [router])

	return (
		<div className="flex flex-1 size-full items-center justify-center text-[16px]">
			<div className="grid place-items-center relative grid-flow-row gap-[20px] select-none w-full pt-[60px] pb-[40px] z-1">
				<Intro />
				<p className="text-base-content-secondary max-w-[260px] text-center">
					View account history and transaction details on Tempo.
				</p>
				<div className="px-[16px] w-full flex justify-center">
					<ExploreInput
						autoFocus
						size="large"
						value={inputValue}
						onChange={setInputValue}
						disabled={isMounted && isNavigating}
						onActivate={(data) => {
							if (data.type === 'hash') {
								navigate({ to: '/receipt/$hash', params: { hash: data.value } })
								return
							}
							if (data.type === 'token') {
								navigate({
									to: '/token/$address',
									params: { address: data.value },
								})
								return
							}
							if (data.type === 'address') {
								navigate({
									to: '/address/$address',
									params: { address: data.value },
								})
								return
							}
						}}
					/>
				</div>
				<SpotlightLinks />
			</div>
		</div>
	)
}

function SpotlightLinks() {
	return (
		<section className="text-center">
			<span className="text-sm font-medium text-base-content-tertiary">
				Try
			</span>
			<div className="flex items-center gap-[8px] mt-2 text-[14px] text-base-content-tertiary">
				<SpotlightLink
					to="/address/$address"
					params={{ address: '0x5bc1473610754a5ca10749552b119df90c1a1877' }}
				>
					Account
				</SpotlightLink>
				<span>·</span>
				<SpotlightLink to="/blocks">Blocks</SpotlightLink>
				<span>·</span>
				<SpotlightLink to="/tokens">Tokens</SpotlightLink>
				<span>·</span>
				<SpotlightLink
					to="/receipt/$hash"
					params={{
						hash: '0x6d6d8c102064e6dee44abad2024a8b1d37959230baab80e70efbf9b0c739c4fd',
					}}
				>
					Receipt
				</SpotlightLink>
				<span>·</span>
				<SpotlightLink
					to="/tx/$hash"
					params={{
						hash: '0x6d6d8c102064e6dee44abad2024a8b1d37959230baab80e70efbf9b0c739c4fd',
					}}
				>
					Tx
				</SpotlightLink>
				<span>·</span>
				<SpotlightLink
					to="/address/$address"
					params={{
						address: '0x20fc000000000000000000000000000000000000',
					}}
				>
					Contract
				</SpotlightLink>
			</div>
		</section>
	)
}

function SpotlightLink(props: {
	to: string
	params?: Record<string, string>
	children: React.ReactNode
}) {
	const { to, params, children } = props
	return (
		<Link
			to={to}
			{...(params ? { params } : {})}
			className="text-base-content-secondary hover:text-base-content transition-colors duration-150 underline underline-offset-2 decoration-base-border hover:decoration-base-content-secondary"
		>
			{children}
		</Link>
	)
}

```

## File: apps/explorer/src/routes/_layout/receipt/$hash.tsx
```
import { env } from 'cloudflare:workers'
import puppeteer from '@cloudflare/puppeteer'
import { queryOptions, useQuery } from '@tanstack/react-query'
import { createFileRoute, notFound, rootRouteId } from '@tanstack/react-router'
import { Hex, Json, Value } from 'ox'
import { getBlock, getTransaction, getTransactionReceipt } from 'wagmi/actions'
import * as z from 'zod/mini'
import { NotFound } from '#comps/NotFound'
import { Receipt } from '#comps/Receipt'
import { parseKnownEvents } from '#lib/domain/known-events'
import { LineItems } from '#lib/domain/receipt'
import * as Tip20 from '#lib/domain/tip20'
import { DateFormatter, HexFormatter, PriceFormatter } from '#lib/formatting'
import { getConfig } from '#wagmi.config'

function receiptDetailQueryOptions(params: { hash: Hex.Hex; rpcUrl?: string }) {
	return queryOptions({
		queryKey: ['receipt-detail', params.hash, params.rpcUrl],
		queryFn: () => fetchReceiptData(params),
	})
}

async function fetchReceiptData(params: { hash: Hex.Hex; rpcUrl?: string }) {
	const config = getConfig({ rpcUrl: params.rpcUrl })
	const receipt = await getTransactionReceipt(config, {
		hash: params.hash,
	})
	const [block, transaction, getTokenMetadata] = await Promise.all([
		getBlock(config, { blockHash: receipt.blockHash }),
		getTransaction(config, { hash: receipt.transactionHash }),
		Tip20.metadataFromLogs(receipt.logs),
	])
	const timestampFormatted = DateFormatter.format(block.timestamp)

	const lineItems = LineItems.fromReceipt(receipt, { getTokenMetadata })
	const knownEvents = parseKnownEvents(receipt, {
		transaction,
		getTokenMetadata,
	})

	return {
		block,
		knownEvents,
		lineItems,
		receipt,
		timestampFormatted,
		transaction,
	}
}

function parseHashFromParams(params: unknown): Hex.Hex | null {
	const parseResult = z
		.object({
			hash: z.pipe(
				z.string(),
				z.transform(
					(val) => val.replace(/(\.json|\.txt|\.pdf)$/, '') as Hex.Hex,
				),
			),
		})
		.safeParse(params)

	if (!parseResult.success) return null

	const { hash } = parseResult.data
	if (!Hex.validate(hash) || Hex.size(hash) !== 32) return null

	return hash
}

export const Route = createFileRoute('/_layout/receipt/$hash')({
	component: Component,
	notFoundComponent: NotFound,
	headers: () => ({
		...(import.meta.env.PROD
			? {
					'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400',
				}
			: {}),
	}),
	// @ts-expect-error - TODO: fix
	loader: async ({ params, context }) => {
		try {
			const hash = parseHashFromParams(params)
			if (!hash) throw notFound()

			return await context.queryClient.ensureQueryData(
				receiptDetailQueryOptions({ hash }),
			)
		} catch (error) {
			console.error(error)
			throw notFound({
				routeId: rootRouteId,
				data: {
					error: error instanceof Error ? error.message : 'Unknown error',
				},
			})
		}
	},
	server: {
		handlers: {
			async GET({ params, request, next }) {
				const url = new URL(request.url)

				const accept = request.headers.get('accept')?.toLowerCase() || ''
				const userAgent = request.headers.get('user-agent')?.toLowerCase() || ''
				const isTerminal =
					userAgent.includes('curl') ||
					userAgent.includes('wget') ||
					userAgent.includes('httpie')

				const type = (() => {
					if (
						url.pathname.endsWith('.pdf') ||
						accept.includes('application/pdf')
					)
						return 'application/pdf'
					if (
						url.pathname.endsWith('.json') ||
						accept.includes('application/json')
					)
						return 'application/json'
					if (
						url.pathname.endsWith('.txt') ||
						isTerminal ||
						accept.includes('text/plain')
					)
						return 'text/plain'
				})()

				const rpcUrl = url.searchParams.get('r') ?? undefined
				const hash = parseHashFromParams(params)

				if (type === 'text/plain') {
					if (!hash) return new Response('Not found', { status: 404 })
					const data = await fetchReceiptData({ hash, rpcUrl })
					const text = TextRenderer.render(data)
					return new Response(text, {
						headers: {
							'Content-Type': 'text/plain; charset=utf-8',
							'Content-Disposition': 'inline',
							...(import.meta.env.PROD
								? {
										'Cache-Control':
											'public, max-age=3600, stale-while-revalidate=86400',
									}
								: {}),
						},
					})
				}

				if (type === 'application/json') {
					if (!hash)
						return Response.json({ error: 'Not found' }, { status: 404 })
					const { lineItems, receipt } = await fetchReceiptData({
						hash,
						rpcUrl,
					})
					return Response.json(
						JSON.parse(Json.stringify({ lineItems, receipt })),
					)
				}

				if (type === 'application/pdf') {
					const browser = await puppeteer.launch(env.BROWSER)
					const page = await browser.newPage()

					// Pass through authentication if present
					const authHeader = request.headers.get('Authorization')
					if (authHeader)
						await page.setExtraHTTPHeaders({
							Authorization: authHeader,
						})

					// Build the equivalent HTML URL, preserving existing query params
					const htmlUrl = new URL(url.href)
					htmlUrl.pathname = htmlUrl.pathname.replace(/\.pdf$/, '')
					htmlUrl.searchParams.set('plain', '')

					// Navigate to the HTML version of the receipt
					await page.goto(htmlUrl.toString(), { waitUntil: 'domcontentloaded' })

					// Generate PDF
					const pdf = await page.pdf({
						printBackground: true,
						format: 'A4',
					})

					await browser.close()

					return new Response(Buffer.from(pdf), {
						headers: {
							...(import.meta.env.PROD
								? {
										'Cache-Control':
											'public, max-age=3600, stale-while-revalidate=86400',
									}
								: {}),
							'Content-Type': 'application/pdf',
							'Content-Disposition': 'inline; filename="receipt.pdf"',
						},
					})
				}

				return next()
			},
		},
	},
	params: z.object({
		hash: z.pipe(
			z.string(),
			z.transform((val) => val.replace(/(\.json|\.txt|\.pdf)$/, '') as Hex.Hex),
		),
	}),
})

function Component() {
	const { hash } = Route.useParams()
	const loaderData = Route.useLoaderData() as Awaited<
		ReturnType<typeof fetchReceiptData>
	>

	const { data } = useQuery({
		...receiptDetailQueryOptions({ hash }),
		initialData: loaderData,
	})

	const { block, knownEvents, lineItems, receipt } = data

	const feePrice = lineItems.feeTotals?.[0]?.price
	const previousFee = feePrice
		? Number(Value.format(feePrice.amount, feePrice.decimals))
		: 0

	const totalPrice = lineItems.totals?.[0]?.price
	const previousTotal = totalPrice
		? Number(Value.format(totalPrice.amount, totalPrice.decimals))
		: undefined

	const feeAmount = receipt.effectiveGasPrice * receipt.gasUsed
	// Gas accounting is always in 18-decimal units (wei equivalent), even when the fee token itself
	// has a different number of decimals. Convert using 18 decimals so we get the actual token amount.
	const fee = Number(Value.format(feeAmount, 18))
	const feeDisplay = PriceFormatter.format(fee)

	const total =
		previousTotal !== undefined ? previousTotal - previousFee + fee : fee
	const totalDisplay =
		previousTotal !== undefined
			? PriceFormatter.format(previousTotal)
			: undefined

	return (
		<div className="font-mono text-[13px] flex flex-col items-center justify-center gap-8 pt-16 pb-8 grow">
			<Receipt
				blockNumber={receipt.blockNumber}
				events={knownEvents}
				fee={fee}
				feeBreakdown={lineItems.feeBreakdown}
				feeDisplay={feeDisplay}
				hash={receipt.transactionHash}
				sender={receipt.from}
				timestamp={block.timestamp}
				total={total}
				totalDisplay={totalDisplay}
			/>
		</div>
	)
}

namespace TextRenderer {
	const width = 50
	const indent = '  '

	export function render(data: Awaited<ReturnType<typeof fetchReceiptData>>) {
		const { lineItems, receipt, timestampFormatted } = data

		const lines: string[] = []

		// Header
		lines.push(center('TEMPO RECEIPT'))
		lines.push('')

		// Transaction details
		lines.push(`Tx Hash: ${HexFormatter.truncate(receipt.transactionHash, 8)}`)
		lines.push(`Date: ${timestampFormatted}`)
		lines.push(`Block: ${receipt.blockNumber.toString()}`)
		lines.push(`Sender: ${HexFormatter.truncate(receipt.from, 6)}`)
		lines.push('')
		lines.push('-'.repeat(width))
		lines.push('')

		// Main line items
		if (lineItems.main) {
			for (const item of lineItems.main) {
				// Render `left` and `right`
				lines.push(leftRight(item.ui.left.toUpperCase(), item.ui.right))

				// Render `bottom`
				if ('bottom' in item.ui && item.ui.bottom) {
					for (const bottom of item.ui.bottom) {
						if (bottom.right)
							lines.push(`${indent}${leftRight(bottom.left, bottom.right)}`)
						else lines.push(`${indent}${bottom.left}`)
					}
				}
			}

			lines.push('')
		}

		// Fee breakdown
		if (lineItems.feeBreakdown?.length) {
			for (const item of lineItems.feeBreakdown) {
				const label = item.symbol ? `Fee (${item.symbol})` : 'Fee'
				const amount = PriceFormatter.format(item.amount, {
					decimals: item.decimals,
					format: 'short',
				})
				lines.push(leftRight(label.toUpperCase(), amount))
				if (item.payer)
					lines.push(
						`${indent}Paid by: ${HexFormatter.truncate(item.payer, 6)}`,
					)
			}

			lines.push('')
		}

		// Fee totals
		if (lineItems.feeTotals)
			for (const item of lineItems.feeTotals)
				lines.push(leftRight(item.ui.left.toUpperCase(), item.ui.right))

		// Totals
		if (lineItems.totals)
			for (const item of lineItems.totals)
				lines.push(leftRight(item.ui.left.toUpperCase(), item.ui.right))

		return lines.join('\n')
	}

	function center(text: string): string {
		const padding = Math.max(0, Math.floor((width - text.length) / 2))
		return ' '.repeat(padding) + text
	}

	function leftRight(left: string, right: string): string {
		const spacing = Math.max(1, width - left.length - right.length)
		return left + ' '.repeat(spacing) + right
	}
}

```

## File: apps/explorer/src/routes/_layout/token/$address.tsx
```
import { useQuery } from '@tanstack/react-query'
import {
	ClientOnly,
	createFileRoute,
	Link,
	notFound,
	redirect,
	stripSearchParams,
	useNavigate,
	useRouter,
	useRouterState,
} from '@tanstack/react-router'
import { Address } from 'ox'
import * as React from 'react'
import { Actions, Hooks } from 'tempo.ts/wagmi'
import { formatUnits } from 'viem'
import * as z from 'zod/mini'
import { AddressCell } from '#comps/AddressCell'
import { AmountCell, BalanceCell } from '#comps/AmountCell'
import { ContractReader } from '#comps/ContractReader'
import { DataGrid } from '#comps/DataGrid'
import { InfoCard } from '#comps/InfoCard'
import { NotFound } from '#comps/NotFound'
import { Sections } from '#comps/Sections'
import { TimeColumnHeader, useTimeFormat } from '#comps/TimeFormat'
import { TimestampCell } from '#comps/TimestampCell'
import { TransactionCell } from '#comps/TransactionCell'
import { TruncatedHash } from '#comps/TruncatedHash'
import { cx } from '#cva.config.ts'
import { ellipsis } from '#lib/chars'
import { getContractInfo } from '#lib/domain/contracts'
import { PriceFormatter } from '#lib/formatting'
import { useCopy, useMediaQuery } from '#lib/hooks'
import { holdersQueryOptions, transfersQueryOptions } from '#lib/queries'
import { config } from '#wagmi.config'
import CopyIcon from '~icons/lucide/copy'
import XIcon from '~icons/lucide/x'

const defaultSearchValues = {
	page: 1,
	limit: 10,
	tab: 'transfers',
} as const

const tabOrder = ['transfers', 'holders', 'contract'] as const

type TokenMetadata = Actions.token.getMetadata.ReturnValue

export const Route = createFileRoute('/_layout/token/$address')({
	component: RouteComponent,
	notFoundComponent: NotFound,
	validateSearch: z.object({
		page: z.prefault(z.number(), defaultSearchValues.page),
		limit: z.prefault(
			z.pipe(
				z.number(),
				z.transform((val) => Math.min(100, val)),
			),
			defaultSearchValues.limit,
		),
		tab: z.prefault(
			z.pipe(
				z.string(),
				z.transform((val) => {
					if (val === 'transfers' || val === 'holders' || val === 'contract')
						return val
					return 'transfers'
				}),
			),
			defaultSearchValues.tab,
		),
		a: z.optional(z.string()),
	}),
	search: {
		middlewares: [stripSearchParams(defaultSearchValues)],
	},
	loaderDeps: ({ search: { page, limit, tab, a } }) => ({
		page,
		limit,
		tab,
		a,
	}),
	loader: async ({ deps: { page, limit, tab, a }, params, context }) => {
		const { address } = params
		if (!Address.validate(address)) throw notFound()

		const account = a && Address.validate(a) ? a : undefined
		const offset = (page - 1) * limit

		try {
			// prefetch holders in background (non-blocking) - slow query that reconstructs all balances
			// prefetch page 1 for sidebar stats, and current page for holders tab
			context.queryClient.prefetchQuery(
				holdersQueryOptions({ address, page: 1, limit: 10, offset: 0 }),
			)
			if (page !== 1 || limit !== 10) {
				context.queryClient.prefetchQuery(
					holdersQueryOptions({ address, page, limit, offset }),
				)
			}

			if (tab === 'transfers') {
				const [metadata, transfers] = await Promise.all([
					Actions.token.getMetadata(config, { token: address }),
					context.queryClient.ensureQueryData(
						transfersQueryOptions({ address, page, limit, offset, account }),
					),
				])
				return { metadata, transfers }
			}

			const metadata = await Actions.token.getMetadata(config, {
				token: address,
			})
			return { metadata, transfers: undefined }
		} catch (error) {
			console.error(error)
			// redirect to `/address/$address` and if it's not an address, that route will throw a notFound
			throw redirect({ to: '/address/$address', params: { address } })
		}
	},
	params: {
		parse: z.object({
			address: z.pipe(
				z.string(),
				z.transform((x) => {
					Address.assert(x)
					return x
				}),
			),
		}).parse,
	},
})

function RouteComponent() {
	const navigate = useNavigate()
	const route = useRouter()
	const { address } = Route.useParams()
	const { page, tab, limit, a } = Route.useSearch()
	const loaderData = Route.useLoaderData()

	React.useEffect(() => {
		// Preload only 1 page before and after to reduce API calls
		for (let i = -1; i <= 1; i++) {
			if (i === 0) continue
			const preloadPage = page + i
			if (preloadPage < 1) continue
			route.preloadRoute({
				to: '.',
				search: {
					...(preloadPage !== 1 ? { page: preloadPage } : {}),
					...(tab !== 'transfers' ? { tab } : {}),
					...(a ? { a } : {}),
					...(limit !== defaultSearchValues.limit ? { limit } : {}),
				},
			})
		}
	}, [route, page, tab, limit, a])

	const goToPage = React.useCallback(
		(newPage: number) => {
			navigate({
				to: '.',
				search: () => ({
					...(newPage !== 1 ? { page: newPage } : {}),
					...(tab !== 'transfers' ? { tab } : {}),
					...(a ? { a } : {}),
					...(limit !== defaultSearchValues.limit ? { limit } : {}),
				}),
				resetScroll: false,
			})
		},
		[navigate, tab, limit, a],
	)

	const setActiveSection = React.useCallback(
		(newIndex: number) => {
			const newTab = tabOrder[newIndex] ?? 'transfers'
			navigate({
				to: '.',
				search: () => ({
					...(newTab !== 'transfers' ? { tab: newTab } : {}),
					...(a && newTab === 'transfers' ? { a } : {}),
					...(limit !== defaultSearchValues.limit ? { limit } : {}),
				}),
				resetScroll: false,
			})
		},
		[navigate, limit, a],
	)

	const activeSection = tab === 'holders' ? 1 : tab === 'contract' ? 2 : 0

	return (
		<div
			className={cx(
				'max-[800px]:flex max-[800px]:flex-col max-w-[800px]:pt-10 max-w-[800px]:pb-8 w-full',
				'grid w-full pt-20 pb-16 px-4 gap-[14px] min-w-0 grid-cols-[auto_1fr] min-[1240px]:max-w-[1080px]',
			)}
		>
			<TokenCard
				address={address}
				className="self-start"
				initialMetadata={loaderData.metadata}
			/>
			<SectionsWrapper
				address={address}
				page={page}
				limit={limit}
				account={a}
				goToPage={goToPage}
				activeSection={activeSection}
				onSectionChange={setActiveSection}
			/>
		</div>
	)
}

function TokenCard(props: {
	address: Address.Address
	className?: string
	initialMetadata?: TokenMetadata
}) {
	const { address, className, initialMetadata } = props

	const { data: metadata } = Hooks.token.useGetMetadata({
		token: address,
		query: {
			enabled: Boolean(address),
			initialData: initialMetadata,
		},
	})

	// Fetch holders summary asynchronously (was prefetched in loader)
	const { data: holdersSummary } = useQuery(
		holdersQueryOptions({ address, page: 1, limit: 10, offset: 0 }),
	)

	const { copy, notifying } = useCopy()

	const totalSupply = holdersSummary?.totalSupply
		? BigInt(holdersSummary.totalSupply)
		: undefined
	const totalHolders = holdersSummary?.total

	return (
		<InfoCard
			title={
				<div className="flex items-center justify-between px-[18px] pt-[10px] pb-[8px]">
					<h1 className="text-[13px] uppercase text-tertiary select-none">
						Token
					</h1>
					{metadata?.symbol && (
						<h2 className="text-[13px]">{metadata.symbol}</h2>
					)}
				</div>
			}
			className={className}
			sections={[
				<button
					key="address"
					type="button"
					onClick={() => copy(address)}
					className="w-full text-left cursor-pointer press-down text-tertiary"
					title={address}
				>
					<div className="flex items-center gap-[8px] mb-[8px]">
						<span className="text-[13px] font-normal capitalize">Address</span>
						<div className="relative flex items-center">
							<CopyIcon className="w-[12px] h-[12px]" />
							{notifying && (
								<span className="absolute left-[calc(100%+8px)] text-[13px] leading-[16px]">
									copied
								</span>
							)}
						</div>
					</div>
					<p className="text-[14px] font-normal leading-[17px] tracking-[0.02em] text-primary break-all max-w-[22ch]">
						{address}
					</p>
				</button>,
				{
					label: 'Created',
					value: (
						<ClientOnly
							fallback={
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							}
						>
							<span className="text-tertiary text-[13px]">{ellipsis}</span>
						</ClientOnly>
					),
				},
				{
					label: 'Holdings',
					value: (
						<ClientOnly
							fallback={
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							}
						>
							<span className="text-[13px] text-primary">$0.00</span>
						</ClientOnly>
					),
				},
				{
					label: 'Supply',
					value: (
						<ClientOnly
							fallback={
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							}
						>
							{totalSupply !== undefined && metadata?.decimals !== undefined ? (
								<span
									className="text-[13px] text-primary"
									title={PriceFormatter.format(
										Number(formatUnits(totalSupply, metadata.decimals)),
									)}
								>
									{PriceFormatter.format(
										Number(formatUnits(totalSupply, metadata.decimals)),
										{ format: 'short' },
									)}
								</span>
							) : (
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							)}
						</ClientOnly>
					),
				},
				{
					label: 'Holders',
					value: (
						<ClientOnly
							fallback={
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							}
						>
							{totalHolders !== undefined ? (
								<span className="text-[13px] text-primary">{totalHolders}</span>
							) : (
								<span className="text-tertiary text-[13px]">{ellipsis}</span>
							)}
						</ClientOnly>
					),
				},
			]}
		/>
	)
}

function SectionsSkeleton({ totalItems }: { totalItems: number }) {
	const isMobile = useMediaQuery('(max-width: 799px)')

	const transfersColumns: DataGrid.Column[] = [
		{ label: 'Time', align: 'start', minWidth: 100 },
		{ label: 'Transaction', align: 'start', minWidth: 120 },
		{ label: 'From', align: 'start', minWidth: 140 },
		{ label: 'To', align: 'start', minWidth: 140 },
		{ label: 'Amount', align: 'end', minWidth: 100 },
	]

	const holdersColumns: DataGrid.Column[] = [
		{ label: 'Address', align: 'start', minWidth: 140 },
		{ label: 'Balance', align: 'end', minWidth: 120 },
		{ label: 'Percentage', align: 'end', minWidth: 100 },
	]

	return (
		<Sections
			mode={isMobile ? 'stacked' : 'tabs'}
			sections={[
				{
					title: 'Transfers',
					totalItems,
					itemsLabel: 'transfers',
					content: (
						<DataGrid
							columns={{
								stacked: transfersColumns,
								tabs: transfersColumns,
							}}
							items={() =>
								Array.from(
									{ length: defaultSearchValues.limit },
									(_, index) => {
										const key = `skeleton-${index}`
										return {
											cells: [
												<div key={`${key}-time`} className="h-5" />,
												<div key={`${key}-tx`} className="h-5" />,
												<div key={`${key}-from`} className="h-5" />,
												<div key={`${key}-to`} className="h-5" />,
												<div key={`${key}-amount`} className="h-5" />,
											],
										}
									},
								)
							}
							totalItems={totalItems}
							page={1}
							isPending={false}
							itemsLabel="transfers"
							itemsPerPage={defaultSearchValues.limit}
						/>
					),
				},
				{
					title: 'Holders',
					totalItems: 0,
					itemsLabel: 'holders',
					content: (
						<DataGrid
							columns={{
								stacked: holdersColumns,
								tabs: holdersColumns,
							}}
							items={() => []}
							totalItems={0}
							page={1}
							isPending={false}
							itemsLabel="holders"
						/>
					),
				},
				{
					title: 'Contract',
					totalItems: 0,
					itemsLabel: 'functions',
					content: (
						<div className="animate-pulse space-y-[12px]">
							<div className="h-[200px] rounded-[10px] bg-card-header" />
							<div className="h-[300px] rounded-[10px] bg-card-header" />
						</div>
					),
				},
			]}
			activeSection={0}
			onSectionChange={() => {}}
		/>
	)
}

function SectionsWrapper(props: {
	address: Address.Address
	page: number
	limit: number
	account?: string
	goToPage: (page: number) => void
	activeSection: number
	onSectionChange: (index: number) => void
}) {
	const {
		address,
		page,
		limit,
		account: account_,
		activeSection,
		onSectionChange,
	} = props
	const account = account_ && Address.validate(account_) ? account_ : undefined
	const { timeFormat, cycleTimeFormat, formatLabel } = useTimeFormat()

	const state = useRouterState()
	const loaderData = Route.useLoaderData()

	const { data: metadata } = Hooks.token.useGetMetadata({
		token: address,
		query: {
			enabled: Boolean(address),
			initialData: loaderData.metadata,
		},
	})

	const transfersQueryPage = activeSection === 0 ? page : 1
	const transfersOptions = transfersQueryOptions({
		address,
		page: transfersQueryPage,
		limit,
		offset: activeSection === 0 ? (page - 1) * limit : 0,
		account,
	})

	const { data: transfersData, isLoading: isLoadingTransfers } = useQuery({
		...transfersOptions,
		...(activeSection === 0 &&
		transfersQueryPage === page &&
		loaderData.transfers
			? { initialData: loaderData.transfers }
			: {}),
	})

	const holdersQueryPage = activeSection === 1 ? page : 1
	const holdersOptions = holdersQueryOptions({
		address,
		page: holdersQueryPage,
		limit,
		offset: activeSection === 1 ? (page - 1) * limit : 0,
	})

	const { data: holdersData, isLoading: isLoadingHolders } =
		useQuery(holdersOptions)

	const { transfers = [], total: transfersTotal = 0 } = transfersData ?? {}

	const { holders = [], total: holdersTotal = 0 } = holdersData ?? {}

	const routeIsLoading =
		state.isLoading && state.location.pathname.includes('/token/')
	const transfersPending = routeIsLoading || isLoadingTransfers
	const holdersPending = routeIsLoading || isLoadingHolders

	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	if (transfers.length === 0 && transfersPending && activeSection === 0)
		return <SectionsSkeleton totalItems={transfersTotal} />

	const transfersColumns: DataGrid.Column[] = [
		{
			label: (
				<TimeColumnHeader
					label="Time"
					formatLabel={formatLabel}
					onCycle={cycleTimeFormat}
					className="text-secondary hover:text-accent cursor-pointer transition-colors"
				/>
			),
			align: 'start',
			minWidth: 100,
		},
		{ label: 'Transaction', align: 'start', minWidth: 120 },
		{ label: 'From', align: 'start', minWidth: 140 },
		{ label: 'To', align: 'start', minWidth: 140 },
		{ label: 'Amount', align: 'end', minWidth: 100 },
	]

	const holdersColumns: DataGrid.Column[] = [
		{ label: 'Address', align: 'start', minWidth: 140 },
		{ label: 'Balance', align: 'end', minWidth: 120 },
		{ label: 'Percentage', align: 'end', minWidth: 100 },
	]

	return (
		<Sections
			mode={mode}
			sections={[
				{
					title: 'Transfers',
					totalItems: transfersTotal,
					itemsLabel: 'transfers',
					contextual: account && (
						<FilterIndicator account={account} tokenAddress={address} />
					),
					content: (
						<DataGrid
							columns={{
								stacked: transfersColumns,
								tabs: transfersColumns,
							}}
							items={() => {
								const validTransfers = transfers.filter(
									(t): t is typeof t & { timestamp: string; value: string } =>
										t.timestamp !== null && t.value !== null,
								)

								return validTransfers.map((transfer) => ({
									cells: [
										<TimestampCell
											key="time"
											timestamp={BigInt(transfer.timestamp)}
											link={`/receipt/${transfer.transactionHash}`}
											format={timeFormat}
										/>,
										<TransactionCell
											key="tx"
											hash={transfer.transactionHash}
										/>,
										<AddressCell
											key="from"
											address={transfer.from}
											label="From"
										/>,
										<AddressCell key="to" address={transfer.to} label="To" />,
										<AmountCell
											key="amount"
											value={BigInt(transfer.value)}
											decimals={metadata?.decimals}
											symbol={metadata?.symbol}
										/>,
									],
									link: {
										href: `/receipt/${transfer.transactionHash}`,
										title: `View receipt ${transfer.transactionHash}`,
									},
								}))
							}}
							totalItems={transfersTotal}
							page={page}
							isPending={transfersPending}
							itemsLabel="transfers"
							itemsPerPage={limit}
							emptyState="No transfers found."
						/>
					),
				},
				{
					title: 'Holders',
					totalItems: holdersTotal,
					itemsLabel: 'holders',
					content: (
						<DataGrid
							columns={{
								stacked: holdersColumns,
								tabs: holdersColumns,
							}}
							items={() =>
								holders.map((holder) => ({
									cells: [
										<AddressCell key="address" address={holder.address} />,
										<BalanceCell
											key="balance"
											balance={holder.balance}
											decimals={metadata?.decimals}
										/>,
										<span key="percentage" className="text-[12px] text-primary">
											{holder.percentage.toFixed(2)}%
										</span>,
									],
									link: {
										href: `/token/${address}?a=${holder.address}`,
										title: `View transfers for ${holder.address}`,
									},
								}))
							}
							totalItems={holdersTotal}
							page={page}
							isPending={holdersPending}
							itemsLabel="holders"
							itemsPerPage={limit}
							emptyState="No holders found."
						/>
					),
				},
				{
					title: 'Contract',
					totalItems: 0,
					itemsLabel: 'functions',
					content: <ContractSection address={address} />,
				},
			]}
			activeSection={activeSection}
			onSectionChange={onSectionChange}
		/>
	)
}

function FilterIndicator(props: {
	account: Address.Address
	tokenAddress: Address.Address
}) {
	const { account, tokenAddress } = props
	return (
		<div className="flex items-center gap-[8px] text-[12px]">
			<span className="text-tertiary">Filtered:</span>
			<Link
				to="/address/$address"
				params={{ address: account }}
				className="text-accent press-down"
				title={account}
			>
				<TruncatedHash hash={account} minChars={8} />
			</Link>
			<Link
				to="/token/$address"
				params={{ address: tokenAddress }}
				className="text-tertiary press-down"
				title="Clear filter"
			>
				<XIcon className="w-[14px] h-[14px] translate-y-px" />
			</Link>
		</div>
	)
}

function ContractSection(props: { address: Address.Address }) {
	const { address } = props
	const contractInfo = getContractInfo(address)

	return (
		<ContractReader
			address={address}
			abi={contractInfo?.abi}
			docsUrl={contractInfo?.docsUrl}
		/>
	)
}

```

## File: apps/explorer/src/routes/_layout/tokens.tsx
```
import { useQuery } from '@tanstack/react-query'
import { createFileRoute } from '@tanstack/react-router'
import * as z from 'zod/mini'
import { DataGrid } from '#comps/DataGrid'
import { Sections } from '#comps/Sections'
import {
	FormattedTimestamp,
	TimeColumnHeader,
	useTimeFormat,
} from '#comps/TimeFormat'
import { TruncatedHash } from '#comps/TruncatedHash'
import { useMediaQuery } from '#lib/hooks'
import { TOKENS_PER_PAGE, tokensListQueryOptions } from '#lib/queries'
import type { Token } from '#lib/server/tokens.server'

export const Route = createFileRoute('/_layout/tokens')({
	component: TokensPage,
	head: () => ({
		meta: [{ title: 'Tokens – Tempo Explorer' }],
	}),
	validateSearch: z.object({
		page: z.optional(z.number()),
	}).parse,
	loader: async ({ context }) => {
		return context.queryClient.ensureQueryData(
			tokensListQueryOptions({ page: 1, limit: TOKENS_PER_PAGE }),
		)
	},
})

function TokensPage() {
	const { page = 1 } = Route.useSearch()
	const loaderData = Route.useLoaderData()
	const { timeFormat, cycleTimeFormat, formatLabel } = useTimeFormat()

	const { data, isLoading } = useQuery({
		...tokensListQueryOptions({ page, limit: TOKENS_PER_PAGE }),
		initialData: page === 1 ? loaderData : undefined,
	})

	const tokens = data?.tokens ?? []
	const total = data?.total ?? 0

	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	const columns: DataGrid.Column[] = [
		{ label: 'Token', align: 'start', minWidth: 80 },
		{ label: 'Name', align: 'start' },
		{ label: 'Currency', align: 'start', minWidth: 80 },
		{ label: 'Address', align: 'start' },
		{
			label: (
				<TimeColumnHeader
					label="Created"
					formatLabel={formatLabel}
					onCycle={cycleTimeFormat}
					className="text-secondary hover:text-accent cursor-pointer transition-colors"
				/>
			),
			align: 'end',
			minWidth: 100,
		},
	]

	return (
		<div className="flex flex-col gap-6 px-4 pt-20 pb-16 max-w-[1200px] mx-auto w-full">
			<Sections
				mode={mode}
				sections={[
					{
						title: 'Tokens',
						totalItems: total,
						itemsLabel: 'tokens',
						autoCollapse: false,
						content: (
							<DataGrid
								columns={{ stacked: columns, tabs: columns }}
								items={() =>
									tokens.map((token: Token) => ({
										cells: [
											<span
												key="symbol"
												className="text-base-content-positive font-medium"
											>
												{token.symbol}
											</span>,
											<span key="name" className="truncate">
												{token.name}
											</span>,
											<span key="currency" className="text-secondary">
												{token.currency}
											</span>,
											<TruncatedHash
												key="address"
												hash={token.address}
												minChars={8}
												className="text-accent"
											/>,
											<FormattedTimestamp
												key="created"
												timestamp={BigInt(token.createdAt)}
												format={timeFormat}
												className="text-secondary"
											/>,
										],
										link: {
											href: `/token/${token.address}`,
											title: `View token ${token.symbol}`,
										},
									}))
								}
								totalItems={total}
								page={page}
								isPending={isLoading}
								itemsLabel="tokens"
								itemsPerPage={TOKENS_PER_PAGE}
								pagination="simple"
								emptyState="No tokens found."
							/>
						),
					},
				]}
				activeSection={0}
			/>
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout/tx/$hash.tsx
```
import { useQuery } from '@tanstack/react-query'
import {
	createFileRoute,
	Link,
	notFound,
	rootRouteId,
	stripSearchParams,
	useNavigate,
} from '@tanstack/react-router'
import { type Address, type Hex, Json, Value } from 'ox'
import * as React from 'react'
import type { Log, TransactionReceipt } from 'viem'
import { useChains } from 'wagmi'
import * as z from 'zod/mini'
import { DataGrid } from '#comps/DataGrid'
import { InfoRow } from '#comps/InfoRow'
import { NotFound } from '#comps/NotFound'
import { Sections } from '#comps/Sections'
import { TruncatedHash } from '#comps/TruncatedHash'
import { TxDecodedCalldata } from '#comps/TxDecodedCalldata'
import { TxDecodedTopics } from '#comps/TxDecodedTopics'
import { TxEventDescription } from '#comps/TxEventDescription'
import { TxRawTransaction } from '#comps/TxRawTransaction'
import { TxTransactionCard } from '#comps/TxTransactionCard'
import { cx } from '#cva.config.ts'
import type { KnownEvent } from '#lib/domain/known-events'
import type { FeeBreakdownItem } from '#lib/domain/receipt'
import { useCopy, useMediaQuery } from '#lib/hooks'
import { type TxData, txQueryOptions } from '#lib/queries'
import { zHash } from '#lib/zod'
import CopyIcon from '~icons/lucide/copy'

const defaultSearchValues = {
	tab: 'overview',
} as const

export const Route = createFileRoute('/_layout/tx/$hash')({
	component: RouteComponent,
	notFoundComponent: NotFound,
	headers: () => ({
		...(import.meta.env.PROD
			? {
					'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400',
				}
			: {}),
	}),
	validateSearch: z.object({
		r: z.optional(z.string()),
		tab: z.prefault(
			z.enum(['overview', 'calls', 'events', 'raw']),
			defaultSearchValues.tab,
		),
	}),
	search: {
		middlewares: [stripSearchParams(defaultSearchValues)],
	},
	loader: async ({ params, context }) => {
		try {
			return await context.queryClient.ensureQueryData(
				txQueryOptions({ hash: params.hash }),
			)
		} catch (error) {
			console.error(error)
			throw notFound({
				routeId: rootRouteId,
				data: {
					error: error instanceof Error ? error.message : 'Unknown error',
				},
			})
		}
	},
	params: z.object({
		hash: zHash(),
	}),
})

function RouteComponent() {
	const navigate = useNavigate()
	const { hash } = Route.useParams()
	const { tab } = Route.useSearch()
	const loaderData = Route.useLoaderData()

	const { data } = useQuery({
		...txQueryOptions({ hash }),
		initialData: loaderData,
	})

	const {
		block,
		feeBreakdown,
		knownEvents,
		knownEventsByLog = [],
		receipt,
		transaction,
	} = data

	const isMobile = useMediaQuery('(max-width: 799px)')
	const mode = isMobile ? 'stacked' : 'tabs'

	const calls = 'calls' in transaction ? transaction.calls : undefined
	const hasCalls = Boolean(calls && calls.length > 0)

	const tabs = [
		'overview',
		...(hasCalls ? ['calls'] : []),
		'events',
		'raw',
	] as const
	const activeSection = tabs.indexOf(tab)

	const setActiveSection = (newIndex: number) => {
		navigate({
			to: '.',
			search: { tab: tabs[newIndex] ?? 'overview' },
			resetScroll: false,
		})
	}

	return (
		<div
			className={cx(
				'max-[800px]:flex max-[800px]:flex-col max-w-[800px]:pt-10 max-w-[800px]:pb-8 w-full',
				'grid w-full pt-20 pb-16 px-4 gap-[14px] min-w-0 grid-cols-[auto_1fr] min-[1240px]:max-w-[1080px]',
			)}
		>
			<TxTransactionCard
				hash={receipt.transactionHash}
				status={receipt.status}
				blockNumber={receipt.blockNumber}
				timestamp={block.timestamp}
				from={receipt.from}
				to={receipt.to}
				className="self-start"
			/>
			<Sections
				mode={mode}
				sections={[
					{
						title: 'Overview',
						totalItems: 0,
						itemsLabel: 'fields',
						autoCollapse: false,
						content: (
							<OverviewSection
								receipt={receipt}
								transaction={transaction}
								block={block}
								knownEvents={knownEvents}
								feeBreakdown={feeBreakdown}
							/>
						),
					},
					...(hasCalls && calls
						? [
								{
									title: 'Calls',
									totalItems: calls.length,
									itemsLabel: 'calls',
									content: <CallsSection calls={calls} />,
								},
							]
						: []),
					{
						title: 'Events',
						totalItems: receipt.logs.length,
						itemsLabel: 'events',
						content: (
							<EventsSection
								logs={receipt.logs}
								knownEvents={knownEventsByLog}
							/>
						),
					},
					{
						title: 'Raw',
						totalItems: 0,
						itemsLabel: 'data',
						content: <RawSection transaction={transaction} receipt={receipt} />,
					},
				]}
				activeSection={activeSection}
				onSectionChange={setActiveSection}
			/>
		</div>
	)
}

function OverviewSection(props: {
	receipt: TransactionReceipt
	transaction: TxData['transaction']
	block: TxData['block']
	knownEvents: KnownEvent[]
	feeBreakdown: FeeBreakdownItem[]
}) {
	const { receipt, transaction, block, knownEvents, feeBreakdown } = props

	const [chain] = useChains()
	const { decimals, symbol } = chain.nativeCurrency

	const value = transaction.value ?? 0n
	const gasUsed = receipt.gasUsed
	const gasLimit = transaction.gas
	const gasUsedPercentage =
		gasLimit > 0n ? (Number(gasUsed) / Number(gasLimit)) * 100 : 0
	const gasPrice = receipt.effectiveGasPrice
	const baseFee = block.baseFeePerGas
	const maxFee = transaction.maxFeePerGas
	const maxPriorityFee = transaction.maxPriorityFeePerGas
	const nonce = transaction.nonce
	const positionInBlock = receipt.transactionIndex
	const input = transaction.input

	return (
		<div className="flex flex-col">
			{knownEvents.length > 0 && (
				<InfoRow label="Description">
					<TxEventDescription.ExpandGroup
						events={knownEvents}
						limit={5}
						limitFilter={(event) =>
							event.type !== 'active key count changed' &&
							event.type !== 'nonce incremented'
						}
					/>
				</InfoRow>
			)}
			<InfoRow label="Value">
				<span className="text-primary">
					{Value.format(value, decimals)} {symbol}
				</span>
			</InfoRow>
			<InfoRow label="Transaction Fee">
				{feeBreakdown.length > 0 ? (
					<div className="flex flex-col gap-[4px]">
						{feeBreakdown.map((item, index) => {
							return (
								<span key={`${index}${item.token}`} className="text-primary">
									{Value.format(item.amount, item.decimals)}{' '}
									{item.token ? (
										<Link
											to="/token/$address"
											params={{ address: item.token }}
											className="text-base-content-positive press-down"
										>
											{item.symbol}
										</Link>
									) : (
										<span className="text-base-content-positive">
											{item.symbol}
										</span>
									)}
								</span>
							)
						})}
					</div>
				) : (
					<span className="text-primary">
						{Value.format(
							receipt.effectiveGasPrice * receipt.gasUsed,
							decimals,
						)}{' '}
						{symbol}
					</span>
				)}
			</InfoRow>
			<InfoRow label="Gas Used">
				<span className="text-primary">
					{gasUsed.toLocaleString()} / {gasLimit.toLocaleString()}{' '}
					<span className="text-tertiary">
						({gasUsedPercentage.toFixed(2)}%)
					</span>
				</span>
			</InfoRow>
			<InfoRow label="Gas Price">
				<span className="text-primary">{gasPrice}</span>
			</InfoRow>
			{baseFee !== undefined && baseFee !== null && (
				<InfoRow label="Base Fee">
					<span className="text-primary">{baseFee}</span>
				</InfoRow>
			)}
			{maxFee !== undefined && (
				<InfoRow label="Max Fee">
					<span className="text-primary">{maxFee}</span>
				</InfoRow>
			)}
			{maxPriorityFee !== undefined && (
				<InfoRow label="Max Priority Fee">
					<span className="text-primary">{maxPriorityFee}</span>
				</InfoRow>
			)}
			<InfoRow label="Transaction Type">
				<span className="text-primary">{receipt.type}</span>
			</InfoRow>
			<InfoRow label="Nonce">
				<span className="text-primary">{nonce}</span>
			</InfoRow>
			<InfoRow label="Position in Block">
				<span className="text-primary">{positionInBlock}</span>
			</InfoRow>
			{input && input !== '0x' && (
				<InputDataRow input={input} to={transaction.to} />
			)}
		</div>
	)
}

function InputDataRow(props: { input: Hex.Hex; to?: Address.Address | null }) {
	const { input, to } = props

	return (
		<div className="flex flex-col px-[18px] py-[12px] border-b border-dashed border-card-border last:border-b-0">
			<div className="flex items-start gap-[16px]">
				<span className="text-[13px] text-tertiary min-w-[140px] shrink-0">
					Input Data
				</span>
				<div className="flex-1">
					<TxDecodedCalldata address={to} data={input} />
				</div>
			</div>
		</div>
	)
}

function CallsSection(props: {
	calls: ReadonlyArray<{
		to?: Address.Address | null
		data?: Hex.Hex
		value?: bigint
	}>
}) {
	const { calls } = props
	return calls.length === 0 ? (
		<div className="px-[18px] py-[24px] text-[13px] text-tertiary text-center">
			No calls in this transaction
		</div>
	) : (
		<div className="flex flex-col divide-y divide-card-border">
			{calls.map((call, i) => (
				<CallItem key={`${call.to}-${i}`} call={call} index={i} />
			))}
		</div>
	)
}

function CallItem(props: {
	call: {
		to?: Address.Address | null
		data?: Hex.Hex
		value?: bigint
	}
	index: number
}) {
	const { call, index } = props
	const data = call.data
	return (
		<div className="flex flex-col gap-[12px] px-[18px] py-[16px]">
			<div className="flex items-center gap-[8px] text-[13px] font-mono">
				<span className="text-primary">#{index}</span>
				{call.to ? (
					<Link
						to="/address/$address"
						params={{ address: call.to }}
						className="text-accent hover:underline press-down"
					>
						<TruncatedHash hash={call.to} minChars={8} />
					</Link>
				) : (
					<span className="text-tertiary">Contract Creation</span>
				)}
				{data && data !== '0x' && (
					<span className="text-tertiary">({data.length} bytes)</span>
				)}
			</div>
			{data && data !== '0x' && (
				<TxDecodedCalldata address={call.to} data={data} />
			)}
		</div>
	)
}

function EventsSection(props: {
	logs: Log[]
	knownEvents: (KnownEvent | null)[]
}) {
	const { logs, knownEvents } = props
	const [expandedRows, setExpandedRows] = React.useState<Set<number>>(new Set())

	const toggleRow = (index: number) => {
		setExpandedRows((expanded) => {
			const newExpanded = new Set(expanded)
			if (newExpanded.has(index)) newExpanded.delete(index)
			else newExpanded.add(index)
			return newExpanded
		})
	}

	if (logs.length === 0)
		return (
			<div className="px-[18px] py-[24px] text-[13px] text-tertiary text-center">
				No events emitted in this transaction
			</div>
		)

	const cols = [
		{ label: '#', align: 'start', width: '0.5fr' },
		{ label: 'Event', align: 'start', width: '4fr' },
		{ label: 'Contract', align: 'end', width: '2fr' },
	] satisfies DataGrid.Props['columns']['stacked']

	return (
		<DataGrid
			columns={{ stacked: cols, tabs: cols }}
			items={() =>
				logs.map((log, index) => {
					const knownEvent = knownEvents[index] ?? undefined
					const isExpanded = expandedRows.has(index)
					return {
						cells: [
							<span key="index" className="text-tertiary">
								{index}
							</span>,
							<EventCell
								key="event"
								log={log}
								knownEvent={knownEvent}
								expanded={isExpanded}
								onToggle={() => toggleRow(index)}
							/>,
							<Link
								key="contract"
								to="/address/$address"
								params={{ address: log.address }}
								className="text-accent hover:underline whitespace-nowrap press-down"
								title={log.address}
							>
								<TruncatedHash hash={log.address} minChars={6} />
							</Link>,
						],
						expanded: isExpanded ? (
							<TxDecodedTopics key={log.logIndex} log={log} />
						) : (
							false
						),
					}
				})
			}
			totalItems={logs.length}
			page={1}
			isPending={false}
			itemsLabel="events"
			itemsPerPage={logs.length}
			emptyState="No events emitted."
		/>
	)
}

function EventCell(props: {
	log: Log
	knownEvent?: KnownEvent
	expanded: boolean
	onToggle: () => void
}) {
	const { log, knownEvent, expanded, onToggle } = props
	const [eventSignature] = log.topics

	return (
		<div className="flex flex-col gap-[4px]">
			{knownEvent ? (
				<TxEventDescription
					event={knownEvent}
					className="flex flex-row items-center gap-[6px] leading-[18px]"
				/>
			) : (
				<span className="text-primary">
					{eventSignature ? (
						<TruncatedHash hash={eventSignature} minChars={8} />
					) : (
						'Unknown'
					)}
				</span>
			)}
			<div>
				<button
					type="button"
					onClick={onToggle}
					className="text-[11px] text-accent hover:underline text-left cursor-pointer press-down-mini"
				>
					{expanded ? 'Hide details' : 'Show details'}
				</button>
			</div>
		</div>
	)
}

function RawSection(props: {
	transaction: TxData['transaction']
	receipt: TransactionReceipt
}) {
	const { transaction, receipt } = props
	const { copy, notifying } = useCopy()

	const rawData = Json.stringify({ tx: transaction, receipt }, null, 2)

	return (
		<div className="relative px-[18px] py-[12px] text-[13px] break-all">
			<div className="absolute top-[12px] right-[18px] flex items-center gap-[4px] text-tertiary">
				{notifying && <span className="text-[11px] select-none">copied</span>}
				<button
					type="button"
					className="press-down cursor-pointer hover:text-secondary p-[4px]"
					onClick={() => copy(rawData)}
					title="Copy"
				>
					<CopyIcon className="size-[14px]" />
				</button>
			</div>
			<TxRawTransaction data={rawData} />
		</div>
	)
}

```

## File: apps/explorer/src/routes/_layout.tsx
```
import { createFileRoute, Outlet, useMatchRoute } from '@tanstack/react-router'
import * as z from 'zod/mini'
import { Footer } from '#comps/Footer'
import { Header } from '#comps/Header'
import { Sphere } from '#comps/Sphere'
import { fetchLatestBlock } from '#lib/server/latest-block.server.ts'

export const Route = createFileRoute('/_layout')({
	component: RouteComponent,
	validateSearch: z.object({
		plain: z.optional(z.string()),
	}).parse,
	loader: () => fetchLatestBlock(),
})

function RouteComponent() {
	const search = Route.useSearch()
	const isPlain = 'plain' in search
	const blockNumber = Route.useLoaderData()

	if (isPlain) return <Outlet />

	return (
		<Layout blockNumber={blockNumber}>
			<Outlet />
		</Layout>
	)
}

export function Layout(props: Layout.Props) {
	const { children, blockNumber } = props
	const matchRoute = useMatchRoute()
	return (
		<div className="flex min-h-dvh flex-col">
			<div className="relative z-2">
				<Header initialBlockNumber={blockNumber} />
			</div>
			<main className="flex flex-1 size-full flex-col items-center relative z-1">
				{children}
			</main>
			<div className="w-full mt-40 relative z-1">
				<Footer />
			</div>
			<Sphere animate={Boolean(matchRoute({ to: '/' }))} />
		</div>
	)
}

export namespace Layout {
	export interface Props {
		children: React.ReactNode
		blockNumber?: bigint
	}
}

```

## File: apps/explorer/src/routes/api/search.ts
```
import { createFileRoute } from '@tanstack/react-router'
import * as IDX from 'idxs'
import { Address, Hex } from 'ox'
import tokensIndex from '#data/tokens-index.json' with { type: 'json' }
import { isTip20Address } from '#lib/domain/tip20'
import { config } from '#wagmi.config.ts'

const IS = IDX.IndexSupply.create({
	apiKey: process.env.INDEXER_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

export type SearchResult =
	| {
			type: 'token'
			address: Address.Address
			symbol: string
			name: string
			isTip20: boolean
	  }
	| {
			type: 'address'
			address: Address.Address
			isTip20: boolean
	  }
	| {
			type: 'transaction'
			hash: Hex.Hex
			timestamp?: number
	  }

export type SearchApiResponse = {
	results: SearchResult[]
	query: string
}

export type TokenSearchResult = Extract<SearchResult, { type: 'token' }>
export type AddressSearchResult = Extract<SearchResult, { type: 'address' }>
export type TransactionSearchResult = Extract<
	SearchResult,
	{ type: 'transaction' }
>

type Token = [address: Address.Address, symbol: string, name: string]

type IndexedToken = {
	address: Address.Address
	symbol: string
	name: string
	searchKey: string
}

// prepare search keys
const indexedTokens: IndexedToken[] = (tokensIndex as Token[]).map(
	([address, symbol, name]) => ({
		address,
		symbol,
		name,
		searchKey: `${symbol.toLowerCase()}|${name.toLowerCase()}|${address}`,
	}),
)

function searchTokens(query: string): TokenSearchResult[] {
	query = query.toLowerCase()

	// filter using search keys
	const matches = indexedTokens.filter((token) => {
		return query.startsWith('0x')
			? token.address.startsWith(query)
			: token.searchKey.includes(query)
	})

	matches.sort((a, b) => {
		const aSymbol = a.symbol.toLowerCase()
		const bSymbol = b.symbol.toLowerCase()
		const aName = a.name.toLowerCase()
		const bName = b.name.toLowerCase()

		// exact symbol
		if (aSymbol === query && bSymbol !== query) return -1
		if (bSymbol === query && aSymbol !== query) return 1

		// symbol prefix
		if (aSymbol.startsWith(query) && !bSymbol.startsWith(query)) return -1
		if (bSymbol.startsWith(query) && !aSymbol.startsWith(query)) return 1

		// exact name
		if (aName === query && bName !== query) return -1
		if (bName === query && aName !== query) return 1

		// name prefix
		if (aName.startsWith(query) && !bName.startsWith(query)) return -1
		if (bName.startsWith(query) && !aName.startsWith(query)) return 1

		return 0
	})

	return matches.slice(0, 5).map((token) => ({
		type: 'token' as const,
		address: token.address,
		symbol: token.symbol,
		name: token.name,
		isTip20: true, // all tokens in the index are tip20
	}))
}

export const Route = createFileRoute('/api/search')({
	server: {
		handlers: {
			GET: async ({ request }) => {
				const url = new URL(request.url)
				const query = url.searchParams.get('q')?.trim() ?? ''

				if (!query)
					return Response.json({
						results: [],
						query,
					} satisfies SearchApiResponse)

				const results: SearchResult[] = []

				// address
				if (Address.validate(query))
					results.push({
						type: 'address',
						address: query,
						isTip20: isTip20Address(query),
					})

				const isHash = Hex.validate(query) && Hex.size(query) === 32

				// hash
				if (isHash) {
					try {
						const chainId = config.getClient().chain.id
						const result = await QB.selectFrom('txs')
							.select(['block_timestamp'])
							.where('chain', '=', chainId)
							.where('hash', '=', query)
							.limit(1)
							.executeTakeFirst()

						results.push({
							type: 'transaction',
							hash: query,
							timestamp: result?.block_timestamp
								? Number(result.block_timestamp)
								: undefined,
						})
					} catch {
						results.push({
							type: 'transaction',
							hash: query,
							timestamp: undefined,
						})
					}
				} else {
					// search for token matches (even if an address was found)
					results.push(...searchTokens(query))
				}

				return Response.json({ results, query } satisfies SearchApiResponse, {
					headers: { 'Cache-Control': 'public, max-age=30' },
				})
			},
		},
	},
})

```

## File: apps/explorer/src/routes/styles.css
```
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.scheme-light-dark *));

@theme {
	/* Background Colors */
	--color-background-inverse: light-dark(#202020, #fcfcfc);
	--background-color-inverse: var(--color-background-inverse);
	--color-background-primary: light-dark(#f8f8f8, #111111);
	--background-color-primary: var(--color-background-primary);
	--color-background-surface: light-dark(#ffffff, #1a1a1a);
	--background-color-surface: var(--color-background-surface);
	--color-background-alt: light-dark(#fcfcfc, #222222);
	--background-alt: var(--color-background-alt);
	--color-frame-background: light-dark(#ffffff, #1a1a1a);
	--frame-background: var(--color-frame-background);
	--color-system-background: light-dark(#f8f8f8, #111111);
	--system-background: var(--color-system-background);
	--color-inverse: var(--color-background-inverse);
	--color-system: var(--color-system-background);
	--color-surface: var(--color-background-surface);
	--color-alt: var(--color-background-alt);
	--color-frame: var(--color-frame-background);

	/* Content/Text Colors */
	--color-content-primary: light-dark(#0a0a0a, #f5f5f5);
	--content-primary: var(--color-content-primary);
	--color-content-secondary: light-dark(#737373, #a0a0a0);
	--content-secondary: var(--color-content-secondary);
	--color-content-tertiary: light-dark(#8d8d8d, #6e6e6e);
	--content-tertiary: var(--color-content-tertiary);
	--color-content-positive: light-dark(#16a34a, #22c55e);
	--content-positive: var(--color-content-positive);
	--color-content-negative: light-dark(#dc2626, #ef4444);
	--content-negative: var(--color-content-negative);
	--color-content-disabled: light-dark(#d4d4d4, #525252);
	--content-disabled: var(--color-content-disabled);
	--color-label-primary: light-dark(#000000, #ffffff);
	--label-primary: var(--color-label-primary);
	--color-content-inverse: light-dark(#f5f5f5, #0a0a0a);
	--content-inverse: var(--color-content-inverse);
	--color-primary: var(--color-content-primary);
	--color-secondary: var(--color-content-secondary);
	--color-tertiary: var(--color-content-tertiary);
	--color-positive: var(--color-content-positive);
	--color-negative: var(--color-content-negative);
	--color-disabled: var(--color-content-disabled);
	--color-content-dimmed: light-dark(#bebebe, #4e4e4e);

	/* Accent & Interactive */
	--color-accent: light-dark(#3b82f6, #60a5fa);
	--accent: var(--color-accent);
	--color-accent-hover: light-dark(#2563eb, #93c5fd);
	--accent-hover: var(--color-accent-hover);
	--color-focus: var(--color-accent);

	/* Border Colors */
	--color-border-primary: light-dark(#f0f0f0, #262626);
	--border-primary: var(--color-border-primary);
	--color-border-secondary: light-dark(#f8f8f8, #1a1a1a);
	--border-secondary: var(--color-border-secondary);
	--color-border-tertiary: light-dark(#e5e5e5, #2e2e2e);
	--border-tertiary: var(--color-border-tertiary);
	--color-border-negative: light-dark(#dc2626, #ef4444);
	--border-negative: var(--color-border-negative);

	/* Outline Colors */
	--color-outline-primary: light-dark(#f0f0f0, #262626);
	--outline-primary: var(--color-outline-primary);
	--color-outline-secondary: light-dark(#f8f8f8, #1a1a1a);
	--outline-secondary: var(--color-outline-secondary);
	--color-outline-negative: light-dark(#dc2626, #ef4444);
	--outline-negative: var(--color-outline-negative);

	/* Field Colors */
	--color-field-content-secondary: light-dark(#a3a3a3, #737373);
	--field-content-secondary: var(--color-field-content-secondary);

	/* Outline Colors */
	--color-outline-inverse: light-dark(#171717, #fafafa);
	--outline-color-inverse: var(--color-outline-inverse);

	/* Solid Colors */
	--color-solid-gray-3: light-dark(#f5f5f5, #262626);
	--solid-gray-3: var(--color-solid-gray-3);

	/* Tokenized Color Pairings */
	--color-black-white: light-dark(#000000, #ffffff);
	--color-white-black: light-dark(#ffffff, #000000);

	/* Card */
	--color-card: light-dark(#f9f9f9, #222222);
	--color-card-header: light-dark(#f9f9f9, #191919);
	--color-card-border: light-dark(#e0e0e0, #2a2a2a);

	/* Other Colors */
	--color-base-background: light-dark(#fcfcfc, #191919);
	--color-base-plane: light-dark(#fcfcfc, #222222);
	--color-base-plane-background: light-dark(#f9f9f9, #222222);
	--color-base-alt: light-dark(#e5e5e5, #2a2a2a);
	--color-base-border: light-dark(#e0e0e0, #2a2a2a);
	--color-base-content: light-dark(#202020, #eeeeee);
	--color-base-content-secondary: light-dark(#7b7b7b, #7b7b7b);
	--color-base-content-positive: light-dark(#30a46c, #30a46c);
	--color-base-content-negative: light-dark(#e5484d, #e5484d);
	--color-distinct: light-dark(#e8e8e8, #313131);

	--font-display: system-ui, sans-serif;
	--font-mono: ui-monospace, monospace;
}

html,
:host {
	background-color: var(--color-base-background);
	color: var(--color-primary);
	color-scheme: light dark;
}

:root {
	touch-action: manipulation;
}

@layer base {
	html {
		color-scheme: light dark;
	}
}

body {
	font-family: var(--font-display);
	@apply text-base;
	min-width: 400px;
}

pre {
	font-family: var(--font-mono);
}

a:focus-visible,
button:focus-visible {
	outline: 2px solid var(--color-focus);
	outline-offset: 2px;
	border-radius: 2px;
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
	@apply appearance-none;
}

input[type="number"] {
	appearance: textfield;
}

@utility text-md {
	font-size: 16px;
	line-height: 1.25rem;
}

@utility size-max {
	width: 100%;
	height: 100%;
}

@utility min-size-max {
	min-width: 100%;
	min-height: 100%;
}

@utility max-size-max {
	max-width: 100%;
	max-height: 100%;
}

@utility size-auto {
	width: auto;
	height: auto;
}

@utility min-size-auto {
	min-width: auto;
	min-height: auto;
}

@utility max-size-auto {
	max-width: auto;
	max-height: auto;
}

@utility min-size-screen {
	min-width: 100vw;
	min-height: 100vh;
}

@utility max-size-screen {
	max-width: 100vw;
	max-height: 100vh;
}

@utility font-bolder {
	font-weight: 750;
}

@utility no-scrollbar {
	-ms-overflow-style: none;
	scrollbar-width: none;

	&::-webkit-scrollbar {
		display: none;
	}
}

@utility press-down {
	&:active:not([aria-disabled="true"]) {
		transform: translateY(0.5px);
	}
}

@utility press-down-mini {
	&:active:not([aria-disabled="true"]) {
		transform: translateY(0.1px);
	}
}

@keyframes progressline {
	0% {
		width: 0%;
	}
	50% {
		width: 70%;
	}
	100% {
		width: 100%;
		opacity: 0;
	}
}

```

## File: apps/explorer/src/wagmi.config.ts
```
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
import { QueryClient } from '@tanstack/react-query'
import { tempoLocal, tempoTestnet } from 'tempo.ts/chains'
import type { OneOf } from 'viem'
import { createConfig, deserialize, http, serialize, webSocket } from 'wagmi'
import { hashFn } from 'wagmi/query'

const browser = typeof window !== 'undefined'

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			staleTime: 60 * 1_000, // needed for SSR
			queryKeyHashFn: hashFn,
			refetchOnWindowFocus: false,
			gcTime: 1_000 * 60 * 60 * 24, // 24 hours
		},
	},
})

export const persister = createAsyncStoragePersister({
	serialize,
	storage: browser ? window.localStorage : undefined,
	deserialize,
})

const chain =
	import.meta.env.VITE_LOCALNET === 'true'
		? tempoLocal({ feeToken: 1n })
		: tempoTestnet({ feeToken: 1n })

export function getConfig(
	parameters: OneOf<{ rpcUrl?: string | undefined }> = {},
) {
	const { rpcUrl } = parameters
	return createConfig({
		chains: [chain],
		ssr: true,
		batch: { multicall: false },
		transports: {
			[tempoTestnet.id]: browser
				? webSocket('wss://rpc-orchestra.testnet.tempo.xyz')
				: http(rpcUrl ?? 'https://rpc-orchestra.testnet.tempo.xyz'),
			[tempoLocal.id]: http(undefined, {
				batch: true,
			}),
		},
	})
}

export const config = getConfig()

```

## File: apps/fee-payer/playground/src/App.tsx
```
import { Hooks } from 'tempo.ts/wagmi'
import { formatUnits, pad, parseUnits, stringToHex } from 'viem'
import {
	useConnect,
	useConnection,
	useConnectors,
	useDisconnect,
	useWatchBlockNumber,
} from 'wagmi'
import { alphaUsd } from './wagmi.config'

export function App() {
	const connection = useConnection()

	const alphaUsdBalance = Hooks.token.useGetBalance({
		account: connection?.address,
		token: alphaUsd,
	})

	return (
		<div>
			<h1>Tempo Example</h1>
			<hr />
			{connection?.isConnected ? (
				<>
					<h2>Account</h2>
					<Account />
					<h2>Fund Account</h2>
					<FundAccount />
					<h2>Balances</h2>
					<Balance />
					{alphaUsdBalance.data && alphaUsdBalance.data > 0n && (
						<>
							<h2>Send 100 Alpha USD</h2>
							<SendPayment />
						</>
					)}
				</>
			) : (
				<>
					<h2>Connect</h2>
					<Connect />
				</>
			)}
		</div>
	)
}

export function Connect() {
	const connect = useConnect()
	const [connector] = useConnectors()

	return (
		<div>
			<button
				onClick={() =>
					connect.mutate({ connector, capabilities: { type: 'sign-up' } })
				}
				type="button"
			>
				Sign up
			</button>
			<button
				onClick={() =>
					connect.mutate({ connector, capabilities: { type: 'sign-in' } })
				}
				type="button"
			>
				Sign in
			</button>
		</div>
	)
}

export function Account() {
	const connection = useConnection()
	const disconnect = useDisconnect()

	return (
		<div>
			<div>
				<strong>Address: </strong>
				{connection?.address}
			</div>
			<button type="button" onClick={() => disconnect.disconnect()}>
				Disconnect
			</button>
		</div>
	)
}

export function Balance() {
	const connection = useConnection()

	const alphaUsdBalance = Hooks.token.useGetBalance({
		account: connection?.address,
		token: alphaUsd,
	})
	const alphaUsdMetadata = Hooks.token.useGetMetadata({
		token: alphaUsd,
	})

	useWatchBlockNumber({
		onBlockNumber() {
			alphaUsdBalance.refetch()
		},
	})

	// Only show section if alphaUsd metadata is loaded
	if (!alphaUsdMetadata.data) return null
	return (
		<div>
			<strong>{alphaUsdMetadata.data?.name} Balance: </strong>
			{formatUnits(
				alphaUsdBalance.data ?? 0n,
				alphaUsdMetadata.data?.decimals ?? 6,
			)}{' '}
			{alphaUsdMetadata.data?.symbol}
		</div>
	)
}

export function FundAccount() {
	const connection = useConnection()
	const fund = Hooks.faucet.useFund()

	if (!connection?.address) return null
	return (
		<div>
			<button
				disabled={fund.isPending}
				type="button"
				// biome-ignore lint/style/noNonNullAssertion: _
				onClick={() => fund.mutate({ account: connection.address! })}
			>
				Fund Account
			</button>

			{fund.data && (
				<div>
					Receipts:{' '}
					{fund.data.map((hash) => (
						<div key={hash}>
							<a href={`https://explore.tempo.xyz/${hash}`} target="_blank">
								{hash}
							</a>
						</div>
					))}
				</div>
			)}
		</div>
	)
}

export function SendPayment() {
	const sendPayment = Hooks.token.useTransferSync()
	const metadata = Hooks.token.useGetMetadata({
		token: alphaUsd,
	})

	if (!metadata.data) return null
	return (
		<form
			onSubmit={(event) => {
				event.preventDefault()
				const formData = new FormData(event.target as HTMLFormElement)

				const recipient = (formData.get('recipient') ||
					'0x0000000000000000000000000000000000000000') as `0x${string}`
				const memo = formData.get('memo') as string

				sendPayment.mutate({
					amount: parseUnits('100', metadata.data.decimals),
					memo: memo ? pad(stringToHex(memo), { size: 32 }) : undefined,
					feePayer: true,
					to: recipient,
					token: alphaUsd,
				})
			}}
		>
			<div>
				<label htmlFor="recipient">Recipient address</label>
				<input type="text" name="recipient" placeholder="0x..." />
			</div>

			<div>
				<label htmlFor="memo">Memo (optional)</label>
				<input type="text" name="memo" placeholder="INV-12345" />
			</div>

			<button disabled={sendPayment.isPending} type="submit">
				Send Payment
			</button>

			{sendPayment.data && (
				<a
					href={`https://explore.tempo.xyz/tx/${sendPayment.data.receipt.transactionHash}`}
					target="_blank"
					rel="noopener noreferrer"
				>
					View receipt
				</a>
			)}
		</form>
	)
}

```

## File: apps/fee-payer/playground/src/main.tsx
```
import { QueryClientProvider } from '@tanstack/react-query'
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { WagmiProvider } from 'wagmi'
import { App } from './App.tsx'

import { config, queryClient } from './wagmi.config.ts'

const root = document.querySelector('div#root')
if (!root) throw new Error('Root element not found')

createRoot(root).render(
	<StrictMode>
		<WagmiProvider config={config}>
			<QueryClientProvider client={queryClient}>
				<App />
			</QueryClientProvider>
		</WagmiProvider>
	</StrictMode>,
)

```

## File: apps/fee-payer/playground/src/wagmi.config.ts
```
import { QueryClient } from '@tanstack/react-query'
import { tempoTestnet } from 'tempo.ts/chains'
import { withFeePayer } from 'tempo.ts/viem'
import { KeyManager, webAuthn } from 'tempo.ts/wagmi'
import { createConfig, http, webSocket } from 'wagmi'

export const alphaUsd = '0x20c0000000000000000000000000000000000001'

export const queryClient = new QueryClient()

export const config = createConfig({
	batch: {
		multicall: false,
	},
	connectors: [
		webAuthn({
			keyManager: KeyManager.localStorage(),
		}),
	],
	chains: [tempoTestnet({ feeToken: alphaUsd })],
	multiInjectedProviderDiscovery: false,
	transports: {
		[tempoTestnet.id]: withFeePayer(
			// Transport for regular transactions
			webSocket('wss://rpc.testnet.tempo.xyz'),
			// Transport for sponsored transactions (feePayer: true)
			http(import.meta.env.VITE_FEE_PAYER_URL ?? 'http://localhost:8787'),
		),
	},
})

declare module 'wagmi' {
	interface Register {
		config: typeof config
	}
}

```

## File: apps/fee-payer/src/index.ts
```
import { env } from 'cloudflare:workers'
import { zValidator } from '@hono/zod-validator'
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { tempo } from 'tempo.ts/chains'
import { Handler } from 'tempo.ts/server'
import { http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import * as z from 'zod'
import { rateLimitMiddleware } from './lib/rate-limit.js'
import { getUsage } from './lib/usage.js'

const app = new Hono()

app.use(
	'*',
	cors({
		origin: (origin) => {
			if (env.ALLOWED_ORIGINS === '*') return '*'
			if (origin && env.ALLOWED_ORIGINS.includes(origin)) return origin
			return null
		},
		allowMethods: ['GET', 'POST', 'OPTIONS'],
		allowHeaders: ['Content-Type', 'Authorization'],
		maxAge: 86400,
	}),
)

app.get(
	'/usage',
	zValidator(
		'query',
		z.object({
			blockTimestampFrom: z.optional(z.coerce.number()),
			blockTimestampTo: z.optional(z.coerce.number()),
		}),
	),
	async (c) => {
		const { blockTimestampFrom, blockTimestampTo } = c.req.valid('query')
		const account = privateKeyToAccount(
			env.SPONSOR_PRIVATE_KEY as `0x${string}`,
		)
		const data = await getUsage(
			account.address,
			blockTimestampFrom,
			blockTimestampTo,
		)

		return c.json(data)
	},
)

app.all('*', rateLimitMiddleware, async (c) => {
	const handler = Handler.feePayer({
		account: privateKeyToAccount(env.SPONSOR_PRIVATE_KEY as `0x${string}`),
		chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),
		transport: http(env.TEMPO_RPC_URL),
		async onRequest(request) {
			console.log(`Sponsoring transaction: ${request.method}`)
		},
	})
	return handler.fetch(c.req.raw)
})

export default app

```

## File: apps/fee-payer/src/lib/consts.ts
```
export const alphaUsd =
	'0x20c0000000000000000000000000000000000001' as const

```

## File: apps/fee-payer/src/lib/rate-limit.ts
```
import { env } from 'cloudflare:workers'
import type { Context, Next } from 'hono'
import { cloneRawRequest } from 'hono/request'
import { RpcRequest } from 'ox'
import { Transaction } from 'tempo.ts/viem'

/**
 * Middleware that rate limits requests based on the transaction's `from` address.
 * Extracts the transaction from the RPC request and checks against the rate limiter.
 * Returns 429 if rate limit is exceeded.
 */
export async function rateLimitMiddleware(c: Context, next: Next) {
	// Clone the request to read the body without consuming the original
	const clonedRequest = await cloneRawRequest(c.req)
	const request = RpcRequest.from((await clonedRequest.json()) as any)
	const serialized = request.params?.[0] as `0x76${string}`

	const transaction = Transaction.deserialize(serialized)
	const from = (transaction as any).from

	const { success } = await env.AddressRateLimiter.limit({
		key: from,
	})

	if (!success) return c.json({ error: 'Rate limit exceeded' }, 429)

	await next()
}

```

## File: apps/fee-payer/src/lib/usage.ts
```
import { env } from 'cloudflare:workers'
import * as IDX from 'idxs'
import { sql } from 'kysely'
import type { Address } from 'ox'
import { tempo, tempoTestnet } from 'tempo.ts/chains'
import { Actions, Addresses } from 'tempo.ts/viem'
import { createPublicClient, formatUnits, http } from 'viem'
import { alphaUsd } from './consts.js'

const IS = IDX.IndexSupply.create({
	apiKey: env.INDEXSUPPLY_API_KEY,
})

const QB = IDX.QueryBuilder.from(IS)

const TRANSFER_SIGNATURE =
	'event Transfer(address indexed from, address indexed to, uint256 tokens)'

const epochToTimestamp = (epoch: number): string =>
	new Date(epoch * 1000).toISOString()

/**
 * Fetch fee payer usage statistics from IndexSupply
 * @param feePayerAddress Address of the fee payer account
 * @param blockTimestampFrom Optional start timestamp (inclusive)
 * @param blockTimestampTo Optional end timestamp (inclusive)
 * @returns Usage statistics including fees paid, transaction count, and time range
 */
export async function getUsage(
	feePayerAddress: Address.Address,
	blockTimestampFrom?: number,
	blockTimestampTo?: number,
) {
	const query = QB.withSignatures([TRANSFER_SIGNATURE])
		.selectFrom('transfer')
		.select((eb) => [
			eb.fn.sum('tokens').as('total_spent'),
			sql<number>`max(transfer.block_timestamp)`.as('ending_at'),
			sql<number>`min(transfer.block_timestamp)`.as('starting_at'),
			eb.fn.count('tx_hash').as('n_transactions'),
		])
		.where('chain', '=', tempo.id)
		.where('from', '=', feePayerAddress)
		.where('to', '=', Addresses.feeManager)
		.$if(blockTimestampFrom !== undefined, (eb) =>
			eb.where(
				sql`transfer.block_timestamp::timestamp`,
				'>=',
				`'${epochToTimestamp(blockTimestampFrom as number)}'`,
			),
		)
		.$if(blockTimestampTo !== undefined, (eb) =>
			eb.where(
				sql`transfer.block_timestamp::timestamp`,
				'<=',
				`'${epochToTimestamp(blockTimestampTo as number)}'`,
			),
		)

	const result = await query.executeTakeFirst()

	const feesPaid = result?.total_spent ? BigInt(result.total_spent) : 0n
	const feeTokenMetadata = await Actions.token.getMetadata(
		createPublicClient({
			chain: tempoTestnet({}),
			transport: http(),
		}),
		{ token: alphaUsd },
	)

	return {
		feePayerAddress,
		feesPaid: formatUnits(feesPaid, feeTokenMetadata.decimals),
		feeCurrency: feeTokenMetadata.currency,
		numTransactions: result?.n_transactions ? Number(result.n_transactions) : 0,
		endingAt: result?.ending_at ?? null,
		startingAt: result?.starting_at ?? null,
	}
}

```

## File: apps/service-proxy/src/index.ts
```
import { env } from 'cloudflare:workers'
import { type Context, Hono, type Next } from 'hono'
import { cors } from 'hono/cors'

const app = new Hono()

app.use(
	cors({
		origin: (origin) => {
			if (!origin) return null
			const allowed = env.ALLOWED_HOSTNAMES.split(',').some(
				matchesOrigin(origin),
			)
			return allowed ? origin : null
		},
	}),
)
app.use(rateLimit)

app.all('/index-supply/*', async (c) => {
	const apiKey = env.INDEXSUPPLY_API_KEY
	if (!apiKey)
		return c.json({ error: 'INDEXSUPPLY_API_KEY not configured' }, 500)

	const reqUrl = new URL(c.req.url)
	const url = new URL(
		`${reqUrl.pathname.replace('/index-supply', '')}${reqUrl.search}`,
		'https://api.indexsupply.net',
	)

	url.searchParams.set('api-key', apiKey)

	const response = await fetch(url, {
		method: c.req.method,
		headers: c.req.raw.headers,
		body: c.req.raw.body,
	})

	const headers = new Headers()
	for (const header of ['content-type', 'cache-control', 'expires', 'etag']) {
		const value = response.headers.get(header)
		if (value) headers.set(header, value)
	}

	return new Response(response.body, {
		status: response.status,
		statusText: response.statusText,
		headers,
	})
})

export default app

/** Rate limit middleware. */
async function rateLimit(c: Context, next: Next) {
	const ip = c.req.raw.headers.get('cf-connecting-ip') || 'unknown'
	const path = c.req.path
	const { success } = await env.REQUESTS_RATE_LIMITER.limit({
		key: `${ip}:${path}`,
	})
	if (!success) return c.json({ error: 'Rate limit exceeded' }, 429)
	await next()
}

/**
 * Checks if an origin matches an allowed hostname pattern.
 * Supports wildcard patterns like "*.example.com"
 */
function matchesOrigin(origin: string) {
	return (pattern: string) => {
		// Exact match
		if (origin === pattern) return true

		// Wildcard pattern
		if (pattern.includes('*')) {
			// Escape special regex characters except *
			const regexPattern = pattern
				.replace(/[.+?^${}()|[\]\\]/g, '\\$&')
				.replace(/\*/g, '.*')
			const regex = new RegExp(`^${regexPattern}$`)
			return regex.test(origin)
		}

		return false
	}
}

```

## File: .git-blame-ignore-revs
```
# This file contains a list of commits that are not likely what you
# are looking for in a blame, such as mass reformatting or renaming.
# You can set this file as a default ignore file for blame by running
# the following command.
#
# $ git config blame.ignoreRevsFile .git-blame-ignore-revs

#
# explorer files re-org
9dc2437222cedd90e9d595b9ae934f1bac8b426b

```

## File: .github/ISSUE_TEMPLATE/bug_report.yml
```
name: Bug Report
description: Report bugs or issues.
body:
  - type: textarea
    attributes:
      label: Describe the bug
      description: Clear and concise description of the bug.
      placeholder: I am doing… What I expect is… What is actually happening…
    validations:
      required: true

  - type: input
    id: reproduction
    attributes:
      label: Where did this happen?
      description: "Please provide a link to where this issue happened."
      placeholder: https://explore.tempo.xyz/abc
    validations:
      required: false

  - type: textarea
    attributes:
      label: Steps To Reproduce
      description: Steps or code snippets to reproduce the behavior.
    validations:
      required: false

  - type: dropdown
    attributes:
      label: Operating System
      options:
        - 'iOS'
        - 'iPadOS'
        - 'macOS'
        - 'Android'
        - 'Linux'
        - 'Windows'
        - 'Other'
    validations:
      required: false

  - type: input
    id: os-version
    attributes:
      label: Operating System version
      description: What version of the operating system mentioned are you using?
      placeholder: x.y.z (do not write `latest`)
    validations:
      required: false

  - type: dropdown
    attributes:
      label: Browser
      options:
        - 'Safari'
        - 'Brave'
        - 'Chrome'
        - 'Firefox'
        - 'Other'
    validations:
      required: false

  - type: input
    id: browser-version
    attributes:
      label: Browser version
      description: What version of the borwser mentioned are you using?
      placeholder: x.y.z (do not write `latest`)
    validations:
      required: false

  - type: textarea
    attributes:
      label: Anything else?
      description: Anything that will give us more context about the issue you are encountering.
    validations:
      required: false




```

## File: .github/ISSUE_TEMPLATE/feature_request.yml
```
name: Feature Request
description: Request a feature to be added to a Tempo app.
body:
  - type: textarea
    attributes:
      label: Describe the solution you'd like
      description: A clear and concise description of what you need or want to happen.
    validations:
      required: true

```

## File: .github/actions/install-dependencies/action.yml
```
name: 'Install dependencies'
description: 'Prepare repository and all dependencies'

runs:
  using: 'composite'
  steps:
    - name: Set up pnpm
      uses: pnpm/action-setup@v4

    - name: Set up Node
      uses: actions/setup-node@v6
      with:
        node-version: 'lts/*'

    - name: Install dependencies
      shell: bash
      run: pnpm install

```

## File: .github/workflows/main.yml
```
name: Main
on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  verify:
    name: Verify
    uses: ./.github/workflows/verify.yml
    secrets: inherit

  deploy:
    name: Deploy (${{ matrix.app }}${{ matrix.env && format('-{0}', matrix.env) || '' }})
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          - app: explorer
          - app: fee-payer # default
          - app: fee-payer # privy
            env: privy
          - app: service-proxy

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: "recursive"
          fetch-depth: 0

      # deploy workspace preview only if there are relevant changes
      # deploy all apps if root lockfile is changed
      - name: Check for relevant changes
        id: changes
        run: |
          if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -qE "^(apps/${{ matrix.app }}/|pnpm-lock.yaml)"; then
            echo "relevant=true" >> $GITHUB_OUTPUT
          else
            echo "relevant=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        if: steps.changes.outputs.relevant == 'true'
        uses: ./.github/actions/install-dependencies

      - name: Build & Deploy Workers
        if: steps.changes.outputs.relevant == 'true'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: apps/${{ matrix.app }}
          command: ${{ matrix.env == 'privy' && 'deploy --env privy' || 'deploy --env=""' }}

```

## File: .github/workflows/pull-request.yml
```
name: Pull Request
on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  verify:
    name: Verify
    uses: ./.github/workflows/verify.yml
    secrets: inherit

  deploy-preview:
    name: Deploy Preview (${{ matrix.app }})
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    strategy:
      matrix:
        app: [explorer, fee-payer]

    steps:
      - name: Clone repository
        uses: actions/checkout@v5
        with:
          submodules: "recursive"
          fetch-depth: 0

      # deploy workspace preview only if there are relevant changes
      # deploy all apps if root lockfile is changed
      - name: Check for relevant changes
        id: changes
        run: |
          if git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -qE "^(apps/${{ matrix.app }}/|pnpm-lock.yaml)"; then
            echo "relevant=true" >> $GITHUB_OUTPUT
          else
            echo "relevant=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        if: steps.changes.outputs.relevant == 'true'
        uses: ./.github/actions/install-dependencies

      - name: Build
        if: steps.changes.outputs.relevant == 'true'
        run: pnpm build
        working-directory: apps/${{ matrix.app }}

      - name: Upload Worker Version
        if: steps.changes.outputs.relevant == 'true'
        id: deploy
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: versions upload
          workingDirectory: apps/${{ matrix.app }}

      - name: Comment Preview URL on PR
        if: steps.changes.outputs.relevant == 'true'
        uses: moojing/cf-preview-bot@v1
        with:
          deployment_url: ${{ steps.deploy.outputs.deployment-url }}
          branch_preview_url: ${{ steps.deploy.outputs.pages-deployment-alias-url }}

```

## File: .github/workflows/verify.yml
```
name: Verify
on:
  workflow_call:
  workflow_dispatch:

jobs:
  checks:
    name: Checks
    runs-on: ubuntu-latest

    steps:
      - name: Clone repository
        uses: actions/checkout@v5
        with:
          submodules: 'recursive'

      - name: Install dependencies
        uses: ./.github/actions/install-dependencies

      - name: Check code and types
        run: pnpm gen:types && pnpm check


```

## File: .vscode/extensions.json
```
{
	"recommendations": [
		"biomejs.biome",
		"bradlc.vscode-tailwindcss",
		"wayou.vscode-todo-highlight"
	],
	"unwantedRecommendations": [
		"esbenp.prettier-vscode",
		"dbaeumer.vscode-eslint"
	]
}

```

## File: .vscode/settings.json
```
{
	"typescript.tsdk": "node_modules/typescript/lib",
	"typescript.enablePromptUseWorkspaceTsdk": true,
	"typescript.preferences.importModuleSpecifierEnding": "js",
	"javascript.preferences.importModuleSpecifierEnding": "js",
	"typescript.preferences.importModuleSpecifier": "non-relative",
	"javascript.preferences.importModuleSpecifier": "non-relative",
	"typescript.preferences.autoImportFileExcludePatterns": [
		"**/node_modules/**/_*/**"
	],
	"javascript.preferences.autoImportFileExcludePatterns": [
		"**/node_modules/**/_*/**"
	],
	"editor.formatOnSave": true,
	"files.watcherExclude": {
		"**/routeTree.gen.ts": true
	},
	"search.exclude": {
		"**/routeTree.gen.ts": true
	},
	"files.readonlyInclude": {
		"**/routeTree.gen.ts": true
	},
	"[javascript]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[javascriptreact]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[typescript]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[typescriptreact]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[json]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[jsonc]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"[css]": {
		"editor.defaultFormatter": "biomejs.biome"
	},
	"editor.codeActionsOnSave": {
		"source.organizeImports.biome": "explicit"
	},
	"files.associations": {
		"*.svg": "html",
		"biome.json": "jsonc",
		"*.css": "tailwindcss"
	},
	"files.exclude": {
		"**/.tanstack": true,
		"**/*.wrangler": true,
		"**/.pnpm-store/**": true
	},
	"tailwindCSS.experimental.classRegex": [
		"cx\\(([^)]+)\\)",
		"twMerge\\(([^)]+)\\)"
	]
}

```

## File: apps/explorer/env.d.ts
```
interface EnvironmentVariables {
	readonly INDEXER_API_KEY: string | undefined
	readonly VITE_LOG_LEVEL: 'info' | 'warn' | 'silent'
}

interface ImportMetaEnv extends Cloudflare.Env {}

interface ImportMeta {
	readonly env: ImportMetaEnv
}

declare namespace NodeJS {
	interface ProcessEnv extends EnvironmentVariables {}
}

```

## File: apps/explorer/package.json
```
{
	"name": "explorer",
	"private": true,
	"type": "module",
	"scripts": {
		"build": "vite build",
		"check": "pnpm check:biome && pnpm check:types",
		"check:biome": "biome check --write --unsafe",
		"check:types": "tsgo --project tsconfig.json --noEmit",
		"check:types:test": "tsc --project tsconfig.test.json --noEmit",
		"deploy": "pnpm build && wrangler deploy",
		"dev": "VITE_ENABLE_DEMO=true vite dev --port 3000",
		"gen:tokens-index": "node --experimental-strip-types --env-file=.env scripts/generate-tokens-index.ts",
		"gen:types": "test -f .env || cp .env.example .env; wrangler types",
		"postinstall": "pnpm gen:types && pnpm build",
		"preview": "vite preview",
		"test": "vitest"
	},
	"dependencies": {
		"@shazow/whatsabi": "catalog:",
		"@tailwindcss/vite": "catalog:",
		"@tanstack/query-async-storage-persister": "catalog:",
		"@tanstack/react-query": "catalog:",
		"@tanstack/react-query-persist-client": "catalog:",
		"@tanstack/react-router": "catalog:",
		"@tanstack/react-router-ssr-query": "catalog:",
		"@tanstack/react-start": "catalog:",
		"@tanstack/router-plugin": "catalog:",
		"abitype": "catalog:",
		"cva": "catalog:",
		"idxs": "catalog:",
		"ox": "catalog:",
		"react": "catalog:",
		"react-dom": "catalog:",
		"tailwind-merge": "catalog:",
		"tailwindcss": "catalog:",
		"tempo.ts": "catalog:",
		"viem": "catalog:",
		"wagmi": "catalog:",
		"zod": "catalog:"
	},
	"devDependencies": {
		"@cloudflare/puppeteer": "catalog:",
		"@cloudflare/vite-plugin": "catalog:",
		"@cloudflare/vitest-pool-workers": "catalog:",
		"@iconify/json": "catalog:",
		"@svgr/core": "catalog:",
		"@svgr/plugin-jsx": "catalog:",
		"@tanstack/devtools-vite": "catalog:",
		"@tanstack/react-devtools": "catalog:",
		"@tanstack/react-query-devtools": "catalog:",
		"@tanstack/react-router-devtools": "catalog:",
		"@total-typescript/ts-reset": "^0.6.1",
		"@types/node": "catalog:",
		"@types/react": "catalog:",
		"@types/react-dom": "catalog:",
		"@vitejs/plugin-react": "catalog:",
		"eruda": "catalog:",
		"tw-animate-css": "catalog:",
		"typed-query-selector": "catalog:",
		"unplugin-icons": "catalog:",
		"vite": "catalog:",
		"vite-plugin-devtools-json": "^1.0.0",
		"vite-tsconfig-paths": "catalog:",
		"vitest": "catalog:",
		"wrangler": "catalog:"
	}
}

```

## File: apps/explorer/public/robots.txt
```
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

```

## File: apps/explorer/reset.d.ts
```
import '@total-typescript/ts-reset/dom'

```

## File: apps/explorer/scripts/generate-tokens-index.ts
```
import { writeFileSync } from 'node:fs'
import { resolve } from 'node:path'

const indexSupplyEndpoint = 'https://api.tempo.xyz/indexer/query'
const chainId = 42429

const eventSignature =
	'TokenCreated(address indexed token, uint256 indexed tokenId, string name, string symbol, string currency, address quoteToken, address admin)'

const query =
	`SELECT token, symbol, name FROM tokencreated ` +
	`WHERE chain = ${chainId} ORDER BY block_timestamp DESC`

type Token = [address: string, symbol: string, name: string]

// native tokens (not created via factory)
const nativeTokens: Token[] = [
	['0x20c0000000000000000000000000000000000000', 'pathUSD', 'pathUSD'],
	['0x20c0000000000000000000000000000000000001', 'AlphaUSD', 'AlphaUSD'],
	['0x20c0000000000000000000000000000000000002', 'BetaUSD', 'BetaUSD'],
	['0x20c0000000000000000000000000000000000003', 'ThetaUSD', 'ThetaUSD'],
]

async function fetchAllTokens(): Promise<Token[]> {
	const apiKey = process.env.INDEXER_API_KEY
	if (!apiKey)
		throw new Error('INDEXER_API_KEY environment variable is required')

	const url = new URL(indexSupplyEndpoint)
	url.searchParams.set('api-key', apiKey)

	const response = await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify([
			{ cursor: `${chainId}-0`, signatures: [eventSignature], query },
		]),
	})

	if (!response.ok)
		throw new Error(
			`IndexSupply API error (${response.status}): ${await response.text()}`,
		)

	const data = (await response.json()) as Array<{ rows?: unknown[][] }>
	const [result] = data

	if (!result?.rows)
		throw new Error('Unexpected response format from IndexSupply')

	return result.rows.map(
		(row): Token => [
			String(row[0]).toLowerCase(), // address
			String(row[1]), // symbol
			String(row[2]), // name
		],
	)
}

async function main() {
	console.log('Fetching tokens from IndexSupply…')

	const fetchedTokens = await fetchAllTokens()
	console.log(`Found ${fetchedTokens.length} tokens.`)

	const tokens = [...nativeTokens, ...fetchedTokens]
	console.log(`Total including native: ${tokens.length}.`)

	const outputPath = resolve(
		import.meta.dirname,
		'../src/data/tokens-index.json',
	)

	const lines = tokens.map((t) => `\t${JSON.stringify(t)}`)
	writeFileSync(outputPath, `[\n${lines.join(',\n')}\n]\n`)
	console.log(`Written to ${outputPath}`)
}

main().catch((error) => {
	console.error('Error:', error)
	process.exit(1)
})

```

## File: apps/explorer/tsconfig.test.json
```
{
	"extends": "./tsconfig.json",
	"include": ["**/*.test.ts", "**/*.test.tsx"],
	"compilerOptions": {
		"types": [
			"@cloudflare/vitest-pool-workers",
			"node",
			"vite/client",
			"typed-query-selector/strict",
			"unplugin-icons/types/react"
		]
	}
}

```

## File: apps/explorer/wrangler.jsonc
```
{
	"$schema": "https://esm.sh/wrangler/config-schema.json",
	"name": "explorer",
	"compatibility_date": "2025-10-11",
	"compatibility_flags": ["nodejs_compat"],
	"main": "./src/index.server.ts",
	"browser": {
		"binding": "BROWSER"
	},
	"workers_dev": true,
	"preview_urls": true,
	"keep_vars": true,
	"observability": {
		"enabled": true,
		"logs": {
			"enabled": true,
			"head_sampling_rate": 1,
			"invocation_logs": true,
			"persist": true
		}
	},
	"placement": {
		"mode": "smart"
	}
}

```

## File: apps/fee-payer/package.json
```
{
	"name": "fee-payer",
	"private": true,
	"scripts": {
		"build": "echo 'noop'",
		"check": "pnpm check:biome && pnpm check:types",
		"check:biome": "biome check --write .",
		"check:types": "tsgo --project tsconfig.json --noEmit",
		"dev": "wrangler dev",
		"dev:playground": "pnpm --filter fee-payer-playground dev",
		"deploy": "wrangler deploy",
		"deploy:privy": "wrangler deploy --env privy",
		"format": "biome format --write .",
		"gen:types": "test -f .env || cp .env.example .env; wrangler types",
		"postinstall": "pnpm gen:types",
		"tail": "wrangler tail"
	},
	"dependencies": {
		"@hono/zod-validator": "catalog:",
		"hono": "catalog:",
		"idxs": "catalog:",
		"kysely": "catalog:",
		"ox": "catalog:",
		"tempo.ts": "catalog:",
		"viem": "catalog:",
		"zod": "catalog:"
	},
	"devDependencies": {
		"@cloudflare/workers-types": "catalog:",
		"@types/node": "catalog:",
		"typescript": "catalog:",
		"wrangler": "catalog:"
	}
}

```

## File: apps/fee-payer/playground/index.html
```
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<link rel="icon" type="image/svg+xml" href="/vite.svg">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Fee Payer Playground</title>
	</head>
	<body>
		<div id="root"></div>
		<script type="module" src="/src/main.tsx"></script>
	</body>
</html>

```

## File: apps/fee-payer/playground/package.json
```
{
	"name": "fee-payer-playground",
	"private": true,
	"type": "module",
	"scripts": {
		"build": "tsc -b && vite build",
		"check:types": "tsc -b",
		"dev": "vite",
		"preview": "vite preview"
	},
	"dependencies": {
		"@tanstack/react-query": "^5.90.12",
		"react": "^19.2.1",
		"react-dom": "^19.2.1",
		"tempo.ts": "catalog:",
		"viem": "catalog:",
		"wagmi": "catalog:"
	},
	"devDependencies": {
		"@types/node": "catalog:",
		"@types/react": "catalog:",
		"@types/react-dom": "catalog:",
		"@vitejs/plugin-react": "catalog:",
		"globals": "catalog:",
		"typescript": "catalog:",
		"vite": "catalog:"
	}
}

```

## File: apps/fee-payer/playground/tsconfig.app.json
```
{
	"compilerOptions": {
		"tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
		"target": "ES2022",
		"useDefineForClassFields": true,
		"lib": ["ES2022", "DOM", "DOM.Iterable"],
		"module": "ESNext",
		"types": ["vite/client"],
		"skipLibCheck": true,

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"moduleDetection": "force",
		"noEmit": true,
		"jsx": "react-jsx",

		/* Linting */
		"strict": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"noFallthroughCasesInSwitch": true,
		"noUncheckedSideEffectImports": true
	},
	"include": ["src"]
}

```

## File: apps/fee-payer/playground/tsconfig.node.json
```
{
	"compilerOptions": {
		"tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
		"target": "ES2023",
		"lib": ["ES2023"],
		"module": "ESNext",
		"types": ["node"],
		"skipLibCheck": true,

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"moduleDetection": "force",
		"noEmit": true,

		/* Linting */
		"strict": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"noFallthroughCasesInSwitch": true,
		"noUncheckedSideEffectImports": true
	},
	"include": ["vite.config.ts"]
}

```

## File: apps/fee-payer/wrangler.jsonc
```
{
	"$schema": "https://esm.sh/wrangler/config-schema.json",
	"name": "fee-payer",
	"compatibility_date": "2025-11-20",
	"compatibility_flags": ["nodejs_compat"],
	"main": "./src/index.ts",
	"routes": [{ "pattern": "sponsor.testnet.tempo.xyz", "custom_domain": true }],
	"workers_dev": false,
	"preview_urls": true,
	"keep_vars": true,
	"observability": {
		"enabled": true,
		"logs": {
			"enabled": true,
			"head_sampling_rate": 1,
			"invocation_logs": true,
			"persist": true
		}
	},
	"ratelimits": [
		{
			"name": "AddressRateLimiter",
			"namespace_id": "888",
			"simple": {
				"limit": 1000,
				"period": 60
			}
		}
	],
	"env": {
		"privy": {
			"name": "fee-payer-privy",
			"routes": [
				{ "pattern": "privy-sponsor.testnet.tempo.xyz", "custom_domain": true }
			],
			"workers_dev": false
		}
	}
}

```

## File: apps/service-proxy/package.json
```
{
	"name": "service-proxy",
	"type": "module",
	"scripts": {
		"dev": "wrangler dev",
		"deploy": "wrangler deploy",
		"check:types": "tsgo --project tsconfig.json",
		"gen:types": "test -f .env || cp .env.example .env; wrangler types"
	},
	"dependencies": {
		"hono": "catalog:"
	},
	"devDependencies": {
		"@cloudflare/workers-types": "catalog:",
		"wrangler": "catalog:"
	}
}

```

## File: apps/service-proxy/wrangler.jsonc
```
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "service-proxy",
	"main": "src/index.ts",
	"compatibility_date": "2025-12-08",
	"compatibility_flags": ["nodejs_compat"],
	"vars": {
		"ALLOWED_HOSTNAMES": "*.tempo.xyz,*.porto.workers.dev"
	},
	"ratelimits": [
		{
			"name": "REQUESTS_RATE_LIMITER",
			"namespace_id": "1001",
			"simple": {
				"limit": 30,
				"period": 10
			}
		}
	],
	"observability": {
		"enabled": true,
		"head_sampling_rate": 1
	}
}

```

## File: biome.json
```
{
	"$schema": "https://biomejs.dev/schemas/2.3.8/schema.json",
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"useIgnoreFile": true
	},
	"css": {
		"assist": {
			"enabled": true
		},
		"parser": {
			"tailwindDirectives": true
		},
		"formatter": {
			"enabled": true
		},
		"linter": {
			"enabled": true
		}
	},
	"html": {
		"formatter": {
			"enabled": true
		},
		"assist": {
			"enabled": true
		},
		"linter": {
			"enabled": true
		}
	},
	"json": {
		"formatter": {
			"enabled": true
		}
	},
	"files": {
		"ignoreUnknown": false,
		"includes": ["**", "!**/routeTree.gen.ts", "!**/tokens-index.json", "!**/_"]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"linter": {
		"enabled": true,
		"domains": {
			"react": "all",
			"project": "all"
		},
		"rules": {
			"recommended": true,
			"correctness": {
				"useImportExtensions": "off",
				"noUndeclaredDependencies": "off"
			},
			"style": {
				"useComponentExportOnlyModules": "off"
			},
			"suspicious": {
				"noUnknownAtRules": {
					"level": "warn",
					"options": {
						"ignore": ["@custom-variant", "@theme"]
					}
				}
			},
			"a11y": {
				"noAutofocus": "off"
			}
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "single",
			"semicolons": "asNeeded"
		}
	},
	"assist": {
		"enabled": true,
		"actions": {
			"source": {
				"organizeImports": "on"
			}
		}
	},
	"overrides": [
		{
			"includes": ["**/env.d.ts", "**/worker-configuration.d.ts"],
			"linter": {
				"rules": {
					"style": {
						"useExportType": "off"
					},
					"correctness": {
						"noUnusedVariables": "off"
					},
					"complexity": {
						"noBannedTypes": "off",
						"noStaticOnlyClass": "off"
					},
					"suspicious": {
						"noExplicitAny": "off"
					}
				}
			}
		},
		{
			"includes": ["**/biome.json", "**/tsconfig.json", "**/.vscode/*.json"],
			"json": {
				"parser": {
					"allowComments": true,
					"allowTrailingCommas": true
				}
			}
		}
	]
}

```

## File: pnpm-workspace.yaml
```
packages:
  - apps/**

catalog:
  '@biomejs/biome': ^2.3.8
  '@cloudflare/puppeteer': ^1.0.4
  '@cloudflare/vite-plugin': ^1.17.0
  '@cloudflare/vitest-pool-workers': ^0.10.14
  '@cloudflare/workers-types': ^4.20251209.0
  '@hono/zod-validator': ^0.7.5
  '@iconify/json': ^2.2.416
  '@shazow/whatsabi': ^0.24.0
  '@svgr/core': ^8.1.0
  '@svgr/plugin-jsx': ^8.1.0
  '@tailwindcss/vite': ^4.1.17
  '@tanstack/devtools-vite': ^0.3.12
  '@tanstack/query-async-storage-persister': ^5.90.14
  '@tanstack/react-devtools': ^0.8.4
  '@tanstack/react-query': ^5.90.12
  '@tanstack/react-query-devtools': ^5.91.1
  '@tanstack/react-query-persist-client': ^5.90.14
  '@tanstack/react-router': ^1.140.0
  '@tanstack/react-router-devtools': ^1.140.0
  '@tanstack/react-router-ssr-query': ^1.140.0
  '@tanstack/react-start': ^1.140.0
  '@tanstack/router-plugin': ^1.140.0
  '@total-typescript/ts-reset': ^0.6.1
  '@types/node': ^24.10.2
  '@types/react': ^19.2.7
  '@types/react-dom': ^19.2.3
  '@vitejs/plugin-react': ^5.1.2
  abitype: ^1.2.1
  cva: ^1.0.0-beta.4
  eruda: ^3.4.3
  globals: ^16.5.0
  hono: ^4.10.8
  idxs: ^0.0.5
  kysely: ^0.28.8
  ox: ^0.9.17
  react: ^19.2.1
  react-dom: ^19.2.1
  tailwind-merge: ^3.4.0
  tailwindcss: ^4.1.17
  tempo.ts: ~0.10.5
  tw-animate-css: ^1.4.0
  typed-query-selector: ^2.12.0
  typescript: ^5.9.3
  unplugin-icons: ^22.5.0
  viem: ^2.41.2
  vite: npm:rolldown-vite@latest
  vite-tsconfig-paths: ^5.1.4
  vitest: 3.2.4
  wagmi: ^3.1.0
  wrangler: ^4.53.0
  zod: ^4.1.13

catalogMode: strict

```


---

# Repository Tree (with token estimates)

├── .github/ (~1,703 tokens)
│   ├── actions/ (~89 tokens)
│   │   └── install-dependencies/ (~89 tokens)
│   │       └── action.yml (~89 tokens)
│   ├── ISSUE_TEMPLATE/ (~547 tokens)
│   │   ├── bug_report.yml (~473 tokens)
│   │   └── feature_request.yml (~74 tokens)
│   └── workflows/ (~1,067 tokens)
│       ├── main.yml (~429 tokens)
│       ├── pull-request.yml (~535 tokens)
│       └── verify.yml (~103 tokens)
├── .vscode/ (~447 tokens)
│   ├── extensions.json (~50 tokens)
│   └── settings.json (~397 tokens)
├── apps/ (~137,523 tokens)
│   ├── explorer/ (~132,817 tokens)
│   │   ├── public/ (~17 tokens)
│   │   │   └── robots.txt (~17 tokens)
│   │   ├── scripts/ (~609 tokens)
│   │   │   └── generate-tokens-index.ts (~609 tokens)
│   │   ├── src/ (~131,188 tokens)
│   │   │   ├── comps/ (~40,811 tokens)
│   │   │   │   ├── AccountCard.tsx (~807 tokens)
│   │   │   │   ├── Address.tsx (~161 tokens)
│   │   │   │   ├── AddressCell.tsx (~193 tokens)
│   │   │   │   ├── Amount.tsx (~297 tokens)
│   │   │   │   ├── AmountCell.tsx (~171 tokens)
│   │   │   │   ├── BlockCard.tsx (~2,634 tokens)
│   │   │   │   ├── ContractReader.tsx (~5,227 tokens)
│   │   │   │   ├── ContractWriter.tsx (~17 tokens)
│   │   │   │   ├── CopyButton.tsx (~263 tokens)
│   │   │   │   ├── DataGrid.tsx (~1,541 tokens)
│   │   │   │   ├── DataGridSkeleton.tsx (~183 tokens)
│   │   │   │   ├── ErrorBoundary.tsx (~467 tokens)
│   │   │   │   ├── ExploreInput.tsx (~3,084 tokens)
│   │   │   │   ├── Footer.tsx (~278 tokens)
│   │   │   │   ├── Header.tsx (~1,415 tokens)
│   │   │   │   ├── InfoCard.tsx (~454 tokens)
│   │   │   │   ├── InfoRow.tsx (~105 tokens)
│   │   │   │   ├── Intro.tsx (~2,305 tokens)
│   │   │   │   ├── NotFound.tsx (~387 tokens)
│   │   │   │   ├── Pagination.tsx (~2,584 tokens)
│   │   │   │   ├── ProgressLine.tsx (~367 tokens)
│   │   │   │   ├── Receipt.tsx (~2,532 tokens)
│   │   │   │   ├── ReceiptMark.tsx (~644 tokens)
│   │   │   │   ├── RelativeTime.tsx (~299 tokens)
│   │   │   │   ├── Sections.tsx (~1,462 tokens)
│   │   │   │   ├── Sphere.tsx (~2,476 tokens)
│   │   │   │   ├── TimeFormat.tsx (~615 tokens)
│   │   │   │   ├── TimestampCell.tsx (~165 tokens)
│   │   │   │   ├── TransactionCell.tsx (~110 tokens)
│   │   │   │   ├── TruncatedHash.tsx (~701 tokens)
│   │   │   │   ├── TxDecodedCalldata.tsx (~1,626 tokens)
│   │   │   │   ├── TxDecodedTopics.tsx (~2,411 tokens)
│   │   │   │   ├── TxEventDescription.tsx (~1,115 tokens)
│   │   │   │   ├── TxRawTransaction.tsx (~1,718 tokens)
│   │   │   │   ├── TxTransactionCard.tsx (~920 tokens)
│   │   │   │   └── TxTransactionRow.tsx (~1,077 tokens)
│   │   │   ├── data/ (~22,474 tokens)
│   │   │   │   └── tokens-index.json (~22,474 tokens)
│   │   │   ├── lib/ (~24,941 tokens)
│   │   │   │   ├── domain/ (~14,574 tokens)
│   │   │   │   │   ├── contracts.ts (~3,756 tokens)
│   │   │   │   │   ├── known-events.ts (~7,413 tokens)
│   │   │   │   │   ├── receipt.ts (~3,106 tokens)
│   │   │   │   │   └── tip20.ts (~299 tokens)
│   │   │   │   ├── queries/ (~1,901 tokens)
│   │   │   │   │   ├── account.ts (~238 tokens)
│   │   │   │   │   ├── blocks.ts (~854 tokens)
│   │   │   │   │   ├── index.ts (~25 tokens)
│   │   │   │   │   ├── tokens.ts (~443 tokens)
│   │   │   │   │   └── tx.ts (~341 tokens)
│   │   │   │   ├── server/ (~4,468 tokens)
│   │   │   │   │   ├── account.server.ts (~2,158 tokens)
│   │   │   │   │   ├── latest-block.server.ts (~146 tokens)
│   │   │   │   │   ├── token.server.ts (~1,702 tokens)
│   │   │   │   │   └── tokens.server.ts (~462 tokens)
│   │   │   │   ├── abi.ts (~973 tokens)
│   │   │   │   ├── chars.ts (~25 tokens)
│   │   │   │   ├── demo.ts (~905 tokens)
│   │   │   │   ├── formatting.ts (~1,614 tokens)
│   │   │   │   ├── hooks.ts (~372 tokens)
│   │   │   │   └── zod.ts (~109 tokens)
│   │   │   ├── routes/ (~39,018 tokens)
│   │   │   │   ├── _layout/ (~34,736 tokens)
│   │   │   │   │   ├── address/ (~5,998 tokens)
│   │   │   │   │   │   └── $address.tsx (~5,998 tokens)
│   │   │   │   │   ├── block/ (~3,045 tokens)
│   │   │   │   │   │   └── $id.tsx (~3,045 tokens)
│   │   │   │   │   ├── demo/ (~11,068 tokens)
│   │   │   │   │   │   ├── address.tsx (~6,517 tokens)
│   │   │   │   │   │   ├── empty-state.tsx (~313 tokens)
│   │   │   │   │   │   ├── index.tsx (~215 tokens)
│   │   │   │   │   │   ├── pagination.tsx (~458 tokens)
│   │   │   │   │   │   └── tx.tsx (~3,565 tokens)
│   │   │   │   │   ├── receipt/ (~2,466 tokens)
│   │   │   │   │   │   └── $hash.tsx (~2,466 tokens)
│   │   │   │   │   ├── token/ (~4,635 tokens)
│   │   │   │   │   │   └── $address.tsx (~4,635 tokens)
│   │   │   │   │   ├── tx/ (~3,386 tokens)
│   │   │   │   │   │   └── $hash.tsx (~3,386 tokens)
│   │   │   │   │   ├── blocks.tsx (~2,375 tokens)
│   │   │   │   │   ├── index.tsx (~890 tokens)
│   │   │   │   │   └── tokens.tsx (~873 tokens)
│   │   │   │   ├── api/ (~1,034 tokens)
│   │   │   │   │   └── search.ts (~1,034 tokens)
│   │   │   │   ├── __root.tsx (~1,304 tokens)
│   │   │   │   ├── _layout.tsx (~342 tokens)
│   │   │   │   └── styles.css (~1,602 tokens)
│   │   │   ├── cva.config.ts (~49 tokens)
│   │   │   ├── index.client.tsx (~56 tokens)
│   │   │   ├── index.server.ts (~36 tokens)
│   │   │   ├── index.start.ts (~37 tokens)
│   │   │   ├── router.tsx (~285 tokens)
│   │   │   ├── routeTree.gen.ts (~3,136 tokens)
│   │   │   └── wagmi.config.ts (~345 tokens)
│   │   ├── env.d.ts (~81 tokens)
│   │   ├── package.json (~570 tokens)
│   │   ├── README.md (~153 tokens)
│   │   ├── reset.d.ts (~10 tokens)
│   │   ├── tsconfig.test.json (~65 tokens)
│   │   └── wrangler.jsonc (~124 tokens)
│   ├── fee-payer/ (~3,915 tokens)
│   │   ├── playground/ (~1,992 tokens)
│   │   │   ├── src/ (~1,441 tokens)
│   │   │   │   ├── App.tsx (~1,057 tokens)
│   │   │   │   ├── main.tsx (~142 tokens)
│   │   │   │   └── wagmi.config.ts (~242 tokens)
│   │   │   ├── index.html (~87 tokens)
│   │   │   ├── package.json (~153 tokens)
│   │   │   ├── tsconfig.app.json (~165 tokens)
│   │   │   └── tsconfig.node.json (~146 tokens)
│   │   ├── src/ (~1,315 tokens)
│   │   │   ├── lib/ (~897 tokens)
│   │   │   │   ├── consts.ts (~20 tokens)
│   │   │   │   ├── rate-limit.ts (~252 tokens)
│   │   │   │   └── usage.ts (~625 tokens)
│   │   │   └── index.ts (~418 tokens)
│   │   ├── package.json (~236 tokens)
│   │   ├── README.md (~168 tokens)
│   │   └── wrangler.jsonc (~204 tokens)
│   └── service-proxy/ (~791 tokens)
│       ├── src/ (~526 tokens)
│       │   └── index.ts (~526 tokens)
│       ├── package.json (~95 tokens)
│       ├── README.md (~50 tokens)
│       └── wrangler.jsonc (~120 tokens)
├── .git-blame-ignore-revs (~91 tokens)
├── biome.json (~492 tokens)
├── package.json (~201 tokens)
├── pnpm-workspace.yaml (~382 tokens)
└── README.md (~273 tokens)

---

# Complete File Paths (untruncated)

.git-blame-ignore-revs (~91 tokens)
.github/actions/install-dependencies/action.yml (~89 tokens)
.github/ISSUE_TEMPLATE/bug_report.yml (~473 tokens)
.github/ISSUE_TEMPLATE/feature_request.yml (~74 tokens)
.github/workflows/main.yml (~429 tokens)
.github/workflows/pull-request.yml (~535 tokens)
.github/workflows/verify.yml (~103 tokens)
.vscode/extensions.json (~50 tokens)
.vscode/settings.json (~397 tokens)
apps/explorer/env.d.ts (~81 tokens)
apps/explorer/package.json (~570 tokens)
apps/explorer/public/robots.txt (~17 tokens)
apps/explorer/README.md (~153 tokens)
apps/explorer/reset.d.ts (~10 tokens)
apps/explorer/scripts/generate-tokens-index.ts (~609 tokens)
apps/explorer/src/comps/AccountCard.tsx (~807 tokens)
apps/explorer/src/comps/Address.tsx (~161 tokens)
apps/explorer/src/comps/AddressCell.tsx (~193 tokens)
apps/explorer/src/comps/Amount.tsx (~297 tokens)
apps/explorer/src/comps/AmountCell.tsx (~171 tokens)
apps/explorer/src/comps/BlockCard.tsx (~2,634 tokens)
apps/explorer/src/comps/ContractReader.tsx (~5,227 tokens)
apps/explorer/src/comps/ContractWriter.tsx (~17 tokens)
apps/explorer/src/comps/CopyButton.tsx (~263 tokens)
apps/explorer/src/comps/DataGrid.tsx (~1,541 tokens)
apps/explorer/src/comps/DataGridSkeleton.tsx (~183 tokens)
apps/explorer/src/comps/ErrorBoundary.tsx (~467 tokens)
apps/explorer/src/comps/ExploreInput.tsx (~3,084 tokens)
apps/explorer/src/comps/Footer.tsx (~278 tokens)
apps/explorer/src/comps/Header.tsx (~1,415 tokens)
apps/explorer/src/comps/InfoCard.tsx (~454 tokens)
apps/explorer/src/comps/InfoRow.tsx (~105 tokens)
apps/explorer/src/comps/Intro.tsx (~2,305 tokens)
apps/explorer/src/comps/NotFound.tsx (~387 tokens)
apps/explorer/src/comps/Pagination.tsx (~2,584 tokens)
apps/explorer/src/comps/ProgressLine.tsx (~367 tokens)
apps/explorer/src/comps/Receipt.tsx (~2,532 tokens)
apps/explorer/src/comps/ReceiptMark.tsx (~644 tokens)
apps/explorer/src/comps/RelativeTime.tsx (~299 tokens)
apps/explorer/src/comps/Sections.tsx (~1,462 tokens)
apps/explorer/src/comps/Sphere.tsx (~2,476 tokens)
apps/explorer/src/comps/TimeFormat.tsx (~615 tokens)
apps/explorer/src/comps/TimestampCell.tsx (~165 tokens)
apps/explorer/src/comps/TransactionCell.tsx (~110 tokens)
apps/explorer/src/comps/TruncatedHash.tsx (~701 tokens)
apps/explorer/src/comps/TxDecodedCalldata.tsx (~1,626 tokens)
apps/explorer/src/comps/TxDecodedTopics.tsx (~2,411 tokens)
apps/explorer/src/comps/TxEventDescription.tsx (~1,115 tokens)
apps/explorer/src/comps/TxRawTransaction.tsx (~1,718 tokens)
apps/explorer/src/comps/TxTransactionCard.tsx (~920 tokens)
apps/explorer/src/comps/TxTransactionRow.tsx (~1,077 tokens)
apps/explorer/src/cva.config.ts (~49 tokens)
apps/explorer/src/data/tokens-index.json (~22,474 tokens)
apps/explorer/src/index.client.tsx (~56 tokens)
apps/explorer/src/index.server.ts (~36 tokens)
apps/explorer/src/index.start.ts (~37 tokens)
apps/explorer/src/lib/abi.ts (~973 tokens)
apps/explorer/src/lib/chars.ts (~25 tokens)
apps/explorer/src/lib/demo.ts (~905 tokens)
apps/explorer/src/lib/domain/contracts.ts (~3,756 tokens)
apps/explorer/src/lib/domain/known-events.ts (~7,413 tokens)
apps/explorer/src/lib/domain/receipt.ts (~3,106 tokens)
apps/explorer/src/lib/domain/tip20.ts (~299 tokens)
apps/explorer/src/lib/formatting.ts (~1,614 tokens)
apps/explorer/src/lib/hooks.ts (~372 tokens)
apps/explorer/src/lib/queries/account.ts (~238 tokens)
apps/explorer/src/lib/queries/blocks.ts (~854 tokens)
apps/explorer/src/lib/queries/index.ts (~25 tokens)
apps/explorer/src/lib/queries/tokens.ts (~443 tokens)
apps/explorer/src/lib/queries/tx.ts (~341 tokens)
apps/explorer/src/lib/server/account.server.ts (~2,158 tokens)
apps/explorer/src/lib/server/latest-block.server.ts (~146 tokens)
apps/explorer/src/lib/server/token.server.ts (~1,702 tokens)
apps/explorer/src/lib/server/tokens.server.ts (~462 tokens)
apps/explorer/src/lib/zod.ts (~109 tokens)
apps/explorer/src/router.tsx (~285 tokens)
apps/explorer/src/routes/__root.tsx (~1,304 tokens)
apps/explorer/src/routes/_layout.tsx (~342 tokens)
apps/explorer/src/routes/_layout/address/$address.tsx (~5,998 tokens)
apps/explorer/src/routes/_layout/block/$id.tsx (~3,045 tokens)
apps/explorer/src/routes/_layout/blocks.tsx (~2,375 tokens)
apps/explorer/src/routes/_layout/demo/address.tsx (~6,517 tokens)
apps/explorer/src/routes/_layout/demo/empty-state.tsx (~313 tokens)
apps/explorer/src/routes/_layout/demo/index.tsx (~215 tokens)
apps/explorer/src/routes/_layout/demo/pagination.tsx (~458 tokens)
apps/explorer/src/routes/_layout/demo/tx.tsx (~3,565 tokens)
apps/explorer/src/routes/_layout/index.tsx (~890 tokens)
apps/explorer/src/routes/_layout/receipt/$hash.tsx (~2,466 tokens)
apps/explorer/src/routes/_layout/token/$address.tsx (~4,635 tokens)
apps/explorer/src/routes/_layout/tokens.tsx (~873 tokens)
apps/explorer/src/routes/_layout/tx/$hash.tsx (~3,386 tokens)
apps/explorer/src/routes/api/search.ts (~1,034 tokens)
apps/explorer/src/routes/styles.css (~1,602 tokens)
apps/explorer/src/routeTree.gen.ts (~3,136 tokens)
apps/explorer/src/wagmi.config.ts (~345 tokens)
apps/explorer/tsconfig.test.json (~65 tokens)
apps/explorer/wrangler.jsonc (~124 tokens)
apps/fee-payer/package.json (~236 tokens)
apps/fee-payer/playground/index.html (~87 tokens)
apps/fee-payer/playground/package.json (~153 tokens)
apps/fee-payer/playground/src/App.tsx (~1,057 tokens)
apps/fee-payer/playground/src/main.tsx (~142 tokens)
apps/fee-payer/playground/src/wagmi.config.ts (~242 tokens)
apps/fee-payer/playground/tsconfig.app.json (~165 tokens)
apps/fee-payer/playground/tsconfig.node.json (~146 tokens)
apps/fee-payer/README.md (~168 tokens)
apps/fee-payer/src/index.ts (~418 tokens)
apps/fee-payer/src/lib/consts.ts (~20 tokens)
apps/fee-payer/src/lib/rate-limit.ts (~252 tokens)
apps/fee-payer/src/lib/usage.ts (~625 tokens)
apps/fee-payer/wrangler.jsonc (~204 tokens)
apps/service-proxy/package.json (~95 tokens)
apps/service-proxy/README.md (~50 tokens)
apps/service-proxy/src/index.ts (~526 tokens)
apps/service-proxy/wrangler.jsonc (~120 tokens)
biome.json (~492 tokens)
package.json (~201 tokens)
pnpm-workspace.yaml (~382 tokens)
README.md (~273 tokens)

---
# End of llms.txt
# Included: 119 files, 564,261 characters (~146,053 tokens)
# Skipped: 0 files (binary or in excluded directories)
# Truncated: 0 files (showing first 1000 chars of large files)